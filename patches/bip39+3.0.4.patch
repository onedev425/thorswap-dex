diff --git a/node_modules/bip39/src/_wordlists.js b/node_modules/bip39/src/_wordlists.js
index 4cf7f47..c953a34 100644
--- a/node_modules/bip39/src/_wordlists.js
+++ b/node_modules/bip39/src/_wordlists.js
@@ -1,61 +1,27 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-// browserify by default only pulls in files that are hard coded in requires
-// In order of last to first in this file, the default wordlist will be chosen
-// based on what is present. (Bundles may remove wordlists they don't need)
-const wordlists = {};
-exports.wordlists = wordlists;
-let _default;
-exports._default = _default;
-try {
-    exports._default = _default = require('./wordlists/czech.json');
-    wordlists.czech = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/chinese_simplified.json');
-    wordlists.chinese_simplified = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/chinese_traditional.json');
-    wordlists.chinese_traditional = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/korean.json');
-    wordlists.korean = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/french.json');
-    wordlists.french = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/italian.json');
-    wordlists.italian = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/spanish.json');
-    wordlists.spanish = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/japanese.json');
-    wordlists.japanese = _default;
-    wordlists.JA = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/portuguese.json');
-    wordlists.portuguese = _default;
-}
-catch (err) { }
-try {
-    exports._default = _default = require('./wordlists/english.json');
-    wordlists.english = _default;
-    wordlists.EN = _default;
-}
-catch (err) { }
+import czech from './wordlists/czech.json'
+import chinese_simplified from './wordlists/chinese_simplified.json'
+import chinese_traditional from './wordlists/chinese_traditional.json'
+import korean from './wordlists/korean.json'
+import french from './wordlists/french.json'
+import italian from './wordlists/italian.json'
+import spanish from './wordlists/spanish.json'
+import japanese from './wordlists/japanese.json'
+import portuguese from './wordlists/portuguese.json'
+import english from './wordlists/english.json'
+
+export const wordlists = {
+    czech,
+    chinese_simplified,
+    chinese_traditional,
+    korean,
+    french,
+    italian,
+    spanish,
+    japanese,
+    portuguese,
+    english,
+    JA: japanese,
+    EN: english,
+};
+
+export default english;
diff --git a/node_modules/bip39/src/index.js b/node_modules/bip39/src/index.js
index 91d1a72..a902f1d 100644
--- a/node_modules/bip39/src/index.js
+++ b/node_modules/bip39/src/index.js
@@ -1,15 +1,14 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-const createHash = require("create-hash");
-const pbkdf2_1 = require("pbkdf2");
-const randomBytes = require("randombytes");
-const _wordlists_1 = require("./_wordlists");
-let DEFAULT_WORDLIST = _wordlists_1._default;
+import createHash from "create-hash";
+import pbkdf2_1 from "pbkdf2";
+import randomBytes from "randombytes";
+import defaultWordlist, {wordlists} from "./_wordlists";
+let DEFAULT_WORDLIST = defaultWordlist
 const INVALID_MNEMONIC = 'Invalid mnemonic';
 const INVALID_ENTROPY = 'Invalid entropy';
 const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
 const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
     'Please pass a 2048 word array explicitly.';
+
 function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
     return Promise.resolve().then(() => new Promise((resolve, reject) => {
         const callback = (err, derivedKey) => {
@@ -26,18 +25,22 @@ function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
 function normalize(str) {
     return (str || '').normalize('NFKD');
 }
+
 function lpad(str, padString, length) {
     while (str.length < length) {
         str = padString + str;
     }
     return str;
 }
+
 function binaryToByte(bin) {
     return parseInt(bin, 2);
 }
+
 function bytesToBinary(bytes) {
     return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
 }
+
 function deriveChecksumBits(entropyBuffer) {
     const ENT = entropyBuffer.length * 8;
     const CS = ENT / 32;
@@ -46,15 +49,17 @@ function deriveChecksumBits(entropyBuffer) {
         .digest();
     return bytesToBinary(Array.from(hash)).slice(0, CS);
 }
+
 function salt(password) {
     return 'mnemonic' + (password || '');
 }
+
 function mnemonicToSeedSync(mnemonic, password) {
     const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
     const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
     return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
 }
-exports.mnemonicToSeedSync = mnemonicToSeedSync;
+
 function mnemonicToSeed(mnemonic, password) {
     return Promise.resolve().then(() => {
         const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
@@ -62,7 +67,7 @@ function mnemonicToSeed(mnemonic, password) {
         return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
     });
 }
-exports.mnemonicToSeed = mnemonicToSeed;
+
 function mnemonicToEntropy(mnemonic, wordlist) {
     wordlist = wordlist || DEFAULT_WORDLIST;
     if (!wordlist) {
@@ -104,7 +109,7 @@ function mnemonicToEntropy(mnemonic, wordlist) {
     }
     return entropy.toString('hex');
 }
-exports.mnemonicToEntropy = mnemonicToEntropy;
+
 function entropyToMnemonic(entropy, wordlist) {
     if (!Buffer.isBuffer(entropy)) {
         entropy = Buffer.from(entropy, 'hex');
@@ -135,7 +140,7 @@ function entropyToMnemonic(entropy, wordlist) {
         ? words.join('\u3000')
         : words.join(' ');
 }
-exports.entropyToMnemonic = entropyToMnemonic;
+
 function generateMnemonic(strength, rng, wordlist) {
     strength = strength || 128;
     if (strength % 32 !== 0) {
@@ -144,19 +149,20 @@ function generateMnemonic(strength, rng, wordlist) {
     rng = rng || randomBytes;
     return entropyToMnemonic(rng(strength / 8), wordlist);
 }
-exports.generateMnemonic = generateMnemonic;
+
 function validateMnemonic(mnemonic, wordlist) {
     try {
         mnemonicToEntropy(mnemonic, wordlist);
     }
     catch (e) {
+        console.error(e)
         return false;
     }
     return true;
 }
-exports.validateMnemonic = validateMnemonic;
+
 function setDefaultWordlist(language) {
-    const result = _wordlists_1.wordlists[language];
+    const result = wordlists[language];
     if (result) {
         DEFAULT_WORDLIST = result;
     }
@@ -164,18 +170,27 @@ function setDefaultWordlist(language) {
         throw new Error('Could not find wordlist for language "' + language + '"');
     }
 }
-exports.setDefaultWordlist = setDefaultWordlist;
+
 function getDefaultWordlist() {
     if (!DEFAULT_WORDLIST) {
         throw new Error('No Default Wordlist set');
     }
-    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
+    return Object.keys(wordlists).filter((lang) => {
         if (lang === 'JA' || lang === 'EN') {
             return false;
         }
-        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
+        return wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
     })[0];
 }
-exports.getDefaultWordlist = getDefaultWordlist;
-var _wordlists_2 = require("./_wordlists");
-exports.wordlists = _wordlists_2.wordlists;
+
+export {
+    mnemonicToSeedSync,
+    mnemonicToSeed,
+    mnemonicToEntropy,
+    entropyToMnemonic,
+    generateMnemonic,
+    validateMnemonic,
+    setDefaultWordlist,
+    getDefaultWordlist,
+    wordlists,
+}
