diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/decoder/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/amino/decoder/index.d.ts
deleted file mode 100644
index f9eb802..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/decoder/index.d.ts
+++ /dev/null
@@ -1,18 +0,0 @@
-/// <reference types="node" />
-/**
- * @category amino
- * js amino UnmarshalBinaryLengthPrefixed
- * @param {Buffer} bytes
- * @param {Object} type
- * @returns {Object}
- *  */
-export declare const unMarshalBinaryLengthPrefixed: (bytes: Buffer, type: any) => any;
-/**
- * @category amino
- * js amino UnmarshalBinaryBare
- * @param {Buffer} bytes
- * @param {Object} type
- * @returns {Object}
- *  */
-export declare const unMarshalBinaryBare: (bytes: Buffer, type: any) => any;
-export declare const decodeFieldNumberAndTyp3: (bytes: Buffer) => any;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/decoder/index.js b/node_modules/@binance-chain/javascript-sdk/lib/amino/decoder/index.js
deleted file mode 100644
index 7c84c9c..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/decoder/index.js
+++ /dev/null
@@ -1,245 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.decodeFieldNumberAndTyp3 = exports.unMarshalBinaryBare = exports.unMarshalBinaryLengthPrefixed = void 0;
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _is_js = _interopRequireDefault(require("is_js"));
-
-var _protocolBuffersEncodings = require("protocol-buffers-encodings");
-
-var _encoderHelper = _interopRequireDefault(require("../../utils/encoderHelper"));
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-var decoder = function decoder(bytes, varType) {
-  var val = varType.decode(bytes, 0);
-  var offset = varType.encodingLength(val);
-  return {
-    val: val,
-    offset: offset
-  };
-};
-/**
- * @category amino
- * js amino UnmarshalBinaryLengthPrefixed
- * @param {Buffer} bytes
- * @param {Object} type
- * @returns {Object}
- *  */
-
-
-var unMarshalBinaryLengthPrefixed = function unMarshalBinaryLengthPrefixed(bytes, type) {
-  if (bytes.length === 0) throw new TypeError("Cannot decode empty bytes"); // read byte-length prefix
-
-  var _decoder = decoder(bytes, _protocolBuffersEncodings.varint),
-      len = _decoder.offset;
-
-  if (len < 0) throw new Error("Error reading msg byte-length prefix: got code ".concat(len));
-  bytes = bytes.slice(len);
-  return unMarshalBinaryBare(bytes, type);
-};
-/**
- * @category amino
- * js amino UnmarshalBinaryBare
- * @param {Buffer} bytes
- * @param {Object} type
- * @returns {Object}
- *  */
-
-
-exports.unMarshalBinaryLengthPrefixed = unMarshalBinaryLengthPrefixed;
-
-var unMarshalBinaryBare = function unMarshalBinaryBare(bytes, type) {
-  if (!_is_js["default"].object(type)) throw new TypeError("type should be object");
-  if (!Buffer.isBuffer(bytes)) throw new TypeError("bytes must be buffer");
-
-  if (_is_js["default"].array(type)) {
-    if (!_is_js["default"].object(type[0])) throw new TypeError("type should be object");
-    return decodeArrayBinary(bytes, type[0]);
-  }
-
-  return decodeBinary(bytes, type);
-};
-
-exports.unMarshalBinaryBare = unMarshalBinaryBare;
-
-var decodeBinary = function decodeBinary(bytes, type, isLengthPrefixed) {
-  if (Buffer.isBuffer(type)) {
-    return decoder(bytes, _protocolBuffersEncodings.bytes);
-  }
-
-  if (_is_js["default"].array(type)) {
-    return decodeArrayBinary(bytes, type);
-  }
-
-  if (_is_js["default"].number(type)) {
-    return decoder(bytes, _protocolBuffersEncodings.varint);
-  }
-
-  if (_is_js["default"]["boolean"](type)) {
-    return decoder(bytes, _protocolBuffersEncodings.bool);
-  }
-
-  if (_is_js["default"].string(type)) {
-    return decoder(bytes, _protocolBuffersEncodings.string);
-  }
-
-  if (_is_js["default"].object(type)) {
-    return decodeObjectBinary(bytes, type, isLengthPrefixed);
-  }
-
-  return;
-};
-
-var setDefaultValue = function setDefaultValue(type, key) {
-  if (_is_js["default"].object(type[key])) type[key] = null;
-  if (_is_js["default"].number(type[key])) type[key] = 0;
-  if (_is_js["default"]["boolean"](type[key])) type[key] = false;
-  if (_is_js["default"].string(type[key])) type[key] = "";
-};
-
-var decodeObjectBinary = function decodeObjectBinary(bytes, type, isLengthPrefixed) {
-  var objectOffset = 0; // read byte-length prefix
-
-  if (isLengthPrefixed) {
-    var _decoder2 = decoder(bytes, _protocolBuffersEncodings.varint),
-        len = _decoder2.offset;
-
-    bytes = bytes.slice(len);
-    objectOffset += len;
-  } // If registered concrete, consume and verify prefix bytes.
-
-
-  if (type.aminoPrefix) {
-    bytes = bytes.slice(4);
-    objectOffset += 4;
-  }
-
-  var lastFieldNum = 0;
-  var keys = Object.keys(type).filter(function (key) {
-    return key !== "aminoPrefix";
-  });
-  keys.forEach(function (key, index) {
-    if (_is_js["default"].array(type[key])) {
-      var _decodeArrayBinary = decodeArrayBinary(bytes, type[key][0]),
-          offset = _decodeArrayBinary.offset,
-          val = _decodeArrayBinary.val;
-
-      objectOffset += offset;
-      type[key] = val;
-      bytes = bytes.slice(offset);
-    } else {
-      var _decodeFieldNumberAnd = decodeFieldNumberAndTyp3(bytes),
-          fieldNum = _decodeFieldNumberAnd.fieldNum,
-          typ = _decodeFieldNumberAnd.typ; //if this field is default value, continue
-
-
-      if (index + 1 !== fieldNum || fieldNum < 0) {
-        setDefaultValue(type, key);
-        return;
-      }
-
-      if (fieldNum <= lastFieldNum) {
-        throw new Error("encountered fieldNum: ".concat(fieldNum, ", but we have already seen fnum: ").concat(lastFieldNum));
-      }
-
-      lastFieldNum = fieldNum;
-
-      if (index + 1 !== fieldNum) {
-        throw new Error("field number is not expected");
-      }
-
-      var typeWanted = (0, _encoderHelper["default"])(type[key]);
-
-      if (typ !== typeWanted) {
-        throw new Error("field type is not expected");
-      } //remove 1 byte of type
-
-
-      bytes = bytes.slice(1);
-
-      var _decodeBinary = decodeBinary(bytes, type[key], true),
-          _val = _decodeBinary.val,
-          _offset = _decodeBinary.offset;
-
-      type[key] = _val; //remove decoded bytes
-
-      bytes = bytes.slice(_offset);
-      objectOffset += _offset + 1;
-    }
-  });
-  return {
-    val: type,
-    offset: objectOffset
-  };
-};
-
-var decodeArrayBinary = function decodeArrayBinary(bytes, type) {
-  var arr = [];
-  var arrayOffset = 0;
-
-  var _decodeFieldNumberAnd2 = decodeFieldNumberAndTyp3(bytes),
-      fieldNumber = _decodeFieldNumberAnd2.fieldNum;
-
-  while (true) {
-    var _decodeFieldNumberAnd3 = decodeFieldNumberAndTyp3(bytes),
-        fieldNum = _decodeFieldNumberAnd3.fieldNum;
-
-    if (fieldNum !== fieldNumber || fieldNum < 0) break; //remove 1 byte of encoded field number and type
-
-    bytes = bytes.slice(1); //is default value, skip and continue read bytes
-    // if (bytes.length > 0 && bytes[0] === 0x00) continue
-
-    if (bytes.length > 0 && bytes.readUInt8(0) === 0x00) continue;
-
-    var _decodeBinary2 = decodeBinary(bytes, type, true),
-        offset = _decodeBinary2.offset,
-        val = _decodeBinary2.val;
-
-    arr.push(_objectSpread({}, val));
-    bytes = bytes.slice(offset + 1); //add 1 byte of type
-
-    arrayOffset += offset + 1;
-    fieldNumber = fieldNum;
-  } // console.log(arr)
-
-
-  return {
-    val: arr,
-    offset: arrayOffset
-  };
-};
-
-var decodeFieldNumberAndTyp3 = function decodeFieldNumberAndTyp3(bytes) {
-  if (bytes.length < 2) {
-    //default value
-    return {
-      fieldNum: -1
-    };
-  }
-
-  var _decoder3 = decoder(bytes, _protocolBuffersEncodings.varint),
-      val = _decoder3.val;
-
-  var typ = val & 7;
-  var fieldNum = val >> 3;
-
-  if (fieldNum > 1 << 29 - 1) {
-    throw new Error("invalid field num ".concat(fieldNum));
-  }
-
-  return {
-    fieldNum: fieldNum,
-    typ: typ
-  };
-};
-
-exports.decodeFieldNumberAndTyp3 = decodeFieldNumberAndTyp3;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/index.d.ts
deleted file mode 100644
index 2b3930f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/index.d.ts
+++ /dev/null
@@ -1,74 +0,0 @@
-/// <reference types="node" />
-/**
- * encode number
- * @category amino
- * @param num
- */
-export declare const encodeNumber: (num: number) => any;
-/**
- * encode bool
- * @category amino
- * @param b
- */
-export declare const encodeBool: (b: boolean) => any;
-/**
- * encode string
- * @category amino
- * @param str
- */
-export declare const encodeString: (str: string) => Buffer;
-/**
- * encode time
- * @category amino
- * @param value
- */
-export declare const encodeTime: (value: string | Date) => Buffer;
-/**
- * @category amino
- * @param obj -- {object}
- * @return bytes {Buffer}
- */
-export declare const convertObjectToSignBytes: (obj: any) => Buffer;
-/**
- * js amino MarshalBinary
- * @category amino
- * @param {Object} obj
- *  */
-export declare const marshalBinary: (obj: any) => any;
-/**
- * js amino MarshalBinaryBare
- * @category amino
- * @param {Object} obj
- *  */
-export declare const marshalBinaryBare: (obj: any) => any;
-/**
- * This is the main entrypoint for encoding all types in binary form.
- * @category amino
- * @param {*} js data type (not null, not undefined)
- * @param {Number} field index of object
- * @param {Boolean} isByteLenPrefix
- * @return {Buffer} binary of object.
- */
-export declare const encodeBinary: (val: any, fieldNum?: number | undefined, isByteLenPrefix?: boolean | undefined) => any;
-/**
- * prefixed with bytes length
- * @category amino
- * @param {Buffer} bytes
- * @return {Buffer} with bytes length prefixed
- */
-export declare const encodeBinaryByteArray: (bytes: Buffer) => Buffer;
-/**
- * @category amino
- * @param {Object} obj
- * @return {Buffer} with bytes length prefixed
- */
-export declare const encodeObjectBinary: (obj: any, isByteLenPrefix?: boolean | undefined) => Buffer;
-/**
- * @category amino
- * @param {Number} fieldNum object field index
- * @param {Array} arr
- * @param {Boolean} isByteLenPrefix
- * @return {Buffer} bytes of array
- */
-export declare const encodeArrayBinary: (fieldNum: number | undefined, arr: any[], isByteLenPrefix?: boolean | undefined) => Buffer;
-export * from "./varint";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/index.js b/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/index.js
deleted file mode 100644
index 0c9c554..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/index.js
+++ /dev/null
@@ -1,294 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-var _exportNames = {
-  encodeNumber: true,
-  encodeBool: true,
-  encodeString: true,
-  encodeTime: true,
-  convertObjectToSignBytes: true,
-  marshalBinary: true,
-  marshalBinaryBare: true,
-  encodeBinary: true,
-  encodeBinaryByteArray: true,
-  encodeObjectBinary: true,
-  encodeArrayBinary: true
-};
-exports.encodeArrayBinary = exports.encodeObjectBinary = exports.encodeBinaryByteArray = exports.encodeBinary = exports.marshalBinaryBare = exports.marshalBinary = exports.convertObjectToSignBytes = exports.encodeTime = exports.encodeString = exports.encodeBool = exports.encodeNumber = void 0;
-
-var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
-
-var _is_js = _interopRequireDefault(require("is_js"));
-
-var _protocolBuffersEncodings = require("protocol-buffers-encodings");
-
-var _encoderHelper = _interopRequireDefault(require("../../utils/encoderHelper"));
-
-var _varint = require("./varint");
-
-Object.keys(_varint).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _varint[key];
-    }
-  });
-});
-
-var sortObject = function sortObject(obj) {
-  if (obj === null) return null;
-  if ((0, _typeof2["default"])(obj) !== "object") return obj; // arrays have typeof "object" in js!
-
-  if (Array.isArray(obj)) return obj.map(sortObject);
-  var sortedKeys = Object.keys(obj).sort();
-  var result = {};
-  sortedKeys.forEach(function (key) {
-    result[key] = sortObject(obj[key]);
-  });
-  return result;
-};
-/**
- * encode number
- * @category amino
- * @param num
- */
-
-
-var encodeNumber = function encodeNumber(num) {
-  return _varint.UVarInt.encode(num);
-};
-/**
- * encode bool
- * @category amino
- * @param b
- */
-
-
-exports.encodeNumber = encodeNumber;
-
-var encodeBool = function encodeBool(b) {
-  return b ? _varint.UVarInt.encode(1) : _varint.UVarInt.encode(0);
-};
-/**
- * encode string
- * @category amino
- * @param str
- */
-
-
-exports.encodeBool = encodeBool;
-
-var encodeString = function encodeString(str) {
-  var buf = Buffer.alloc(_protocolBuffersEncodings.string.encodingLength(str));
-  return _protocolBuffersEncodings.string.encode(str, buf, 0);
-};
-/**
- * encode time
- * @category amino
- * @param value
- */
-
-
-exports.encodeString = encodeString;
-
-var encodeTime = function encodeTime(value) {
-  var millis = new Date(value).getTime();
-  var seconds = Math.floor(millis / 1000);
-  var nanos = Number(seconds.toString().padEnd(9, "0"));
-  var buffer = Buffer.alloc(14); // buffer[0] = (1 << 3) | 1 // field 1, typ3 1
-
-  buffer.writeInt32LE(1 << 3 | 1, 0);
-  buffer.writeUInt32LE(seconds, 1); // buffer[9] = (2 << 3) | 5 // field 2, typ3 5
-
-  buffer.writeInt32LE(2 << 3 | 5, 9);
-  buffer.writeUInt32LE(nanos, 10);
-  return buffer;
-};
-/**
- * @category amino
- * @param obj -- {object}
- * @return bytes {Buffer}
- */
-
-
-exports.encodeTime = encodeTime;
-
-var convertObjectToSignBytes = function convertObjectToSignBytes(obj) {
-  return Buffer.from(JSON.stringify(sortObject(obj)));
-};
-/**
- * js amino MarshalBinary
- * @category amino
- * @param {Object} obj
- *  */
-
-
-exports.convertObjectToSignBytes = convertObjectToSignBytes;
-
-var marshalBinary = function marshalBinary(obj) {
-  if (!_is_js["default"].object(obj)) throw new TypeError("data must be an object");
-  return encodeBinary(obj, -1, true).toString("hex");
-};
-/**
- * js amino MarshalBinaryBare
- * @category amino
- * @param {Object} obj
- *  */
-
-
-exports.marshalBinary = marshalBinary;
-
-var marshalBinaryBare = function marshalBinaryBare(obj) {
-  if (!_is_js["default"].object(obj)) throw new TypeError("data must be an object");
-  return encodeBinary(obj).toString("hex");
-};
-/**
- * This is the main entrypoint for encoding all types in binary form.
- * @category amino
- * @param {*} js data type (not null, not undefined)
- * @param {Number} field index of object
- * @param {Boolean} isByteLenPrefix
- * @return {Buffer} binary of object.
- */
-
-
-exports.marshalBinaryBare = marshalBinaryBare;
-
-var encodeBinary = function encodeBinary(val, fieldNum, isByteLenPrefix) {
-  if (val === null || val === undefined) throw new TypeError("unsupported type");
-
-  if (Buffer.isBuffer(val)) {
-    if (isByteLenPrefix) {
-      return Buffer.concat([_varint.UVarInt.encode(val.length), val]);
-    }
-
-    return val;
-  }
-
-  if (_is_js["default"].array(val)) {
-    return encodeArrayBinary(fieldNum, val, isByteLenPrefix);
-  }
-
-  if (_is_js["default"].number(val)) {
-    return encodeNumber(val);
-  }
-
-  if (_is_js["default"]["boolean"](val)) {
-    return encodeBool(val);
-  }
-
-  if (_is_js["default"].string(val)) {
-    return encodeString(val);
-  }
-
-  if (_is_js["default"].object(val)) {
-    return encodeObjectBinary(val, isByteLenPrefix);
-  }
-
-  return;
-};
-/**
- * prefixed with bytes length
- * @category amino
- * @param {Buffer} bytes
- * @return {Buffer} with bytes length prefixed
- */
-
-
-exports.encodeBinary = encodeBinary;
-
-var encodeBinaryByteArray = function encodeBinaryByteArray(bytes) {
-  var lenPrefix = bytes.length;
-  return Buffer.concat([_varint.UVarInt.encode(lenPrefix), bytes]);
-};
-/**
- * @category amino
- * @param {Object} obj
- * @return {Buffer} with bytes length prefixed
- */
-
-
-exports.encodeBinaryByteArray = encodeBinaryByteArray;
-
-var encodeObjectBinary = function encodeObjectBinary(obj, isByteLenPrefix) {
-  var bufferArr = [];
-  Object.keys(obj).forEach(function (key, index) {
-    if (key === "aminoPrefix" || key === "version") return;
-    if (isDefaultValue(obj[key])) return;
-
-    if (_is_js["default"].array(obj[key]) && obj[key].length > 0) {
-      bufferArr.push(encodeArrayBinary(index, obj[key]));
-    } else {
-      bufferArr.push(encodeTypeAndField(index, obj[key]));
-      bufferArr.push(encodeBinary(obj[key], index, true));
-    }
-  });
-  var bytes = Buffer.concat(bufferArr); // add prefix
-
-  if (obj.aminoPrefix) {
-    var prefix = Buffer.from(obj.aminoPrefix, "hex");
-    bytes = Buffer.concat([prefix, bytes]);
-  } // Write byte-length prefixed.
-
-
-  if (isByteLenPrefix) {
-    var lenBytes = _varint.UVarInt.encode(bytes.length);
-
-    bytes = Buffer.concat([lenBytes, bytes]);
-  }
-
-  return bytes;
-};
-/**
- * @category amino
- * @param {Number} fieldNum object field index
- * @param {Array} arr
- * @param {Boolean} isByteLenPrefix
- * @return {Buffer} bytes of array
- */
-
-
-exports.encodeObjectBinary = encodeObjectBinary;
-
-var encodeArrayBinary = function encodeArrayBinary(fieldNum, arr, isByteLenPrefix) {
-  var result = [];
-  arr.forEach(function (item) {
-    result.push(encodeTypeAndField(fieldNum, item));
-
-    if (isDefaultValue(item)) {
-      result.push(Buffer.from("00", "hex"));
-      return;
-    }
-
-    result.push(encodeBinary(item, fieldNum, true));
-  }); //encode length
-
-  if (isByteLenPrefix) {
-    var length = result.reduce(function (prev, item) {
-      return prev + item.length;
-    }, 0);
-    result.unshift(_varint.UVarInt.encode(length));
-  }
-
-  return Buffer.concat(result);
-}; // Write field key.
-
-
-exports.encodeArrayBinary = encodeArrayBinary;
-
-var encodeTypeAndField = function encodeTypeAndField(index, field) {
-  index = Number(index);
-  var value = index + 1 << 3 | (0, _encoderHelper["default"])(field);
-  return _varint.UVarInt.encode(value);
-};
-
-var isDefaultValue = function isDefaultValue(obj) {
-  if (obj === null) return false;
-  return _is_js["default"].number(obj) && obj === 0 || _is_js["default"].string(obj) && obj === "" || _is_js["default"].array(obj) && obj.length === 0 || _is_js["default"]["boolean"](obj) && !obj;
-};
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/varint.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/varint.d.ts
deleted file mode 100644
index 723d384..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/varint.d.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-/// <reference types="node" />
-export declare const UVarInt: {
-    encode: (n: number, buffer?: Buffer | any, offset?: number | undefined) => any;
-    decode: (bytes: Buffer | any) => number;
-    encodingLength: (n: number) => number;
-};
-export declare const VarInt: {
-    encode: (n: number, buffer?: Buffer | any, offset?: number | undefined) => any;
-    decode: (bytes: Buffer | any) => number;
-    encodingLength: (n: number) => number;
-};
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/varint.js b/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/varint.js
deleted file mode 100644
index 8a85035..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/encoder/varint.js
+++ /dev/null
@@ -1,90 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.VarInt = exports.UVarInt = void 0;
-
-var _bn = _interopRequireDefault(require("bn.js"));
-
-function VarIntFunc(signed) {
-  var encodingLength = function encodingLength(n) {
-    if (signed) n *= 2;
-
-    if (n < 0) {
-      throw Error("varint value is out of bounds");
-    }
-
-    var bits = Math.log2(n + 1);
-    return Math.ceil(bits / 7) || 1;
-  };
-
-  var encode = function encode(n, buffer, offset) {
-    if (n < 0) {
-      throw Error("varint value is out of bounds");
-    }
-
-    buffer = buffer || Buffer.alloc(encodingLength(n));
-    offset = offset || 0;
-    var nStr = n.toString();
-    var bn = new _bn["default"](nStr, 10);
-    var num255 = new _bn["default"](0xff);
-    var num128 = new _bn["default"](0x80); // amino signed varint is multiplied by 2
-
-    if (signed) {
-      bn = bn.muln(2);
-    }
-
-    var i = 0;
-
-    while (bn.gten(0x80)) {
-      buffer[offset + i] = bn.and(num255).or(num128).toNumber();
-      bn = bn.shrn(7);
-      i++;
-    }
-
-    buffer[offset + i] = bn.andln(0xff); // TODO
-    // encode.bytes = i + 1
-
-    return buffer;
-  };
-  /**
-   * https://github.com/golang/go/blob/master/src/encoding/binary/varint.go#L60
-   */
-
-
-  var decode = function decode(bytes) {
-    var x = 0;
-    var s = 0;
-
-    for (var i = 0, len = bytes.length; i < len; i++) {
-      var b = bytes[i];
-
-      if (b < 0x80) {
-        if (i > 9 || i === 9 && b > 1) {
-          return 0;
-        }
-
-        return x | b << s;
-      }
-
-      x |= (b & 0x7f) << s;
-      s += 7;
-    }
-
-    return 0;
-  };
-
-  return {
-    encode: encode,
-    decode: decode,
-    encodingLength: encodingLength
-  };
-}
-
-var UVarInt = VarIntFunc(false);
-exports.UVarInt = UVarInt;
-var VarInt = VarIntFunc(true);
-exports.VarInt = VarInt;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/amino/index.d.ts
deleted file mode 100644
index 3306b1b..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/index.d.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-import * as decoder from "./decoder";
-import * as encoder from "./encoder";
-export { decoder, encoder };
-export * from "./decoder";
-export * from "./encoder";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/amino/index.js b/node_modules/@binance-chain/javascript-sdk/lib/amino/index.js
deleted file mode 100644
index c14b363..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/amino/index.js
+++ /dev/null
@@ -1,40 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-var _exportNames = {
-  decoder: true,
-  encoder: true
-};
-exports.encoder = exports.decoder = void 0;
-
-var decoder = _interopRequireWildcard(require("./decoder"));
-
-exports.decoder = decoder;
-Object.keys(decoder).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return decoder[key];
-    }
-  });
-});
-
-var encoder = _interopRequireWildcard(require("./encoder"));
-
-exports.encoder = encoder;
-Object.keys(encoder).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return encoder[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/bridge/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/client/bridge/index.d.ts
deleted file mode 100644
index 5242ad6..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/bridge/index.d.ts
+++ /dev/null
@@ -1,78 +0,0 @@
-import { BncClient } from "../";
-import { TransferInClaim, TransferOutRefundClaim, UpdateBindClaim } from "../../types";
-/**
- * Bridge
- */
-export declare class Bridge {
-    private _bncClient;
-    /**
-     * @param {BncClient} bncClient
-     */
-    constructor(bncClient: BncClient);
-    /**
-     * transfer smart chain token to binance chain receiver
-     */
-    transferIn({ sequence, contract_address, refund_addresses, receiver_addresses, amounts, relay_fee, expire_time, symbol, fromAddress, }: TransferInClaim & {
-        sequence: number;
-        fromAddress: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * refund tokens to sender if transfer to smart chain failed
-     */
-    transferOutRefund({ transfer_out_sequence, refund_address, refund_reason, amount, fromAddress, }: TransferOutRefundClaim & {
-        fromAddress: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * bind smart chain token to bep2 token
-     */
-    bind({ contractAddress, contractDecimal, amount, symbol, expireTime, fromAddress, }: {
-        contractAddress: string;
-        contractDecimal: number;
-        amount: number;
-        symbol: string;
-        expireTime: number;
-        fromAddress: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * transfer token from Binance Chain to Binance Smart Chain
-     */
-    transferFromBcToBsc({ toAddress, amount, symbol, expireTime, fromAddress, }: {
-        toAddress: string;
-        amount: number;
-        symbol: string;
-        expireTime: number;
-        fromAddress: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * update bind request when events from smart chain received
-     */
-    upateBind({ sequence, contract_address, symbol, status, fromAddress, }: UpdateBindClaim & {
-        sequence: number;
-        fromAddress: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    skipSequence({ sequence, sequenceToSkip, fromAddress, }: {
-        sequence: number;
-        sequenceToSkip: number;
-        fromAddress: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    private buildClaimAndBroadcast;
-    private broadcast;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/bridge/index.js b/node_modules/@binance-chain/javascript-sdk/lib/client/bridge/index.js
deleted file mode 100644
index e8e0aeb..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/bridge/index.js
+++ /dev/null
@@ -1,514 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.Bridge = void 0;
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _crypto = require("../../crypto");
-
-var _types = require("../../types");
-
-/**
- * Bridge
- */
-var Bridge = /*#__PURE__*/function () {
-  /**
-   * @param {BncClient} bncClient
-   */
-  function Bridge(bncClient) {
-    (0, _classCallCheck2["default"])(this, Bridge);
-    (0, _defineProperty2["default"])(this, "_bncClient", void 0);
-    this._bncClient = bncClient;
-  }
-  /**
-   * transfer smart chain token to binance chain receiver
-   */
-
-
-  (0, _createClass2["default"])(Bridge, [{
-    key: "transferIn",
-    value: function () {
-      var _transferIn = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
-        var sequence, contract_address, refund_addresses, receiver_addresses, amounts, relay_fee, expire_time, symbol, fromAddress, receiverAddresses, refundAddresses, claimHex;
-        return _regenerator["default"].wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                sequence = _ref.sequence, contract_address = _ref.contract_address, refund_addresses = _ref.refund_addresses, receiver_addresses = _ref.receiver_addresses, amounts = _ref.amounts, relay_fee = _ref.relay_fee, expire_time = _ref.expire_time, symbol = _ref.symbol, fromAddress = _ref.fromAddress;
-
-                if (!(sequence < 0)) {
-                  _context.next = 3;
-                  break;
-                }
-
-                throw new Error("sequence should not be less than 0");
-
-              case 3:
-                if (contract_address) {
-                  _context.next = 5;
-                  break;
-                }
-
-                throw new Error("contract address should not be empty");
-
-              case 5:
-                if (relay_fee) {
-                  _context.next = 7;
-                  break;
-                }
-
-                throw new Error("relay fee should not be empty");
-
-              case 7:
-                if (symbol) {
-                  _context.next = 9;
-                  break;
-                }
-
-                throw new Error("symbol should not be null");
-
-              case 9:
-                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {
-                  _context.next = 11;
-                  break;
-                }
-
-                throw new Error("fromAddress is not a valid Binance Chain address");
-
-              case 11:
-                if (!(refund_addresses.length != receiver_addresses.length || refund_addresses.length != amounts.length)) {
-                  _context.next = 13;
-                  break;
-                }
-
-                throw new Error("the length of refund address array, recipient address array and transfer amount array must be the same");
-
-              case 13:
-                receiverAddresses = receiver_addresses.map(function (address) {
-                  var addressHrp = address.startsWith("tbnb") ? "tbnb" : "bnb";
-
-                  if (!(0, _crypto.checkAddress)(address, addressHrp)) {
-                    throw new Error("".concat(address, " in receiver_addresses is not a valid Binance Chain address"));
-                  }
-
-                  return (0, _crypto.decodeAddress)(address);
-                });
-                refundAddresses = refund_addresses.map(function (address) {
-                  if (!address.startsWith("0x")) {
-                    throw new Error("".concat(address, " is invalid"));
-                  }
-
-                  return Buffer.from(address.slice(2), "hex");
-                });
-                claimHex = Buffer.from(JSON.stringify({
-                  contract_address: contract_address,
-                  refund_addresses: refundAddresses,
-                  receiver_addresses: receiverAddresses,
-                  amounts: amounts,
-                  symbol: symbol,
-                  relay_fee: relay_fee,
-                  expire_time: expire_time
-                })).toString("hex");
-                return _context.abrupt("return", this.buildClaimAndBroadcast({
-                  claimHex: claimHex,
-                  claim_type: _types.ClaimTypes.ClaimTypeTransferIn,
-                  fromAddress: fromAddress,
-                  sequence: sequence
-                }));
-
-              case 17:
-              case "end":
-                return _context.stop();
-            }
-          }
-        }, _callee, this);
-      }));
-
-      function transferIn(_x) {
-        return _transferIn.apply(this, arguments);
-      }
-
-      return transferIn;
-    }()
-    /**
-     * refund tokens to sender if transfer to smart chain failed
-     */
-
-  }, {
-    key: "transferOutRefund",
-    value: function () {
-      var _transferOutRefund = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref2) {
-        var transfer_out_sequence, refund_address, refund_reason, amount, fromAddress, claimHex;
-        return _regenerator["default"].wrap(function _callee2$(_context2) {
-          while (1) {
-            switch (_context2.prev = _context2.next) {
-              case 0:
-                transfer_out_sequence = _ref2.transfer_out_sequence, refund_address = _ref2.refund_address, refund_reason = _ref2.refund_reason, amount = _ref2.amount, fromAddress = _ref2.fromAddress;
-
-                if (!(transfer_out_sequence < 0)) {
-                  _context2.next = 3;
-                  break;
-                }
-
-                throw new Error("sequence should not be less than 0");
-
-              case 3:
-                if (amount) {
-                  _context2.next = 5;
-                  break;
-                }
-
-                throw new Error("amount should not be empty");
-
-              case 5:
-                if (refund_reason) {
-                  _context2.next = 7;
-                  break;
-                }
-
-                throw new Error("empty refund reason");
-
-              case 7:
-                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {
-                  _context2.next = 9;
-                  break;
-                }
-
-                throw new Error("fromAddress is not a valid Binance Chain address");
-
-              case 9:
-                claimHex = Buffer.from(JSON.stringify({
-                  transfer_out_sequence: transfer_out_sequence,
-                  refund_address: refund_address,
-                  amount: amount,
-                  refund_reason: refund_reason
-                })).toString("hex");
-                return _context2.abrupt("return", this.buildClaimAndBroadcast({
-                  claimHex: claimHex,
-                  claim_type: _types.ClaimTypes.ClaimTypeTransferOutRefund,
-                  sequence: transfer_out_sequence,
-                  fromAddress: fromAddress
-                }));
-
-              case 11:
-              case "end":
-                return _context2.stop();
-            }
-          }
-        }, _callee2, this);
-      }));
-
-      function transferOutRefund(_x2) {
-        return _transferOutRefund.apply(this, arguments);
-      }
-
-      return transferOutRefund;
-    }()
-    /**
-     * bind smart chain token to bep2 token
-     */
-
-  }, {
-    key: "bind",
-    value: function () {
-      var _bind = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref3) {
-        var contractAddress, contractDecimal, amount, symbol, expireTime, fromAddress, bindMsg;
-        return _regenerator["default"].wrap(function _callee3$(_context3) {
-          while (1) {
-            switch (_context3.prev = _context3.next) {
-              case 0:
-                contractAddress = _ref3.contractAddress, contractDecimal = _ref3.contractDecimal, amount = _ref3.amount, symbol = _ref3.symbol, expireTime = _ref3.expireTime, fromAddress = _ref3.fromAddress;
-
-                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {
-                  _context3.next = 3;
-                  break;
-                }
-
-                throw new Error("fromAddress is not a valid Binance Chain address");
-
-              case 3:
-                if (contractAddress.startsWith("0x")) {
-                  _context3.next = 5;
-                  break;
-                }
-
-                throw new Error("contractAddress \"".concat(contractAddress, "\" is invalid"));
-
-              case 5:
-                bindMsg = new _types.BindMsg({
-                  from: fromAddress,
-                  amount: amount,
-                  contract_address: contractAddress,
-                  contract_decimals: contractDecimal,
-                  expire_time: expireTime,
-                  symbol: symbol
-                });
-                _context3.next = 8;
-                return this.broadcast(bindMsg, fromAddress);
-
-              case 8:
-                return _context3.abrupt("return", _context3.sent);
-
-              case 9:
-              case "end":
-                return _context3.stop();
-            }
-          }
-        }, _callee3, this);
-      }));
-
-      function bind(_x3) {
-        return _bind.apply(this, arguments);
-      }
-
-      return bind;
-    }()
-    /**
-     * transfer token from Binance Chain to Binance Smart Chain
-     */
-
-  }, {
-    key: "transferFromBcToBsc",
-    value: function () {
-      var _transferFromBcToBsc = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(_ref4) {
-        var toAddress, amount, symbol, expireTime, fromAddress, transferOut;
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                toAddress = _ref4.toAddress, amount = _ref4.amount, symbol = _ref4.symbol, expireTime = _ref4.expireTime, fromAddress = _ref4.fromAddress;
-
-                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {
-                  _context4.next = 3;
-                  break;
-                }
-
-                throw new Error("fromAddress is not a valid Binance Chain address");
-
-              case 3:
-                if (toAddress.startsWith("0x")) {
-                  _context4.next = 5;
-                  break;
-                }
-
-                throw new Error("toAddress \"".concat(toAddress, "\" is invalid"));
-
-              case 5:
-                transferOut = new _types.TransferOutMsg({
-                  from: fromAddress,
-                  to: toAddress,
-                  amount: {
-                    denom: symbol,
-                    amount: amount
-                  },
-                  expire_time: expireTime
-                });
-                return _context4.abrupt("return", this.broadcast(transferOut, fromAddress));
-
-              case 7:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this);
-      }));
-
-      function transferFromBcToBsc(_x4) {
-        return _transferFromBcToBsc.apply(this, arguments);
-      }
-
-      return transferFromBcToBsc;
-    }()
-    /**
-     * update bind request when events from smart chain received
-     */
-
-  }, {
-    key: "upateBind",
-    value: function () {
-      var _upateBind = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(_ref5) {
-        var sequence, contract_address, symbol, status, fromAddress, claimHex;
-        return _regenerator["default"].wrap(function _callee5$(_context5) {
-          while (1) {
-            switch (_context5.prev = _context5.next) {
-              case 0:
-                sequence = _ref5.sequence, contract_address = _ref5.contract_address, symbol = _ref5.symbol, status = _ref5.status, fromAddress = _ref5.fromAddress;
-
-                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {
-                  _context5.next = 3;
-                  break;
-                }
-
-                throw new Error("fromAddress is not a valid Binance Chain address");
-
-              case 3:
-                if (contract_address.startsWith("0x")) {
-                  _context5.next = 5;
-                  break;
-                }
-
-                throw new Error("toAddress \"".concat(contract_address, "\" is invalid"));
-
-              case 5:
-                claimHex = Buffer.from(JSON.stringify({
-                  status: status,
-                  symbol: symbol,
-                  contract_address: contract_address
-                })).toString("hex");
-                return _context5.abrupt("return", this.buildClaimAndBroadcast({
-                  claimHex: claimHex,
-                  sequence: sequence,
-                  fromAddress: fromAddress,
-                  claim_type: _types.ClaimTypes.ClaimTypeUpdateBind
-                }));
-
-              case 7:
-              case "end":
-                return _context5.stop();
-            }
-          }
-        }, _callee5, this);
-      }));
-
-      function upateBind(_x5) {
-        return _upateBind.apply(this, arguments);
-      }
-
-      return upateBind;
-    }()
-  }, {
-    key: "skipSequence",
-    value: function () {
-      var _skipSequence = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(_ref6) {
-        var sequence, sequenceToSkip, fromAddress, claimHex;
-        return _regenerator["default"].wrap(function _callee6$(_context6) {
-          while (1) {
-            switch (_context6.prev = _context6.next) {
-              case 0:
-                sequence = _ref6.sequence, sequenceToSkip = _ref6.sequenceToSkip, fromAddress = _ref6.fromAddress;
-
-                if (!(sequence < 0)) {
-                  _context6.next = 3;
-                  break;
-                }
-
-                throw new Error("sequence should not be less than 0");
-
-              case 3:
-                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {
-                  _context6.next = 5;
-                  break;
-                }
-
-                throw new Error("fromAddress is not a valid Binance Chain address");
-
-              case 5:
-                claimHex = Buffer.from(JSON.stringify({
-                  claim_type: _types.ClaimTypes.ClaimTypeUpdateBind,
-                  sequence: sequenceToSkip
-                })).toString("hex");
-                return _context6.abrupt("return", this.buildClaimAndBroadcast({
-                  claimHex: claimHex,
-                  sequence: sequence,
-                  fromAddress: fromAddress,
-                  claim_type: _types.ClaimTypes.ClaimTypeSkipSequence
-                }));
-
-              case 7:
-              case "end":
-                return _context6.stop();
-            }
-          }
-        }, _callee6, this);
-      }));
-
-      function skipSequence(_x6) {
-        return _skipSequence.apply(this, arguments);
-      }
-
-      return skipSequence;
-    }()
-  }, {
-    key: "buildClaimAndBroadcast",
-    value: function () {
-      var _buildClaimAndBroadcast = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(_ref7) {
-        var claimHex, claim_type, sequence, fromAddress, claimMsg;
-        return _regenerator["default"].wrap(function _callee7$(_context7) {
-          while (1) {
-            switch (_context7.prev = _context7.next) {
-              case 0:
-                claimHex = _ref7.claimHex, claim_type = _ref7.claim_type, sequence = _ref7.sequence, fromAddress = _ref7.fromAddress;
-                claimMsg = new _types.ClaimMsg({
-                  claim_type: claim_type,
-                  sequence: sequence,
-                  claim: claimHex,
-                  validator_address: fromAddress
-                });
-                _context7.next = 4;
-                return this.broadcast(claimMsg, fromAddress, sequence);
-
-              case 4:
-                return _context7.abrupt("return", _context7.sent);
-
-              case 5:
-              case "end":
-                return _context7.stop();
-            }
-          }
-        }, _callee7, this);
-      }));
-
-      function buildClaimAndBroadcast(_x7) {
-        return _buildClaimAndBroadcast.apply(this, arguments);
-      }
-
-      return buildClaimAndBroadcast;
-    }()
-  }, {
-    key: "broadcast",
-    value: function () {
-      var _broadcast = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(msg, fromAddress, sequence) {
-        var signedTx;
-        return _regenerator["default"].wrap(function _callee8$(_context8) {
-          while (1) {
-            switch (_context8.prev = _context8.next) {
-              case 0:
-                _context8.next = 2;
-                return this._bncClient._prepareTransaction(msg.getMsg(), msg.getSignMsg(), fromAddress, sequence);
-
-              case 2:
-                signedTx = _context8.sent;
-                return _context8.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 4:
-              case "end":
-                return _context8.stop();
-            }
-          }
-        }, _callee8, this);
-      }));
-
-      function broadcast(_x8, _x9, _x10) {
-        return _broadcast.apply(this, arguments);
-      }
-
-      return broadcast;
-    }()
-  }]);
-  return Bridge;
-}();
-
-exports.Bridge = Bridge;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/client/gov/index.d.ts
deleted file mode 100644
index c2d7ec0..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/index.d.ts
+++ /dev/null
@@ -1,117 +0,0 @@
-import { BigSource } from "big.js";
-import { BncClient } from "..";
-import { Coin } from "../../types";
-declare const proposalTypeMapping: {
-    readonly 4: "ListTradingPair";
-    readonly 0: "Nil";
-    readonly 1: "Text";
-    readonly 2: "ParameterChange";
-    readonly 3: "SoftwareUpgrade";
-    readonly 5: "FeeChange";
-    readonly 6: "CreateValidator";
-    readonly 7: "RemoveValidator";
-};
-/**
- * VoteOption
- * @ignore
- * @example
- * OptionEmpty - 0x00
- * OptionYes - 0x01
- * OptionAbstain - 0x02
- * OptionNo - 0x03
- * OptionNoWithVeto - 0x04
- */
-export declare const voteOption: {
-    readonly OptionEmpty: 0;
-    readonly OptionYes: 1;
-    readonly OptionAbstain: 2;
-    readonly OptionNo: 3;
-    readonly OptionNoWithVeto: 4;
-};
-declare const voteOptionMapping: {
-    0: string;
-    1: string;
-    2: string;
-    3: string;
-    4: string;
-};
-declare class Gov {
-    static instance: Gov;
-    private _bncClient;
-    /**
-     * @param {Object} bncClient
-     */
-    constructor(bncClient: BncClient);
-    /**
-     * Submit a list proposal along with an initial deposit
-     * @param {Object} listParams
-     * @example
-     * var listParams = {
-     *  title: 'New trading pair',
-     *  description: '',
-     *  baseAsset: 'BTC',
-     *  quoteAsset: 'BNB',
-     *  initPrice: 1,
-     *  address: '',
-     *  initialDeposit: 2000,
-     *  expireTime: 1570665600,
-     *  votingPeriod: 604800
-     * }
-     */
-    submitListProposal(listParams: {
-        baseAsset: string;
-        quoteAsset: string;
-        initPrice: BigSource;
-        description: string;
-        expireTime: string;
-        address: string;
-        title: string;
-        initialDeposit: BigSource;
-        votingPeriod: BigSource;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Submit a proposal along with an initial deposit.
-     * Proposal title, description, type and deposit can
-     * be given directly or through a proposal JSON file.
-     * @param {String} address
-     * @param {String} title
-     * @param {String} description
-     * @param {Number} proposalType
-     * @param {Number} initialDeposit
-     * @param {String} votingPeriod
-     * @return {Promise} resolves with response (success or fail)
-     */
-    submitProposal(address: string, title: string, description: string, proposalType: keyof typeof proposalTypeMapping, initialDeposit: BigSource, votingPeriod: BigSource): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Deposit tokens for activing proposal
-     * @param {Number} proposalId
-     * @param {String} address
-     * @param {Array} coins
-     * @example
-     * var coins = [{
-     *   "denom": "BNB",
-     *   "amount": 10
-     * }]
-     */
-    deposit(proposalId: number, address: string, coins: Coin[]): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     *
-     * @param {Number} proposalId
-     * @param {String} voter
-     * @param {VoteOption} option
-     */
-    vote(proposalId: number, voter: string, option: keyof typeof voteOptionMapping): Promise<{
-        result: any;
-        status: number;
-    }>;
-}
-export default Gov;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/index.js b/node_modules/@binance-chain/javascript-sdk/lib/client/gov/index.js
deleted file mode 100644
index 4ffe015..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/index.js
+++ /dev/null
@@ -1,333 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = exports.voteOption = void 0;
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var crypto = _interopRequireWildcard(require("../../crypto"));
-
-var _types = require("../../types");
-
-var _validateHelper = require("../../utils/validateHelper");
-
-var _proposalType = _interopRequireDefault(require("./proposalType"));
-
-// This is a circular dependecy; should be changed to `import type` asap
-var BASENUMBER = Math.pow(10, 8);
-var proposalTypeMapping = {
-  0x04: "ListTradingPair",
-  0x00: "Nil",
-  0x01: "Text",
-  0x02: "ParameterChange",
-  0x03: "SoftwareUpgrade",
-  0x05: "FeeChange",
-  0x06: "CreateValidator",
-  0x07: "RemoveValidator"
-};
-/**
- * VoteOption
- * @ignore
- * @example
- * OptionEmpty - 0x00
- * OptionYes - 0x01
- * OptionAbstain - 0x02
- * OptionNo - 0x03
- * OptionNoWithVeto - 0x04
- */
-
-var voteOption = {
-  OptionEmpty: 0x00,
-  OptionYes: 0x01,
-  OptionAbstain: 0x02,
-  OptionNo: 0x03,
-  OptionNoWithVeto: 0x04
-};
-exports.voteOption = voteOption;
-var voteOptionMapping = {
-  0x00: "Empty",
-  0x01: "Yes",
-  0x02: "Abstain",
-  0x03: "No",
-  0x04: "NoWithVeto"
-};
-
-var Gov = /*#__PURE__*/function () {
-  /**
-   * @param {Object} bncClient
-   */
-  function Gov(bncClient) {
-    (0, _classCallCheck2["default"])(this, Gov);
-    (0, _defineProperty2["default"])(this, "_bncClient", void 0);
-
-    if (!Gov.instance) {
-      this._bncClient = bncClient;
-      Gov.instance = this;
-    }
-
-    return Gov.instance;
-  }
-  /**
-   * Submit a list proposal along with an initial deposit
-   * @param {Object} listParams
-   * @example
-   * var listParams = {
-   *  title: 'New trading pair',
-   *  description: '',
-   *  baseAsset: 'BTC',
-   *  quoteAsset: 'BNB',
-   *  initPrice: 1,
-   *  address: '',
-   *  initialDeposit: 2000,
-   *  expireTime: 1570665600,
-   *  votingPeriod: 604800
-   * }
-   */
-
-
-  (0, _createClass2["default"])(Gov, [{
-    key: "submitListProposal",
-    value: function () {
-      var _submitListProposal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(listParams) {
-        var listTradingPairObj, description, address, title, initialDeposit, votingPeriod;
-        return _regenerator["default"].wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                listTradingPairObj = {
-                  base_asset_symbol: listParams.baseAsset,
-                  quote_asset_symbol: listParams.quoteAsset,
-                  init_price: +new _big["default"](listParams.initPrice).mul(BASENUMBER).toString(),
-                  description: listParams.description,
-                  expire_time: new Date(listParams.expireTime).toISOString()
-                };
-                description = JSON.stringify(listTradingPairObj);
-                address = listParams.address, title = listParams.title, initialDeposit = listParams.initialDeposit, votingPeriod = listParams.votingPeriod;
-                _context.next = 5;
-                return this.submitProposal(address, title, description, _proposalType["default"].ProposalTypeListTradingPair, initialDeposit, votingPeriod);
-
-              case 5:
-                return _context.abrupt("return", _context.sent);
-
-              case 6:
-              case "end":
-                return _context.stop();
-            }
-          }
-        }, _callee, this);
-      }));
-
-      function submitListProposal(_x) {
-        return _submitListProposal.apply(this, arguments);
-      }
-
-      return submitListProposal;
-    }()
-    /**
-     * Submit a proposal along with an initial deposit.
-     * Proposal title, description, type and deposit can
-     * be given directly or through a proposal JSON file.
-     * @param {String} address
-     * @param {String} title
-     * @param {String} description
-     * @param {Number} proposalType
-     * @param {Number} initialDeposit
-     * @param {String} votingPeriod
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "submitProposal",
-    value: function () {
-      var _submitProposal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(address, title, description, proposalType, initialDeposit, votingPeriod) {
-        var accAddress, coins, proposalMsg, signMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee2$(_context2) {
-          while (1) {
-            switch (_context2.prev = _context2.next) {
-              case 0:
-                accAddress = crypto.decodeAddress(address);
-                coins = [{
-                  denom: "BNB",
-                  amount: new _big["default"](initialDeposit).mul(BASENUMBER).toString()
-                }];
-                votingPeriod = +new _big["default"](votingPeriod).mul(Math.pow(10, 9)).toString();
-                proposalMsg = {
-                  title: title,
-                  description: description,
-                  proposal_type: proposalType,
-                  proposer: accAddress,
-                  initial_deposit: [{
-                    denom: "BNB",
-                    amount: +new _big["default"](initialDeposit).mul(BASENUMBER).toString()
-                  }],
-                  voting_period: votingPeriod,
-                  aminoPrefix: _types.AminoPrefix.MsgSubmitProposal
-                };
-                signMsg = {
-                  description: description,
-                  initial_deposit: coins,
-                  proposal_type: proposalTypeMapping[proposalType],
-                  proposer: address,
-                  title: title,
-                  voting_period: votingPeriod.toString()
-                };
-                _context2.next = 7;
-                return this._bncClient._prepareTransaction(proposalMsg, signMsg, address);
-
-              case 7:
-                signedTx = _context2.sent;
-                return _context2.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 9:
-              case "end":
-                return _context2.stop();
-            }
-          }
-        }, _callee2, this);
-      }));
-
-      function submitProposal(_x2, _x3, _x4, _x5, _x6, _x7) {
-        return _submitProposal.apply(this, arguments);
-      }
-
-      return submitProposal;
-    }()
-    /**
-     * Deposit tokens for activing proposal
-     * @param {Number} proposalId
-     * @param {String} address
-     * @param {Array} coins
-     * @example
-     * var coins = [{
-     *   "denom": "BNB",
-     *   "amount": 10
-     * }]
-     */
-
-  }, {
-    key: "deposit",
-    value: function () {
-      var _deposit = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(proposalId, address, coins) {
-        var accAddress, amount, depositMsg, signMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee3$(_context3) {
-          while (1) {
-            switch (_context3.prev = _context3.next) {
-              case 0:
-                accAddress = crypto.decodeAddress(address);
-                (0, _validateHelper.checkCoins)(coins);
-                amount = [];
-                coins.forEach(function (coin) {
-                  amount.push({
-                    denom: coin.denom,
-                    amount: +new _big["default"](coin.amount).mul(BASENUMBER).toString()
-                  });
-                });
-                depositMsg = {
-                  proposal_id: proposalId,
-                  depositer: accAddress,
-                  amount: amount,
-                  aminoPrefix: _types.AminoPrefix.MsgDeposit
-                };
-                signMsg = {
-                  amount: amount.map(function (coin) {
-                    return {
-                      denom: coin.denom,
-                      amount: String(coin.amount)
-                    };
-                  }),
-                  depositer: address,
-                  proposal_id: String(proposalId)
-                };
-                _context3.next = 8;
-                return this._bncClient._prepareTransaction(depositMsg, signMsg, address);
-
-              case 8:
-                signedTx = _context3.sent;
-                return _context3.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 10:
-              case "end":
-                return _context3.stop();
-            }
-          }
-        }, _callee3, this);
-      }));
-
-      function deposit(_x8, _x9, _x10) {
-        return _deposit.apply(this, arguments);
-      }
-
-      return deposit;
-    }()
-    /**
-     *
-     * @param {Number} proposalId
-     * @param {String} voter
-     * @param {VoteOption} option
-     */
-
-  }, {
-    key: "vote",
-    value: function () {
-      var _vote = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(proposalId, voter, option) {
-        var accAddress, voteMsg, signMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                accAddress = crypto.decodeAddress(voter);
-                voteMsg = {
-                  proposal_id: proposalId,
-                  voter: accAddress,
-                  option: option,
-                  aminoPrefix: _types.AminoPrefix.MsgVote
-                };
-                signMsg = {
-                  option: voteOptionMapping[option],
-                  proposal_id: String(proposalId),
-                  voter: voter
-                };
-                _context4.next = 5;
-                return this._bncClient._prepareTransaction(voteMsg, signMsg, voter);
-
-              case 5:
-                signedTx = _context4.sent;
-                return _context4.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 7:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this);
-      }));
-
-      function vote(_x11, _x12, _x13) {
-        return _vote.apply(this, arguments);
-      }
-
-      return vote;
-    }()
-  }]);
-  return Gov;
-}();
-
-(0, _defineProperty2["default"])(Gov, "instance", void 0);
-var _default = Gov;
-exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/proposalType.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/client/gov/proposalType.d.ts
deleted file mode 100644
index 0c5c549..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/proposalType.d.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-declare const _default: {
-    readonly ProposalTypeNil: 0;
-    readonly ProposalTypeText: 1;
-    readonly ProposalTypeParameterChange: 2;
-    readonly ProposalTypeSoftwareUpgrade: 3;
-    readonly ProposalTypeListTradingPair: 4;
-    readonly ProposalTypeFeeChange: 5;
-    readonly ProposalTypeCreateValidator: 6;
-    readonly ProposalTypeRemoveValidator: 7;
-};
-export default _default;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/proposalType.js b/node_modules/@binance-chain/javascript-sdk/lib/client/gov/proposalType.js
deleted file mode 100644
index 10ec316..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/gov/proposalType.js
+++ /dev/null
@@ -1,25 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-var ProposalTypeNil = 0x00;
-var ProposalTypeText = 0x01;
-var ProposalTypeParameterChange = 0x02;
-var ProposalTypeSoftwareUpgrade = 0x03;
-var ProposalTypeListTradingPair = 0x04;
-var ProposalTypeFeeChange = 0x05;
-var ProposalTypeCreateValidator = 0x06;
-var ProposalTypeRemoveValidator = 0x07;
-var _default = {
-  ProposalTypeNil: ProposalTypeNil,
-  ProposalTypeText: ProposalTypeText,
-  ProposalTypeParameterChange: ProposalTypeParameterChange,
-  ProposalTypeSoftwareUpgrade: ProposalTypeSoftwareUpgrade,
-  ProposalTypeListTradingPair: ProposalTypeListTradingPair,
-  ProposalTypeFeeChange: ProposalTypeFeeChange,
-  ProposalTypeCreateValidator: ProposalTypeCreateValidator,
-  ProposalTypeRemoveValidator: ProposalTypeRemoveValidator
-};
-exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/client/index.d.ts
deleted file mode 100644
index c462f9f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/index.d.ts
+++ /dev/null
@@ -1,513 +0,0 @@
-/// <reference types="node" />
-import { BigSource } from "big.js";
-import * as crypto from "../crypto";
-import LedgerApp, { PublicKey, SignedSignature } from "../ledger/ledger-app";
-import Transaction from "../tx";
-import { Coin } from "../types/";
-import HttpRequest from "../utils/request";
-import Gov from "./gov";
-import Swap from "./swap";
-import TokenManagement from "./token";
-import { Bridge } from "./bridge";
-import { Stake } from "./stake";
-export declare const api: {
-    broadcast: string;
-    nodeInfo: string;
-    getAccount: string;
-    getMarkets: string;
-    getSwaps: string;
-    getOpenOrders: string;
-    getDepth: string;
-    getTransactions: string;
-    getTxs: string;
-    getTx: string;
-};
-export declare const NETWORK_PREFIX_MAPPING: {
-    readonly testnet: "tbnb";
-    readonly mainnet: "bnb";
-};
-export declare type Transfer = {
-    to: string;
-    coins: Coin[];
-};
-/**
- * The default signing delegate which uses the local private key.
- * @param  {Transaction} tx      the transaction
- * @param  {Object}      signMsg the canonical sign bytes for the msg
- * @return {Transaction}
- */
-export declare const DefaultSigningDelegate: (this: BncClient, tx: Transaction, signMsg?: any) => Promise<Transaction>;
-/**
- * The default broadcast delegate which immediately broadcasts a transaction.
- * @param {Transaction} signedTx the signed transaction
- */
-export declare const DefaultBroadcastDelegate: (this: BncClient, signedTx: Transaction) => Promise<{
-    result: any;
-    status: number;
-}>;
-/**
- * The Ledger signing delegate.
- * @param  {LedgerApp}  ledgerApp
- * @param  {preSignCb}  function
- * @param  {postSignCb} function
- * @param  {errCb} function
- * @return {function}
- */
-export declare const LedgerSigningDelegate: (ledgerApp: LedgerApp, preSignCb: (preSignCb: Buffer) => void, postSignCb: (pubKeyResp: PublicKey, sigResp: SignedSignature) => void, errCb: (error: any) => void, hdPath: number[]) => typeof DefaultSigningDelegate;
-/**
- * The Binance Chain client.
- */
-export declare class BncClient {
-    _httpClient: HttpRequest;
-    _signingDelegate: typeof DefaultSigningDelegate;
-    _broadcastDelegate: typeof DefaultBroadcastDelegate;
-    _useAsyncBroadcast: boolean;
-    _source: number;
-    tokens: TokenManagement;
-    swap: Swap;
-    gov: Gov;
-    bridge: Bridge;
-    stake: Stake;
-    chainId?: string | null;
-    addressPrefix: typeof NETWORK_PREFIX_MAPPING[keyof typeof NETWORK_PREFIX_MAPPING];
-    network: keyof typeof NETWORK_PREFIX_MAPPING;
-    address?: string;
-    _setPkPromise?: ReturnType<HttpRequest["request"]>;
-    account_number?: string | number;
-    private _privateKey;
-    /**
-     * @param {String} server Binance Chain public url
-     * @param {Boolean} useAsyncBroadcast use async broadcast mode, faster but less guarantees (default off)
-     * @param {Number} source where does this transaction come from (default 0)
-     */
-    constructor(server: string, useAsyncBroadcast?: boolean, source?: number);
-    /**
-     * Initialize the client with the chain's ID. Asynchronous.
-     * @return {Promise}
-     */
-    initChain(): Promise<this>;
-    /**
-     * Sets the client network (testnet or mainnet).
-     * @param {String} network Indicate testnet or mainnet
-     */
-    chooseNetwork(network: keyof typeof NETWORK_PREFIX_MAPPING): void;
-    /**
-     * Sets the client's private key for calls made by this client. Asynchronous.
-     * @param {string} privateKey the private key hexstring
-     * @param {boolean} localOnly set this to true if you will supply an account_number yourself via `setAccountNumber`. Warning: You must do that if you set this to true!
-     * @return {Promise}
-     */
-    setPrivateKey(privateKey: string, localOnly?: boolean): Promise<this>;
-    /**
-     * Removes client's private key.
-     * @return {BncClient} this instance (for chaining)
-     */
-    removePrivateKey(): this;
-    /**
-     * Gets client's private key.
-     * @return {string|null} the private key hexstring or `null` if no private key has been set
-     */
-    getPrivateKey(): string | null;
-    /**
-     * Sets the client's account number.
-     * @param {number} accountNumber
-     */
-    setAccountNumber(accountNumber: number): void;
-    /**
-     * Use async broadcast mode. Broadcasts faster with less guarantees (default off)
-     * @param {Boolean} useAsyncBroadcast
-     * @return {BncClient} this instance (for chaining)
-     */
-    useAsyncBroadcast(useAsyncBroadcast?: boolean): BncClient;
-    /**
-     * Sets the signing delegate (for wallet integrations).
-     * @param {function} delegate
-     * @return {BncClient} this instance (for chaining)
-     */
-    setSigningDelegate(delegate: BncClient["_signingDelegate"]): BncClient;
-    /**
-     * Sets the broadcast delegate (for wallet integrations).
-     * @param {function} delegate
-     * @return {BncClient} this instance (for chaining)
-     */
-    setBroadcastDelegate(delegate: BncClient["_broadcastDelegate"]): BncClient;
-    /**
-     * Applies the default signing delegate.
-     * @return {BncClient} this instance (for chaining)
-     */
-    useDefaultSigningDelegate(): BncClient;
-    /**
-     * Applies the default broadcast delegate.
-     * @return {BncClient} this instance (for chaining)
-     */
-    useDefaultBroadcastDelegate(): BncClient;
-    /**
-     * Applies the Ledger signing delegate.
-     * @param {function} ledgerApp
-     * @param {function} preSignCb
-     * @param {function} postSignCb
-     * @param {function} errCb
-     * @return {BncClient} this instance (for chaining)
-     */
-    useLedgerSigningDelegate(...args: Parameters<typeof LedgerSigningDelegate>): this;
-    /**
-     * Transfer tokens from one address to another.
-     * @param {String} fromAddress
-     * @param {String} toAddress
-     * @param {Number} amount
-     * @param {String} asset
-     * @param {String} memo optional memo
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-    transfer(fromAddress: string, toAddress: string, amount: BigSource, asset: string, memo?: string, sequence?: number | null): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Create and sign a multi send tx
-     * @param {String} fromAddress
-     * @param {Array} outputs
-     * @example
-     * const outputs = [
-     * {
-     *   "to": "tbnb1p4kpnj5qz5spsaf0d2555h6ctngse0me5q57qe",
-     *   "coins": [{
-     *     "denom": "BNB",
-     *     "amount": 10
-     *   },{
-     *     "denom": "BTC",
-     *     "amount": 10
-     *   }]
-     * },
-     * {
-     *   "to": "tbnb1scjj8chhhp7lngdeflltzex22yaf9ep59ls4gk",
-     *   "coins": [{
-     *     "denom": "BTC",
-     *     "amount": 10
-     *   },{
-     *     "denom": "BNB",
-     *     "amount": 10
-     *   }]
-     * }]
-     * @param {String} memo optional memo
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-    multiSend(fromAddress: string, outputs: Transfer[], memo?: string, sequence?: number | null): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Cancel an order.
-     * @param {String} fromAddress
-     * @param {String} symbol the market pair
-     * @param {String} refid the order ID of the order to cancel
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-    cancelOrder(fromAddress: string, symbol: string, refid: string, sequence?: number | null): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Place an order.
-     * @param {String} address
-     * @param {String} symbol the market pair
-     * @param {Number} side (1-Buy, 2-Sell)
-     * @param {Number} price
-     * @param {Number} quantity
-     * @param {Number} sequence optional sequence
-     * @param {Number} timeinforce (1-GTC(Good Till Expire), 3-IOC(Immediate or Cancel))
-     * @return {Promise} resolves with response (success or fail)
-     */
-    placeOrder(address: string | undefined, symbol: string, side: number, price: number, quantity: number, sequence?: number | null, timeinforce?: number): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * @param {String} address
-     * @param {Number} proposalId
-     * @param {String} baseAsset
-     * @param {String} quoteAsset
-     * @param {Number} initPrice
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-    list(address: string, proposalId: number, baseAsset: string, quoteAsset: string, initPrice: number, sequence?: number | null): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * list miniToken
-     */
-    listMiniToken({ from, baseAsset, quoteAsset, initPrice, sequence, }: {
-        from: string;
-        baseAsset: string;
-        quoteAsset: string;
-        initPrice: number;
-        sequence?: number | null;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Set account flags
-     * @param {String} address
-     * @param {Number} flags new value of account flags
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-    setAccountFlags(address: string, flags: number, sequence?: number | null): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Prepare a serialized raw transaction for sending to the blockchain.
-     * @param {Object} msg the msg object
-     * @param {Object} stdSignMsg the sign doc object used to generate a signature
-     * @param {String} address
-     * @param {Number} sequence optional sequence
-     * @param {String} memo optional memo
-     * @return {Transaction} signed transaction
-     */
-    _prepareTransaction(msg: any, stdSignMsg: any, address: string, sequence?: string | number | null, memo?: string): Promise<Transaction>;
-    /**
-     * Broadcast a transaction to the blockchain.
-     * @param {signedTx} tx signed Transaction object
-     * @param {Boolean} sync use synchronous mode, optional
-     * @return {Promise} resolves with response (success or fail)
-     */
-    sendTransaction(signedTx: Transaction, sync: boolean): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Broadcast a raw transaction to the blockchain.
-     * @param {String} signedBz signed and serialized raw transaction
-     * @param {Boolean} sync use synchronous mode, optional
-     * @return {Promise} resolves with response (success or fail)
-     */
-    sendRawTransaction(signedBz: string, sync?: boolean): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Broadcast a raw transaction to the blockchain.
-     * @param {Object} msg the msg object
-     * @param {Object} stdSignMsg the sign doc object used to generate a signature
-     * @param {String} address
-     * @param {Number} sequence optional sequence
-     * @param {String} memo optional memo
-     * @param {Boolean} sync use synchronous mode, optional
-     * @return {Promise} resolves with response (success or fail)
-     */
-    _sendTransaction(msg: any, stdSignMsg: any, address: string, sequence?: string | number | null, memo?: string, sync?: boolean): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * get account
-     * @param {String} address
-     * @return {Promise} resolves with http response
-     */
-    getAccount(address?: string | undefined): Promise<{
-        result: any;
-        status: number;
-    } | null>;
-    /**
-     * get balances
-     * @param {String} address optional address
-     * @return {Promise} resolves with http response
-     */
-    getBalance(address?: string | undefined): Promise<any>;
-    /**
-     * get markets
-     * @param {Number} limit max 1000 is default
-     * @param {Number} offset from beggining, default 0
-     * @return {Promise} resolves with http response
-     */
-    getMarkets(limit?: number, offset?: number): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * get transactions for an account
-     * @param {String} address optional address
-     * @param {Number} offset from beggining, default 0
-     * @return {Promise} resolves with http response
-     * @deprecated please use getTxs instead.
-     */
-    getTransactions(address?: string | undefined, offset?: number): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * get transactions for an account
-     * @param {String} address optional address
-     * @param {Number} startTime start time in milliseconds
-     * @param {Number} endTime end time in in milliseconds, endTime - startTime should be smaller than 7 days
-     * @return {Promise} resolves with http response ([more details](https://docs.binance.org/api-reference/dex-api/block-service.html#apiv1txs))
-     * ```js
-     * // Example:
-     * const client = new BncClient('https://testnet-api.binance.org')
-     * client.getTxs(...);
-     * ```
-     */
-    getTxs(address: string | undefined, startTime: number, endTime: number): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * get transaction
-     * @param {String} hash the transaction hash
-     * @return {Promise} resolves with http response
-     */
-    getTx(hash: string): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * get depth for a given market
-     * @param {String} symbol the market pair
-     * @return {Promise} resolves with http response
-     */
-    getDepth(symbol?: string): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * get open orders for an address
-     * @param {String} address binance address
-     * @param {String} symbol binance BEP2 symbol
-     * @return {Promise} resolves with http response
-     */
-    getOpenOrders(address?: string): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * get atomic swap
-     * @param {String} swapID: ID of an existing swap
-     * @return {Promise} AtomicSwap
-     */
-    getSwapByID(swapID: string): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * query atomic swap list by creator address
-     * @param {String} creator: swap creator address
-     * @param {Number} offset from beginning, default 0
-     * @param {Number} limit, max 1000 is default
-     * @return {Promise} Array of AtomicSwap
-     */
-    getSwapByCreator(creator: string, limit?: number, offset?: number): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * query atomic swap list by recipient address
-     * @param {String} recipient: the recipient address of the swap
-     * @param {Number} offset from beginning, default 0
-     * @param {Number} limit, max 1000 is default
-     * @return {Promise} Array of AtomicSwap
-     */
-    getSwapByRecipient(recipient: string, limit?: number, offset?: number): Promise<never[] | {
-        result: any;
-        status: number;
-    }>;
-    /**
-     * Creates a private key and returns it and its address.
-     * @return {object} the private key and address in an object.
-     * {
-     *  address,
-     *  privateKey
-     * }
-     */
-    createAccount(): {
-        privateKey: string;
-        address: string;
-    };
-    /**
-     * Creates an account keystore object, and returns the private key and address.
-     * @param {String} password
-     *  {
-     *  privateKey,
-     *  address,
-     *  keystore
-     * }
-     */
-    createAccountWithKeystore(password: string): {
-        privateKey: string;
-        address: string;
-        keystore: crypto.KeyStore;
-    };
-    /**
-     * Creates an account from mnemonic seed phrase.
-     * @return {object}
-     * {
-     *  privateKey,
-     *  address,
-     *  mnemonic
-     * }
-     */
-    createAccountWithMneomnic(): {
-        privateKey: string;
-        address: string;
-        mnemonic: string;
-    };
-    /**
-     * Recovers an account from a keystore object.
-     * @param {object} keystore object.
-     * @param {string} password password.
-     * {
-     * privateKey,
-     * address
-     * }
-     */
-    recoverAccountFromKeystore(keystore: Parameters<typeof crypto.getPrivateKeyFromKeyStore>[0], password: Parameters<typeof crypto.getPrivateKeyFromKeyStore>[1]): {
-        privateKey: string;
-        address: string;
-    };
-    /**
-     * Recovers an account from a mnemonic seed phrase.
-     * @param {string} mneomnic
-     * {
-     * privateKey,
-     * address
-     * }
-     */
-    recoverAccountFromMnemonic(mnemonic: string): {
-        privateKey: string;
-        address: string;
-    };
-    recoverAccountFromMneomnic(mnemonic: string): {
-        privateKey: string;
-        address: string;
-    };
-    /**
-     * Recovers an account using private key.
-     * @param {String} privateKey
-     * {
-     * privateKey,
-     * address
-     * }
-     */
-    recoverAccountFromPrivateKey(privateKey: string): {
-        privateKey: string;
-        address: string;
-    };
-    /**
-     * Validates an address.
-     * @param {String} address
-     * @param {String} prefix
-     * @return {Boolean}
-     */
-    checkAddress(address: string, prefix?: BncClient["addressPrefix"]): boolean;
-    /**
-     * Returns the address for the current account if setPrivateKey has been called on this client.
-     * @return {String}
-     */
-    getClientKeyAddress(): string;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/index.js b/node_modules/@binance-chain/javascript-sdk/lib/client/index.js
deleted file mode 100644
index 869e82b..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/index.js
+++ /dev/null
@@ -1,2069 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BncClient = exports.LedgerSigningDelegate = exports.DefaultBroadcastDelegate = exports.DefaultSigningDelegate = exports.NETWORK_PREFIX_MAPPING = exports.api = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var crypto = _interopRequireWildcard(require("../crypto"));
-
-var _tx = _interopRequireDefault(require("../tx"));
-
-var _types = require("../types/");
-
-var _request = _interopRequireDefault(require("../utils/request"));
-
-var _validateHelper = require("../utils/validateHelper");
-
-var _gov = _interopRequireDefault(require("./gov"));
-
-var _swap = _interopRequireDefault(require("./swap"));
-
-var _token = _interopRequireWildcard(require("./token"));
-
-var _bridge = require("./bridge");
-
-var _stake = require("./stake");
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-var BASENUMBER = Math.pow(10, 8);
-var api = {
-  broadcast: "/api/v1/broadcast",
-  nodeInfo: "/api/v1/node-info",
-  getAccount: "/api/v1/account",
-  getMarkets: "/api/v1/markets",
-  getSwaps: "/api/v1/atomic-swaps",
-  getOpenOrders: "/api/v1/orders/open",
-  getDepth: "/api/v1/depth",
-  getTransactions: "/api/v1/transactions",
-  getTxs: "/bc/api/v1/txs",
-  getTx: "/api/v1/tx"
-};
-exports.api = api;
-var NETWORK_PREFIX_MAPPING = {
-  testnet: "tbnb",
-  mainnet: "bnb"
-};
-exports.NETWORK_PREFIX_MAPPING = NETWORK_PREFIX_MAPPING;
-
-/**
- * The default signing delegate which uses the local private key.
- * @param  {Transaction} tx      the transaction
- * @param  {Object}      signMsg the canonical sign bytes for the msg
- * @return {Transaction}
- */
-var DefaultSigningDelegate = /*#__PURE__*/function () {
-  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(tx, signMsg) {
-    var privateKey;
-    return _regenerator["default"].wrap(function _callee$(_context) {
-      while (1) {
-        switch (_context.prev = _context.next) {
-          case 0:
-            privateKey = this.getPrivateKey();
-
-            if (privateKey) {
-              _context.next = 3;
-              break;
-            }
-
-            return _context.abrupt("return", Promise.reject("Private key has to be set before signing a transaction"));
-
-          case 3:
-            return _context.abrupt("return", tx.sign(privateKey, signMsg));
-
-          case 4:
-          case "end":
-            return _context.stop();
-        }
-      }
-    }, _callee, this);
-  }));
-
-  return function DefaultSigningDelegate(_x, _x2, _x3) {
-    return _ref.apply(this, arguments);
-  };
-}();
-/**
- * The default broadcast delegate which immediately broadcasts a transaction.
- * @param {Transaction} signedTx the signed transaction
- */
-
-
-exports.DefaultSigningDelegate = DefaultSigningDelegate;
-
-var DefaultBroadcastDelegate = /*#__PURE__*/function () {
-  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(signedTx) {
-    return _regenerator["default"].wrap(function _callee2$(_context2) {
-      while (1) {
-        switch (_context2.prev = _context2.next) {
-          case 0:
-            return _context2.abrupt("return", this.sendTransaction(signedTx, true));
-
-          case 1:
-          case "end":
-            return _context2.stop();
-        }
-      }
-    }, _callee2, this);
-  }));
-
-  return function DefaultBroadcastDelegate(_x4, _x5) {
-    return _ref2.apply(this, arguments);
-  };
-}();
-/**
- * The Ledger signing delegate.
- * @param  {LedgerApp}  ledgerApp
- * @param  {preSignCb}  function
- * @param  {postSignCb} function
- * @param  {errCb} function
- * @return {function}
- */
-
-
-exports.DefaultBroadcastDelegate = DefaultBroadcastDelegate;
-
-var LedgerSigningDelegate = function LedgerSigningDelegate(ledgerApp, preSignCb, postSignCb, errCb, hdPath) {
-  return /*#__PURE__*/function () {
-    var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(tx, signMsg) {
-      var signBytes, pubKeyResp, sigResp, pubKey;
-      return _regenerator["default"].wrap(function _callee3$(_context3) {
-        while (1) {
-          switch (_context3.prev = _context3.next) {
-            case 0:
-              signBytes = tx.getSignBytes(signMsg);
-              preSignCb && preSignCb(signBytes);
-              _context3.prev = 2;
-              _context3.next = 5;
-              return ledgerApp.getPublicKey(hdPath);
-
-            case 5:
-              pubKeyResp = _context3.sent;
-              _context3.next = 8;
-              return ledgerApp.sign(signBytes, hdPath);
-
-            case 8:
-              sigResp = _context3.sent;
-              postSignCb && postSignCb(pubKeyResp, sigResp);
-              _context3.next = 16;
-              break;
-
-            case 12:
-              _context3.prev = 12;
-              _context3.t0 = _context3["catch"](2);
-              console.warn("LedgerSigningDelegate error", _context3.t0);
-              errCb && errCb(_context3.t0);
-
-            case 16:
-              if (!(sigResp && sigResp.signature)) {
-                _context3.next = 19;
-                break;
-              }
-
-              pubKey = crypto.getPublicKey(pubKeyResp.pk.toString("hex"));
-              return _context3.abrupt("return", tx.addSignature(pubKey, sigResp.signature));
-
-            case 19:
-              return _context3.abrupt("return", tx);
-
-            case 20:
-            case "end":
-              return _context3.stop();
-          }
-        }
-      }, _callee3, null, [[2, 12]]);
-    }));
-
-    return function (_x6, _x7) {
-      return _ref3.apply(this, arguments);
-    };
-  }();
-};
-/**
- * validate the input number.
- * @param {Array} outputs
- */
-
-
-exports.LedgerSigningDelegate = LedgerSigningDelegate;
-
-var checkOutputs = function checkOutputs(outputs) {
-  outputs.forEach(function (transfer) {
-    var coins = transfer.coins || [];
-    coins.forEach(function (coin) {
-      (0, _validateHelper.checkNumber)(coin.amount);
-
-      if (!coin.denom) {
-        throw new Error("invalid denmon");
-      }
-    });
-  });
-};
-/**
- * sum corresponding input coin
- * @param {Array} inputs
- * @param {Array} coins
- */
-
-
-var calInputCoins = function calInputCoins(inputs, coins) {
-  coins.forEach(function (coin) {
-    var existCoin = inputs[0].coins.find(function (c) {
-      return c.denom === coin.denom;
-    });
-
-    if (existCoin) {
-      var existAmount = new _big["default"](existCoin.amount);
-      existCoin.amount = Number(existAmount.plus(coin.amount).toString());
-    } else {
-      inputs[0].coins.push(_objectSpread({}, coin));
-    }
-  });
-};
-/**
- * The Binance Chain client.
- */
-
-
-var BncClient = /*#__PURE__*/function () {
-  /**
-   * @param {String} server Binance Chain public url
-   * @param {Boolean} useAsyncBroadcast use async broadcast mode, faster but less guarantees (default off)
-   * @param {Number} source where does this transaction come from (default 0)
-   */
-  function BncClient(server) {
-    var useAsyncBroadcast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
-    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
-    (0, _classCallCheck2["default"])(this, BncClient);
-    (0, _defineProperty2["default"])(this, "_httpClient", void 0);
-    (0, _defineProperty2["default"])(this, "_signingDelegate", void 0);
-    (0, _defineProperty2["default"])(this, "_broadcastDelegate", void 0);
-    (0, _defineProperty2["default"])(this, "_useAsyncBroadcast", void 0);
-    (0, _defineProperty2["default"])(this, "_source", void 0);
-    (0, _defineProperty2["default"])(this, "tokens", void 0);
-    (0, _defineProperty2["default"])(this, "swap", void 0);
-    (0, _defineProperty2["default"])(this, "gov", void 0);
-    (0, _defineProperty2["default"])(this, "bridge", void 0);
-    (0, _defineProperty2["default"])(this, "stake", void 0);
-    (0, _defineProperty2["default"])(this, "chainId", void 0);
-    (0, _defineProperty2["default"])(this, "addressPrefix", "tbnb");
-    (0, _defineProperty2["default"])(this, "network", "testnet");
-    (0, _defineProperty2["default"])(this, "address", void 0);
-    (0, _defineProperty2["default"])(this, "_setPkPromise", void 0);
-    (0, _defineProperty2["default"])(this, "account_number", void 0);
-    (0, _defineProperty2["default"])(this, "_privateKey", null);
-
-    if (!server) {
-      throw new Error("Binance chain server should not be null");
-    }
-
-    this._httpClient = new _request["default"](server);
-    this._signingDelegate = DefaultSigningDelegate;
-    this._broadcastDelegate = DefaultBroadcastDelegate;
-    this._useAsyncBroadcast = useAsyncBroadcast;
-    this._source = source;
-    this.tokens = new _token["default"](this);
-    this.swap = new _swap["default"](this);
-    this.gov = new _gov["default"](this);
-    this.bridge = new _bridge.Bridge(this);
-    this.stake = new _stake.Stake(this);
-  }
-  /**
-   * Initialize the client with the chain's ID. Asynchronous.
-   * @return {Promise}
-   */
-
-
-  (0, _createClass2["default"])(BncClient, [{
-    key: "initChain",
-    value: function () {
-      var _initChain = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
-        var data;
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                if (this.chainId) {
-                  _context4.next = 5;
-                  break;
-                }
-
-                _context4.next = 3;
-                return this._httpClient.request("get", api.nodeInfo);
-
-              case 3:
-                data = _context4.sent;
-                this.chainId = data.result.node_info && data.result.node_info.network;
-
-              case 5:
-                return _context4.abrupt("return", this);
-
-              case 6:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this);
-      }));
-
-      function initChain() {
-        return _initChain.apply(this, arguments);
-      }
-
-      return initChain;
-    }()
-    /**
-     * Sets the client network (testnet or mainnet).
-     * @param {String} network Indicate testnet or mainnet
-     */
-
-  }, {
-    key: "chooseNetwork",
-    value: function chooseNetwork(network) {
-      this.addressPrefix = NETWORK_PREFIX_MAPPING[network] || "tbnb";
-      this.network = NETWORK_PREFIX_MAPPING[network] ? network : "testnet";
-    }
-    /**
-     * Sets the client's private key for calls made by this client. Asynchronous.
-     * @param {string} privateKey the private key hexstring
-     * @param {boolean} localOnly set this to true if you will supply an account_number yourself via `setAccountNumber`. Warning: You must do that if you set this to true!
-     * @return {Promise}
-     */
-
-  }, {
-    key: "setPrivateKey",
-    value: function () {
-      var _setPrivateKey = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(privateKey) {
-        var localOnly,
-            address,
-            promise,
-            data,
-            _args5 = arguments;
-        return _regenerator["default"].wrap(function _callee5$(_context5) {
-          while (1) {
-            switch (_context5.prev = _context5.next) {
-              case 0:
-                localOnly = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;
-
-                if (!(privateKey !== this._privateKey)) {
-                  _context5.next = 19;
-                  break;
-                }
-
-                address = crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix);
-
-                if (address) {
-                  _context5.next = 5;
-                  break;
-                }
-
-                throw new Error("address is falsy: ".concat(address, ". invalid private key?"));
-
-              case 5:
-                this._privateKey = privateKey;
-                this.address = address;
-
-                if (localOnly) {
-                  _context5.next = 19;
-                  break;
-                }
-
-                _context5.prev = 8;
-                promise = this._setPkPromise = this._httpClient.request("get", "".concat(api.getAccount, "/").concat(address));
-                _context5.next = 12;
-                return promise;
-
-              case 12:
-                data = _context5.sent;
-                this.account_number = data.result.account_number;
-                _context5.next = 19;
-                break;
-
-              case 16:
-                _context5.prev = 16;
-                _context5.t0 = _context5["catch"](8);
-                throw new Error("unable to query the address on the blockchain. try sending it some funds first: ".concat(address));
-
-              case 19:
-                return _context5.abrupt("return", this);
-
-              case 20:
-              case "end":
-                return _context5.stop();
-            }
-          }
-        }, _callee5, this, [[8, 16]]);
-      }));
-
-      function setPrivateKey(_x8) {
-        return _setPrivateKey.apply(this, arguments);
-      }
-
-      return setPrivateKey;
-    }()
-    /**
-     * Removes client's private key.
-     * @return {BncClient} this instance (for chaining)
-     */
-
-  }, {
-    key: "removePrivateKey",
-    value: function removePrivateKey() {
-      this._privateKey = null;
-      return this;
-    }
-    /**
-     * Gets client's private key.
-     * @return {string|null} the private key hexstring or `null` if no private key has been set
-     */
-
-  }, {
-    key: "getPrivateKey",
-    value: function getPrivateKey() {
-      return this._privateKey;
-    }
-    /**
-     * Sets the client's account number.
-     * @param {number} accountNumber
-     */
-
-  }, {
-    key: "setAccountNumber",
-    value: function setAccountNumber(accountNumber) {
-      this.account_number = accountNumber;
-    }
-    /**
-     * Use async broadcast mode. Broadcasts faster with less guarantees (default off)
-     * @param {Boolean} useAsyncBroadcast
-     * @return {BncClient} this instance (for chaining)
-     */
-
-  }, {
-    key: "useAsyncBroadcast",
-    value: function useAsyncBroadcast() {
-      var _useAsyncBroadcast = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
-
-      this._useAsyncBroadcast = _useAsyncBroadcast;
-      return this;
-    }
-    /**
-     * Sets the signing delegate (for wallet integrations).
-     * @param {function} delegate
-     * @return {BncClient} this instance (for chaining)
-     */
-
-  }, {
-    key: "setSigningDelegate",
-    value: function setSigningDelegate(delegate) {
-      if (typeof delegate !== "function") throw new Error("signing delegate must be a function");
-      this._signingDelegate = delegate;
-      return this;
-    }
-    /**
-     * Sets the broadcast delegate (for wallet integrations).
-     * @param {function} delegate
-     * @return {BncClient} this instance (for chaining)
-     */
-
-  }, {
-    key: "setBroadcastDelegate",
-    value: function setBroadcastDelegate(delegate) {
-      if (typeof delegate !== "function") throw new Error("broadcast delegate must be a function");
-      this._broadcastDelegate = delegate;
-      return this;
-    }
-    /**
-     * Applies the default signing delegate.
-     * @return {BncClient} this instance (for chaining)
-     */
-
-  }, {
-    key: "useDefaultSigningDelegate",
-    value: function useDefaultSigningDelegate() {
-      this._signingDelegate = DefaultSigningDelegate;
-      return this;
-    }
-    /**
-     * Applies the default broadcast delegate.
-     * @return {BncClient} this instance (for chaining)
-     */
-
-  }, {
-    key: "useDefaultBroadcastDelegate",
-    value: function useDefaultBroadcastDelegate() {
-      this._broadcastDelegate = DefaultBroadcastDelegate;
-      return this;
-    }
-    /**
-     * Applies the Ledger signing delegate.
-     * @param {function} ledgerApp
-     * @param {function} preSignCb
-     * @param {function} postSignCb
-     * @param {function} errCb
-     * @return {BncClient} this instance (for chaining)
-     */
-
-  }, {
-    key: "useLedgerSigningDelegate",
-    value: function useLedgerSigningDelegate() {
-      this._signingDelegate = LedgerSigningDelegate.apply(void 0, arguments);
-      return this;
-    }
-    /**
-     * Transfer tokens from one address to another.
-     * @param {String} fromAddress
-     * @param {String} toAddress
-     * @param {Number} amount
-     * @param {String} asset
-     * @param {String} memo optional memo
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "transfer",
-    value: function () {
-      var _transfer = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(fromAddress, toAddress, amount, asset) {
-        var memo,
-            sequence,
-            accCode,
-            toAccCode,
-            coin,
-            msg,
-            signMsg,
-            signedTx,
-            _args6 = arguments;
-        return _regenerator["default"].wrap(function _callee6$(_context6) {
-          while (1) {
-            switch (_context6.prev = _context6.next) {
-              case 0:
-                memo = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : "";
-                sequence = _args6.length > 5 && _args6[5] !== undefined ? _args6[5] : null;
-                accCode = crypto.decodeAddress(fromAddress);
-                toAccCode = crypto.decodeAddress(toAddress);
-                amount = new _big["default"](amount);
-                amount = Number(amount.mul(BASENUMBER).toString());
-                (0, _validateHelper.checkNumber)(amount, "amount");
-                coin = {
-                  denom: asset,
-                  amount: amount
-                };
-                msg = {
-                  inputs: [{
-                    address: accCode,
-                    coins: [coin]
-                  }],
-                  outputs: [{
-                    address: toAccCode,
-                    coins: [coin]
-                  }],
-                  aminoPrefix: _types.AminoPrefix.MsgSend
-                };
-                signMsg = {
-                  inputs: [{
-                    address: fromAddress,
-                    coins: [{
-                      amount: amount,
-                      denom: asset
-                    }]
-                  }],
-                  outputs: [{
-                    address: toAddress,
-                    coins: [{
-                      amount: amount,
-                      denom: asset
-                    }]
-                  }]
-                };
-                _context6.next = 12;
-                return this._prepareTransaction(msg, signMsg, fromAddress, sequence, memo);
-
-              case 12:
-                signedTx = _context6.sent;
-                return _context6.abrupt("return", this._broadcastDelegate(signedTx));
-
-              case 14:
-              case "end":
-                return _context6.stop();
-            }
-          }
-        }, _callee6, this);
-      }));
-
-      function transfer(_x9, _x10, _x11, _x12) {
-        return _transfer.apply(this, arguments);
-      }
-
-      return transfer;
-    }()
-    /**
-     * Create and sign a multi send tx
-     * @param {String} fromAddress
-     * @param {Array} outputs
-     * @example
-     * const outputs = [
-     * {
-     *   "to": "tbnb1p4kpnj5qz5spsaf0d2555h6ctngse0me5q57qe",
-     *   "coins": [{
-     *     "denom": "BNB",
-     *     "amount": 10
-     *   },{
-     *     "denom": "BTC",
-     *     "amount": 10
-     *   }]
-     * },
-     * {
-     *   "to": "tbnb1scjj8chhhp7lngdeflltzex22yaf9ep59ls4gk",
-     *   "coins": [{
-     *     "denom": "BTC",
-     *     "amount": 10
-     *   },{
-     *     "denom": "BNB",
-     *     "amount": 10
-     *   }]
-     * }]
-     * @param {String} memo optional memo
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "multiSend",
-    value: function () {
-      var _multiSend = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(fromAddress, outputs) {
-        var memo,
-            sequence,
-            fromAddrCode,
-            inputs,
-            transfers,
-            msg,
-            signInputs,
-            signOutputs,
-            signMsg,
-            signedTx,
-            _args7 = arguments;
-        return _regenerator["default"].wrap(function _callee7$(_context7) {
-          while (1) {
-            switch (_context7.prev = _context7.next) {
-              case 0:
-                memo = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : "";
-                sequence = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : null;
-
-                if (fromAddress) {
-                  _context7.next = 4;
-                  break;
-                }
-
-                throw new Error("fromAddress should not be falsy");
-
-              case 4:
-                if (Array.isArray(outputs)) {
-                  _context7.next = 6;
-                  break;
-                }
-
-                throw new Error("outputs should be array");
-
-              case 6:
-                checkOutputs(outputs); //sort denom by alphbet and init amount
-
-                outputs.forEach(function (item) {
-                  item.coins = item.coins.sort(function (a, b) {
-                    return a.denom.localeCompare(b.denom);
-                  });
-                  item.coins.forEach(function (coin) {
-                    var amount = new _big["default"](coin.amount);
-                    coin.amount = Number(amount.mul(BASENUMBER).toString());
-                  });
-                });
-                fromAddrCode = crypto.decodeAddress(fromAddress);
-                inputs = [{
-                  address: fromAddrCode,
-                  coins: []
-                }];
-                transfers = [];
-                outputs.forEach(function (item) {
-                  var toAddcCode = crypto.decodeAddress(item.to);
-                  calInputCoins(inputs, item.coins);
-                  transfers.push({
-                    address: toAddcCode,
-                    coins: item.coins
-                  });
-                });
-                msg = {
-                  inputs: inputs,
-                  outputs: transfers,
-                  aminoPrefix: _types.AminoPrefix.MsgSend
-                };
-                signInputs = [{
-                  address: fromAddress,
-                  coins: []
-                }];
-                signOutputs = [];
-                outputs.forEach(function (item, index) {
-                  signOutputs.push({
-                    address: item.to,
-                    coins: []
-                  });
-                  item.coins.forEach(function (c) {
-                    signOutputs[index].coins.push(c);
-                  });
-                  calInputCoins(signInputs, item.coins);
-                });
-                signMsg = {
-                  inputs: signInputs,
-                  outputs: signOutputs
-                };
-                _context7.next = 19;
-                return this._prepareTransaction(msg, signMsg, fromAddress, sequence, memo);
-
-              case 19:
-                signedTx = _context7.sent;
-                return _context7.abrupt("return", this._broadcastDelegate(signedTx));
-
-              case 21:
-              case "end":
-                return _context7.stop();
-            }
-          }
-        }, _callee7, this);
-      }));
-
-      function multiSend(_x13, _x14) {
-        return _multiSend.apply(this, arguments);
-      }
-
-      return multiSend;
-    }()
-    /**
-     * Cancel an order.
-     * @param {String} fromAddress
-     * @param {String} symbol the market pair
-     * @param {String} refid the order ID of the order to cancel
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "cancelOrder",
-    value: function () {
-      var _cancelOrder = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(fromAddress, symbol, refid) {
-        var sequence,
-            accCode,
-            msg,
-            signMsg,
-            signedTx,
-            _args8 = arguments;
-        return _regenerator["default"].wrap(function _callee8$(_context8) {
-          while (1) {
-            switch (_context8.prev = _context8.next) {
-              case 0:
-                sequence = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : null;
-                accCode = crypto.decodeAddress(fromAddress);
-                msg = {
-                  sender: accCode,
-                  symbol: symbol,
-                  refid: refid,
-                  aminoPrefix: _types.AminoPrefix.CancelOrderMsg
-                };
-                signMsg = {
-                  refid: refid,
-                  sender: fromAddress,
-                  symbol: symbol
-                };
-                _context8.next = 6;
-                return this._prepareTransaction(msg, signMsg, fromAddress, sequence, "");
-
-              case 6:
-                signedTx = _context8.sent;
-                return _context8.abrupt("return", this._broadcastDelegate(signedTx));
-
-              case 8:
-              case "end":
-                return _context8.stop();
-            }
-          }
-        }, _callee8, this);
-      }));
-
-      function cancelOrder(_x15, _x16, _x17) {
-        return _cancelOrder.apply(this, arguments);
-      }
-
-      return cancelOrder;
-    }()
-    /**
-     * Place an order.
-     * @param {String} address
-     * @param {String} symbol the market pair
-     * @param {Number} side (1-Buy, 2-Sell)
-     * @param {Number} price
-     * @param {Number} quantity
-     * @param {Number} sequence optional sequence
-     * @param {Number} timeinforce (1-GTC(Good Till Expire), 3-IOC(Immediate or Cancel))
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "placeOrder",
-    value: function () {
-      var _placeOrder = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
-        var address,
-            symbol,
-            side,
-            price,
-            quantity,
-            sequence,
-            timeinforce,
-            accCode,
-            data,
-            bigPrice,
-            bigQuantity,
-            placeOrderMsg,
-            signMsg,
-            signedTx,
-            _args9 = arguments;
-        return _regenerator["default"].wrap(function _callee9$(_context9) {
-          while (1) {
-            switch (_context9.prev = _context9.next) {
-              case 0:
-                address = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : this.address;
-                symbol = _args9.length > 1 ? _args9[1] : undefined;
-                side = _args9.length > 2 ? _args9[2] : undefined;
-                price = _args9.length > 3 ? _args9[3] : undefined;
-                quantity = _args9.length > 4 ? _args9[4] : undefined;
-                sequence = _args9.length > 5 && _args9[5] !== undefined ? _args9[5] : null;
-                timeinforce = _args9.length > 6 && _args9[6] !== undefined ? _args9[6] : 1;
-
-                if (address) {
-                  _context9.next = 9;
-                  break;
-                }
-
-                throw new Error("address should not be falsy");
-
-              case 9:
-                if (symbol) {
-                  _context9.next = 11;
-                  break;
-                }
-
-                throw new Error("symbol should not be falsy");
-
-              case 11:
-                if (!(side !== 1 && side !== 2)) {
-                  _context9.next = 13;
-                  break;
-                }
-
-                throw new Error("side can only be 1 or 2");
-
-              case 13:
-                if (!(timeinforce !== 1 && timeinforce !== 3)) {
-                  _context9.next = 15;
-                  break;
-                }
-
-                throw new Error("timeinforce can only be 1 or 3");
-
-              case 15:
-                accCode = crypto.decodeAddress(address);
-
-                if (!(sequence !== 0 && !sequence)) {
-                  _context9.next = 21;
-                  break;
-                }
-
-                _context9.next = 19;
-                return this._httpClient.request("get", "".concat(api.getAccount, "/").concat(address));
-
-              case 19:
-                data = _context9.sent;
-                sequence = data.result && data.result.sequence;
-
-              case 21:
-                bigPrice = new _big["default"](price);
-                bigQuantity = new _big["default"](quantity);
-                placeOrderMsg = {
-                  sender: accCode,
-                  id: "".concat(accCode.toString("hex"), "-").concat(sequence + 1).toUpperCase(),
-                  symbol: symbol,
-                  ordertype: 2,
-                  side: side,
-                  price: parseFloat(bigPrice.mul(BASENUMBER).toString()),
-                  quantity: parseFloat(bigQuantity.mul(BASENUMBER).toString()),
-                  timeinforce: timeinforce,
-                  aminoPrefix: _types.AminoPrefix.NewOrderMsg
-                };
-                signMsg = {
-                  id: placeOrderMsg.id,
-                  ordertype: placeOrderMsg.ordertype,
-                  price: placeOrderMsg.price,
-                  quantity: placeOrderMsg.quantity,
-                  sender: address,
-                  side: placeOrderMsg.side,
-                  symbol: placeOrderMsg.symbol,
-                  timeinforce: timeinforce
-                };
-                (0, _validateHelper.checkNumber)(placeOrderMsg.price, "price");
-                (0, _validateHelper.checkNumber)(placeOrderMsg.quantity, "quantity");
-                _context9.next = 29;
-                return this._prepareTransaction(placeOrderMsg, signMsg, address, sequence, "");
-
-              case 29:
-                signedTx = _context9.sent;
-                return _context9.abrupt("return", this._broadcastDelegate(signedTx));
-
-              case 31:
-              case "end":
-                return _context9.stop();
-            }
-          }
-        }, _callee9, this);
-      }));
-
-      function placeOrder() {
-        return _placeOrder.apply(this, arguments);
-      }
-
-      return placeOrder;
-    }()
-    /**
-     * @param {String} address
-     * @param {Number} proposalId
-     * @param {String} baseAsset
-     * @param {String} quoteAsset
-     * @param {Number} initPrice
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "list",
-    value: function () {
-      var _list = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(address, proposalId, baseAsset, quoteAsset, initPrice) {
-        var sequence,
-            accCode,
-            init_price,
-            listMsg,
-            signMsg,
-            signedTx,
-            _args10 = arguments;
-        return _regenerator["default"].wrap(function _callee10$(_context10) {
-          while (1) {
-            switch (_context10.prev = _context10.next) {
-              case 0:
-                sequence = _args10.length > 5 && _args10[5] !== undefined ? _args10[5] : null;
-                accCode = crypto.decodeAddress(address);
-
-                if (address) {
-                  _context10.next = 4;
-                  break;
-                }
-
-                throw new Error("address should not be falsy");
-
-              case 4:
-                if (!(proposalId <= 0)) {
-                  _context10.next = 6;
-                  break;
-                }
-
-                throw new Error("proposal id should larger than 0");
-
-              case 6:
-                if (!(initPrice <= 0)) {
-                  _context10.next = 8;
-                  break;
-                }
-
-                throw new Error("price should larger than 0");
-
-              case 8:
-                if (baseAsset) {
-                  _context10.next = 10;
-                  break;
-                }
-
-                throw new Error("baseAsset should not be falsy");
-
-              case 10:
-                if (quoteAsset) {
-                  _context10.next = 12;
-                  break;
-                }
-
-                throw new Error("quoteAsset should not be falsy");
-
-              case 12:
-                init_price = Number(new _big["default"](initPrice).mul(BASENUMBER).toString());
-                listMsg = {
-                  from: accCode,
-                  proposal_id: proposalId,
-                  base_asset_symbol: baseAsset,
-                  quote_asset_symbol: quoteAsset,
-                  init_price: init_price,
-                  aminoPrefix: _types.AminoPrefix.ListMsg
-                };
-                signMsg = {
-                  base_asset_symbol: baseAsset,
-                  from: address,
-                  init_price: init_price,
-                  proposal_id: proposalId,
-                  quote_asset_symbol: quoteAsset
-                };
-                _context10.next = 17;
-                return this._prepareTransaction(listMsg, signMsg, address, sequence, "");
-
-              case 17:
-                signedTx = _context10.sent;
-                return _context10.abrupt("return", this._broadcastDelegate(signedTx));
-
-              case 19:
-              case "end":
-                return _context10.stop();
-            }
-          }
-        }, _callee10, this);
-      }));
-
-      function list(_x18, _x19, _x20, _x21, _x22) {
-        return _list.apply(this, arguments);
-      }
-
-      return list;
-    }()
-    /**
-     * list miniToken
-     */
-
-  }, {
-    key: "listMiniToken",
-    value: function () {
-      var _listMiniToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(_ref4) {
-        var from, baseAsset, quoteAsset, initPrice, _ref4$sequence, sequence, init_price, listMiniMsg, signedTx;
-
-        return _regenerator["default"].wrap(function _callee11$(_context11) {
-          while (1) {
-            switch (_context11.prev = _context11.next) {
-              case 0:
-                from = _ref4.from, baseAsset = _ref4.baseAsset, quoteAsset = _ref4.quoteAsset, initPrice = _ref4.initPrice, _ref4$sequence = _ref4.sequence, sequence = _ref4$sequence === void 0 ? null : _ref4$sequence;
-                (0, _token.validateMiniTokenSymbol)(baseAsset);
-
-                if (!(initPrice <= 0)) {
-                  _context11.next = 4;
-                  break;
-                }
-
-                throw new Error("price should larger than 0");
-
-              case 4:
-                if (from) {
-                  _context11.next = 6;
-                  break;
-                }
-
-                throw new Error("address should not be falsy");
-
-              case 6:
-                if (quoteAsset) {
-                  _context11.next = 8;
-                  break;
-                }
-
-                throw new Error("quoteAsset should not be falsy");
-
-              case 8:
-                init_price = Number(new _big["default"](initPrice).mul(BASENUMBER).toString());
-                listMiniMsg = new _types.ListMiniMsg({
-                  from: from,
-                  base_asset_symbol: baseAsset,
-                  quote_asset_symbol: quoteAsset,
-                  init_price: init_price
-                });
-                _context11.next = 12;
-                return this._prepareTransaction(listMiniMsg.getMsg(), listMiniMsg.getSignMsg(), from, sequence);
-
-              case 12:
-                signedTx = _context11.sent;
-                return _context11.abrupt("return", this._broadcastDelegate(signedTx));
-
-              case 14:
-              case "end":
-                return _context11.stop();
-            }
-          }
-        }, _callee11, this);
-      }));
-
-      function listMiniToken(_x23) {
-        return _listMiniToken.apply(this, arguments);
-      }
-
-      return listMiniToken;
-    }()
-    /**
-     * Set account flags
-     * @param {String} address
-     * @param {Number} flags new value of account flags
-     * @param {Number} sequence optional sequence
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "setAccountFlags",
-    value: function () {
-      var _setAccountFlags = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(address, flags) {
-        var sequence,
-            accCode,
-            msg,
-            signMsg,
-            signedTx,
-            _args12 = arguments;
-        return _regenerator["default"].wrap(function _callee12$(_context12) {
-          while (1) {
-            switch (_context12.prev = _context12.next) {
-              case 0:
-                sequence = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : null;
-                accCode = crypto.decodeAddress(address);
-                msg = {
-                  from: accCode,
-                  flags: flags,
-                  aminoPrefix: _types.AminoPrefix.SetAccountFlagsMsg
-                };
-                signMsg = {
-                  flags: flags,
-                  from: address
-                };
-                _context12.next = 6;
-                return this._prepareTransaction(msg, signMsg, address, sequence, "");
-
-              case 6:
-                signedTx = _context12.sent;
-                return _context12.abrupt("return", this._broadcastDelegate(signedTx));
-
-              case 8:
-              case "end":
-                return _context12.stop();
-            }
-          }
-        }, _callee12, this);
-      }));
-
-      function setAccountFlags(_x24, _x25) {
-        return _setAccountFlags.apply(this, arguments);
-      }
-
-      return setAccountFlags;
-    }()
-    /**
-     * Prepare a serialized raw transaction for sending to the blockchain.
-     * @param {Object} msg the msg object
-     * @param {Object} stdSignMsg the sign doc object used to generate a signature
-     * @param {String} address
-     * @param {Number} sequence optional sequence
-     * @param {String} memo optional memo
-     * @return {Transaction} signed transaction
-     */
-
-  }, {
-    key: "_prepareTransaction",
-    value: function () {
-      var _prepareTransaction2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(msg, stdSignMsg, address) {
-        var sequence,
-            memo,
-            data,
-            tx,
-            _args13 = arguments;
-        return _regenerator["default"].wrap(function _callee13$(_context13) {
-          while (1) {
-            switch (_context13.prev = _context13.next) {
-              case 0:
-                sequence = _args13.length > 3 && _args13[3] !== undefined ? _args13[3] : null;
-                memo = _args13.length > 4 && _args13[4] !== undefined ? _args13[4] : "";
-
-                if (!((!this.account_number || sequence !== 0 && !sequence) && address)) {
-                  _context13.next = 10;
-                  break;
-                }
-
-                _context13.next = 5;
-                return this._httpClient.request("get", "".concat(api.getAccount, "/").concat(address));
-
-              case 5:
-                data = _context13.sent;
-                sequence = data.result.sequence;
-                this.account_number = data.result.account_number; // if user has not used `await` in its call to setPrivateKey (old API), we should wait for the promise here
-
-                _context13.next = 13;
-                break;
-
-              case 10:
-                if (!this._setPkPromise) {
-                  _context13.next = 13;
-                  break;
-                }
-
-                _context13.next = 13;
-                return this._setPkPromise;
-
-              case 13:
-                tx = new _tx["default"]({
-                  accountNumber: typeof this.account_number !== "number" ? parseInt(this.account_number) : this.account_number,
-                  chainId: this.chainId,
-                  memo: memo,
-                  msg: msg,
-                  sequence: typeof sequence !== "number" ? parseInt(sequence) : sequence,
-                  source: this._source
-                });
-                return _context13.abrupt("return", this._signingDelegate.call(this, tx, stdSignMsg));
-
-              case 15:
-              case "end":
-                return _context13.stop();
-            }
-          }
-        }, _callee13, this);
-      }));
-
-      function _prepareTransaction(_x26, _x27, _x28) {
-        return _prepareTransaction2.apply(this, arguments);
-      }
-
-      return _prepareTransaction;
-    }()
-    /**
-     * Broadcast a transaction to the blockchain.
-     * @param {signedTx} tx signed Transaction object
-     * @param {Boolean} sync use synchronous mode, optional
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "sendTransaction",
-    value: function () {
-      var _sendTransaction2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(signedTx, sync) {
-        var signedBz;
-        return _regenerator["default"].wrap(function _callee14$(_context14) {
-          while (1) {
-            switch (_context14.prev = _context14.next) {
-              case 0:
-                signedBz = signedTx.serialize();
-                return _context14.abrupt("return", this.sendRawTransaction(signedBz, sync));
-
-              case 2:
-              case "end":
-                return _context14.stop();
-            }
-          }
-        }, _callee14, this);
-      }));
-
-      function sendTransaction(_x29, _x30) {
-        return _sendTransaction2.apply(this, arguments);
-      }
-
-      return sendTransaction;
-    }()
-    /**
-     * Broadcast a raw transaction to the blockchain.
-     * @param {String} signedBz signed and serialized raw transaction
-     * @param {Boolean} sync use synchronous mode, optional
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "sendRawTransaction",
-    value: function () {
-      var _sendRawTransaction = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15(signedBz) {
-        var sync,
-            opts,
-            _args15 = arguments;
-        return _regenerator["default"].wrap(function _callee15$(_context15) {
-          while (1) {
-            switch (_context15.prev = _context15.next) {
-              case 0:
-                sync = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : !this._useAsyncBroadcast;
-                opts = {
-                  data: signedBz,
-                  headers: {
-                    "content-type": "text/plain"
-                  }
-                };
-                return _context15.abrupt("return", this._httpClient.request("post", "".concat(api.broadcast, "?sync=").concat(sync), null, opts));
-
-              case 3:
-              case "end":
-                return _context15.stop();
-            }
-          }
-        }, _callee15, this);
-      }));
-
-      function sendRawTransaction(_x31) {
-        return _sendRawTransaction.apply(this, arguments);
-      }
-
-      return sendRawTransaction;
-    }()
-    /**
-     * Broadcast a raw transaction to the blockchain.
-     * @param {Object} msg the msg object
-     * @param {Object} stdSignMsg the sign doc object used to generate a signature
-     * @param {String} address
-     * @param {Number} sequence optional sequence
-     * @param {String} memo optional memo
-     * @param {Boolean} sync use synchronous mode, optional
-     * @return {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "_sendTransaction",
-    value: function () {
-      var _sendTransaction3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16(msg, stdSignMsg, address) {
-        var sequence,
-            memo,
-            sync,
-            signedTx,
-            _args16 = arguments;
-        return _regenerator["default"].wrap(function _callee16$(_context16) {
-          while (1) {
-            switch (_context16.prev = _context16.next) {
-              case 0:
-                sequence = _args16.length > 3 && _args16[3] !== undefined ? _args16[3] : null;
-                memo = _args16.length > 4 && _args16[4] !== undefined ? _args16[4] : "";
-                sync = _args16.length > 5 && _args16[5] !== undefined ? _args16[5] : !this._useAsyncBroadcast;
-                _context16.next = 5;
-                return this._prepareTransaction(msg, stdSignMsg, address, sequence, memo);
-
-              case 5:
-                signedTx = _context16.sent;
-                return _context16.abrupt("return", this.sendTransaction(signedTx, sync));
-
-              case 7:
-              case "end":
-                return _context16.stop();
-            }
-          }
-        }, _callee16, this);
-      }));
-
-      function _sendTransaction(_x32, _x33, _x34) {
-        return _sendTransaction3.apply(this, arguments);
-      }
-
-      return _sendTransaction;
-    }()
-    /**
-     * get account
-     * @param {String} address
-     * @return {Promise} resolves with http response
-     */
-
-  }, {
-    key: "getAccount",
-    value: function () {
-      var _getAccount = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17() {
-        var address,
-            data,
-            _args17 = arguments;
-        return _regenerator["default"].wrap(function _callee17$(_context17) {
-          while (1) {
-            switch (_context17.prev = _context17.next) {
-              case 0:
-                address = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : this.address;
-
-                if (address) {
-                  _context17.next = 3;
-                  break;
-                }
-
-                throw new Error("address should not be falsy");
-
-              case 3:
-                _context17.prev = 3;
-                _context17.next = 6;
-                return this._httpClient.request("get", "".concat(api.getAccount, "/").concat(address));
-
-              case 6:
-                data = _context17.sent;
-                return _context17.abrupt("return", data);
-
-              case 10:
-                _context17.prev = 10;
-                _context17.t0 = _context17["catch"](3);
-                return _context17.abrupt("return", null);
-
-              case 13:
-              case "end":
-                return _context17.stop();
-            }
-          }
-        }, _callee17, this, [[3, 10]]);
-      }));
-
-      function getAccount() {
-        return _getAccount.apply(this, arguments);
-      }
-
-      return getAccount;
-    }()
-    /**
-     * get balances
-     * @param {String} address optional address
-     * @return {Promise} resolves with http response
-     */
-
-  }, {
-    key: "getBalance",
-    value: function () {
-      var _getBalance = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18() {
-        var address,
-            data,
-            _args18 = arguments;
-        return _regenerator["default"].wrap(function _callee18$(_context18) {
-          while (1) {
-            switch (_context18.prev = _context18.next) {
-              case 0:
-                address = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : this.address;
-                _context18.prev = 1;
-                _context18.next = 4;
-                return this.getAccount(address);
-
-              case 4:
-                data = _context18.sent;
-                return _context18.abrupt("return", data.result.balances);
-
-              case 8:
-                _context18.prev = 8;
-                _context18.t0 = _context18["catch"](1);
-                return _context18.abrupt("return", []);
-
-              case 11:
-              case "end":
-                return _context18.stop();
-            }
-          }
-        }, _callee18, this, [[1, 8]]);
-      }));
-
-      function getBalance() {
-        return _getBalance.apply(this, arguments);
-      }
-
-      return getBalance;
-    }()
-    /**
-     * get markets
-     * @param {Number} limit max 1000 is default
-     * @param {Number} offset from beggining, default 0
-     * @return {Promise} resolves with http response
-     */
-
-  }, {
-    key: "getMarkets",
-    value: function () {
-      var _getMarkets = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19() {
-        var limit,
-            offset,
-            data,
-            _args19 = arguments;
-        return _regenerator["default"].wrap(function _callee19$(_context19) {
-          while (1) {
-            switch (_context19.prev = _context19.next) {
-              case 0:
-                limit = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : 1000;
-                offset = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : 0;
-                _context19.prev = 2;
-                _context19.next = 5;
-                return this._httpClient.request("get", "".concat(api.getMarkets, "?limit=").concat(limit, "&offset=").concat(offset));
-
-              case 5:
-                data = _context19.sent;
-                return _context19.abrupt("return", data);
-
-              case 9:
-                _context19.prev = 9;
-                _context19.t0 = _context19["catch"](2);
-                console.warn("getMarkets error", _context19.t0);
-                return _context19.abrupt("return", []);
-
-              case 13:
-              case "end":
-                return _context19.stop();
-            }
-          }
-        }, _callee19, this, [[2, 9]]);
-      }));
-
-      function getMarkets() {
-        return _getMarkets.apply(this, arguments);
-      }
-
-      return getMarkets;
-    }()
-    /**
-     * get transactions for an account
-     * @param {String} address optional address
-     * @param {Number} offset from beggining, default 0
-     * @return {Promise} resolves with http response
-     * @deprecated please use getTxs instead.
-     */
-
-  }, {
-    key: "getTransactions",
-    value: function () {
-      var _getTransactions = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee20() {
-        var address,
-            offset,
-            data,
-            _args20 = arguments;
-        return _regenerator["default"].wrap(function _callee20$(_context20) {
-          while (1) {
-            switch (_context20.prev = _context20.next) {
-              case 0:
-                address = _args20.length > 0 && _args20[0] !== undefined ? _args20[0] : this.address;
-                offset = _args20.length > 1 && _args20[1] !== undefined ? _args20[1] : 0;
-                _context20.prev = 2;
-                _context20.next = 5;
-                return this._httpClient.request("get", "".concat(api.getTransactions, "?address=").concat(address, "&offset=").concat(offset));
-
-              case 5:
-                data = _context20.sent;
-                return _context20.abrupt("return", data);
-
-              case 9:
-                _context20.prev = 9;
-                _context20.t0 = _context20["catch"](2);
-                console.warn("getTransactions error", _context20.t0);
-                return _context20.abrupt("return", []);
-
-              case 13:
-              case "end":
-                return _context20.stop();
-            }
-          }
-        }, _callee20, this, [[2, 9]]);
-      }));
-
-      function getTransactions() {
-        return _getTransactions.apply(this, arguments);
-      }
-
-      return getTransactions;
-    }()
-    /**
-     * get transactions for an account
-     * @param {String} address optional address
-     * @param {Number} startTime start time in milliseconds
-     * @param {Number} endTime end time in in milliseconds, endTime - startTime should be smaller than 7 days
-     * @return {Promise} resolves with http response ([more details](https://docs.binance.org/api-reference/dex-api/block-service.html#apiv1txs))
-     * ```js
-     * // Example:
-     * const client = new BncClient('https://testnet-api.binance.org')
-     * client.getTxs(...);
-     * ```
-     */
-
-  }, {
-    key: "getTxs",
-    value: function () {
-      var _getTxs = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee21() {
-        var address,
-            startTime,
-            endTime,
-            data,
-            _args21 = arguments;
-        return _regenerator["default"].wrap(function _callee21$(_context21) {
-          while (1) {
-            switch (_context21.prev = _context21.next) {
-              case 0:
-                address = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : this.address;
-                startTime = _args21.length > 1 ? _args21[1] : undefined;
-                endTime = _args21.length > 2 ? _args21[2] : undefined;
-                _context21.prev = 3;
-                _context21.next = 6;
-                return this._httpClient.request("get", "".concat(api.getTxs, "?address=").concat(address, "&startTime=").concat(startTime, "&endTime=").concat(endTime));
-
-              case 6:
-                data = _context21.sent;
-                return _context21.abrupt("return", data);
-
-              case 10:
-                _context21.prev = 10;
-                _context21.t0 = _context21["catch"](3);
-                console.warn("getTxs error", _context21.t0);
-                return _context21.abrupt("return", []);
-
-              case 14:
-              case "end":
-                return _context21.stop();
-            }
-          }
-        }, _callee21, this, [[3, 10]]);
-      }));
-
-      function getTxs() {
-        return _getTxs.apply(this, arguments);
-      }
-
-      return getTxs;
-    }()
-    /**
-     * get transaction
-     * @param {String} hash the transaction hash
-     * @return {Promise} resolves with http response
-     */
-
-  }, {
-    key: "getTx",
-    value: function () {
-      var _getTx = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee22(hash) {
-        var data;
-        return _regenerator["default"].wrap(function _callee22$(_context22) {
-          while (1) {
-            switch (_context22.prev = _context22.next) {
-              case 0:
-                _context22.prev = 0;
-                _context22.next = 3;
-                return this._httpClient.request("get", "".concat(api.getTx, "/").concat(hash));
-
-              case 3:
-                data = _context22.sent;
-                return _context22.abrupt("return", data);
-
-              case 7:
-                _context22.prev = 7;
-                _context22.t0 = _context22["catch"](0);
-                console.warn("getTx error", _context22.t0);
-                return _context22.abrupt("return", []);
-
-              case 11:
-              case "end":
-                return _context22.stop();
-            }
-          }
-        }, _callee22, this, [[0, 7]]);
-      }));
-
-      function getTx(_x35) {
-        return _getTx.apply(this, arguments);
-      }
-
-      return getTx;
-    }()
-    /**
-     * get depth for a given market
-     * @param {String} symbol the market pair
-     * @return {Promise} resolves with http response
-     */
-
-  }, {
-    key: "getDepth",
-    value: function () {
-      var _getDepth = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee23() {
-        var symbol,
-            data,
-            _args23 = arguments;
-        return _regenerator["default"].wrap(function _callee23$(_context23) {
-          while (1) {
-            switch (_context23.prev = _context23.next) {
-              case 0:
-                symbol = _args23.length > 0 && _args23[0] !== undefined ? _args23[0] : "BNB_BUSD-BD1";
-                _context23.prev = 1;
-                _context23.next = 4;
-                return this._httpClient.request("get", "".concat(api.getDepth, "?symbol=").concat(symbol));
-
-              case 4:
-                data = _context23.sent;
-                return _context23.abrupt("return", data);
-
-              case 8:
-                _context23.prev = 8;
-                _context23.t0 = _context23["catch"](1);
-                console.warn("getDepth error", _context23.t0);
-                return _context23.abrupt("return", []);
-
-              case 12:
-              case "end":
-                return _context23.stop();
-            }
-          }
-        }, _callee23, this, [[1, 8]]);
-      }));
-
-      function getDepth() {
-        return _getDepth.apply(this, arguments);
-      }
-
-      return getDepth;
-    }()
-    /**
-     * get open orders for an address
-     * @param {String} address binance address
-     * @param {String} symbol binance BEP2 symbol
-     * @return {Promise} resolves with http response
-     */
-
-  }, {
-    key: "getOpenOrders",
-    value: function () {
-      var _getOpenOrders = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee24() {
-        var address,
-            data,
-            _args24 = arguments;
-        return _regenerator["default"].wrap(function _callee24$(_context24) {
-          while (1) {
-            switch (_context24.prev = _context24.next) {
-              case 0:
-                address = _args24.length > 0 && _args24[0] !== undefined ? _args24[0] : this.address;
-                _context24.prev = 1;
-                _context24.next = 4;
-                return this._httpClient.request("get", "".concat(api.getOpenOrders, "?address=").concat(address));
-
-              case 4:
-                data = _context24.sent;
-                return _context24.abrupt("return", data);
-
-              case 8:
-                _context24.prev = 8;
-                _context24.t0 = _context24["catch"](1);
-                console.warn("getOpenOrders error", _context24.t0);
-                return _context24.abrupt("return", []);
-
-              case 12:
-              case "end":
-                return _context24.stop();
-            }
-          }
-        }, _callee24, this, [[1, 8]]);
-      }));
-
-      function getOpenOrders() {
-        return _getOpenOrders.apply(this, arguments);
-      }
-
-      return getOpenOrders;
-    }()
-    /**
-     * get atomic swap
-     * @param {String} swapID: ID of an existing swap
-     * @return {Promise} AtomicSwap
-     */
-
-  }, {
-    key: "getSwapByID",
-    value: function () {
-      var _getSwapByID = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee25(swapID) {
-        var data;
-        return _regenerator["default"].wrap(function _callee25$(_context25) {
-          while (1) {
-            switch (_context25.prev = _context25.next) {
-              case 0:
-                _context25.prev = 0;
-                _context25.next = 3;
-                return this._httpClient.request("get", "".concat(api.getSwaps, "/").concat(swapID));
-
-              case 3:
-                data = _context25.sent;
-                return _context25.abrupt("return", data);
-
-              case 7:
-                _context25.prev = 7;
-                _context25.t0 = _context25["catch"](0);
-                console.warn("query swap by swapID error", _context25.t0);
-                return _context25.abrupt("return", []);
-
-              case 11:
-              case "end":
-                return _context25.stop();
-            }
-          }
-        }, _callee25, this, [[0, 7]]);
-      }));
-
-      function getSwapByID(_x36) {
-        return _getSwapByID.apply(this, arguments);
-      }
-
-      return getSwapByID;
-    }()
-    /**
-     * query atomic swap list by creator address
-     * @param {String} creator: swap creator address
-     * @param {Number} offset from beginning, default 0
-     * @param {Number} limit, max 1000 is default
-     * @return {Promise} Array of AtomicSwap
-     */
-
-  }, {
-    key: "getSwapByCreator",
-    value: function () {
-      var _getSwapByCreator = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee26(creator) {
-        var limit,
-            offset,
-            data,
-            _args26 = arguments;
-        return _regenerator["default"].wrap(function _callee26$(_context26) {
-          while (1) {
-            switch (_context26.prev = _context26.next) {
-              case 0:
-                limit = _args26.length > 1 && _args26[1] !== undefined ? _args26[1] : 100;
-                offset = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : 0;
-                _context26.prev = 2;
-                _context26.next = 5;
-                return this._httpClient.request("get", "".concat(api.getSwaps, "?fromAddress=").concat(creator, "&limit=").concat(limit, "&offset=").concat(offset));
-
-              case 5:
-                data = _context26.sent;
-                return _context26.abrupt("return", data);
-
-              case 9:
-                _context26.prev = 9;
-                _context26.t0 = _context26["catch"](2);
-                console.warn("query swap list by swap creator error", _context26.t0);
-                return _context26.abrupt("return", []);
-
-              case 13:
-              case "end":
-                return _context26.stop();
-            }
-          }
-        }, _callee26, this, [[2, 9]]);
-      }));
-
-      function getSwapByCreator(_x37) {
-        return _getSwapByCreator.apply(this, arguments);
-      }
-
-      return getSwapByCreator;
-    }()
-    /**
-     * query atomic swap list by recipient address
-     * @param {String} recipient: the recipient address of the swap
-     * @param {Number} offset from beginning, default 0
-     * @param {Number} limit, max 1000 is default
-     * @return {Promise} Array of AtomicSwap
-     */
-
-  }, {
-    key: "getSwapByRecipient",
-    value: function () {
-      var _getSwapByRecipient = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee27(recipient) {
-        var limit,
-            offset,
-            data,
-            _args27 = arguments;
-        return _regenerator["default"].wrap(function _callee27$(_context27) {
-          while (1) {
-            switch (_context27.prev = _context27.next) {
-              case 0:
-                limit = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : 100;
-                offset = _args27.length > 2 && _args27[2] !== undefined ? _args27[2] : 0;
-                _context27.prev = 2;
-                _context27.next = 5;
-                return this._httpClient.request("get", "".concat(api.getSwaps, "?toAddress=").concat(recipient, "&limit=").concat(limit, "&offset=").concat(offset));
-
-              case 5:
-                data = _context27.sent;
-                return _context27.abrupt("return", data);
-
-              case 9:
-                _context27.prev = 9;
-                _context27.t0 = _context27["catch"](2);
-                console.warn("query swap list by swap recipient error", _context27.t0);
-                return _context27.abrupt("return", []);
-
-              case 13:
-              case "end":
-                return _context27.stop();
-            }
-          }
-        }, _callee27, this, [[2, 9]]);
-      }));
-
-      function getSwapByRecipient(_x38) {
-        return _getSwapByRecipient.apply(this, arguments);
-      }
-
-      return getSwapByRecipient;
-    }()
-    /**
-     * Creates a private key and returns it and its address.
-     * @return {object} the private key and address in an object.
-     * {
-     *  address,
-     *  privateKey
-     * }
-     */
-
-  }, {
-    key: "createAccount",
-    value: function createAccount() {
-      var privateKey = crypto.generatePrivateKey();
-      return {
-        privateKey: privateKey,
-        address: crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix)
-      };
-    }
-    /**
-     * Creates an account keystore object, and returns the private key and address.
-     * @param {String} password
-     *  {
-     *  privateKey,
-     *  address,
-     *  keystore
-     * }
-     */
-
-  }, {
-    key: "createAccountWithKeystore",
-    value: function createAccountWithKeystore(password) {
-      if (!password) {
-        throw new Error("password should not be falsy");
-      }
-
-      var privateKey = crypto.generatePrivateKey();
-      var address = crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix);
-      var keystore = crypto.generateKeyStore(privateKey, password);
-      return {
-        privateKey: privateKey,
-        address: address,
-        keystore: keystore
-      };
-    }
-    /**
-     * Creates an account from mnemonic seed phrase.
-     * @return {object}
-     * {
-     *  privateKey,
-     *  address,
-     *  mnemonic
-     * }
-     */
-
-  }, {
-    key: "createAccountWithMneomnic",
-    value: function createAccountWithMneomnic() {
-      var mnemonic = crypto.generateMnemonic();
-      var privateKey = crypto.getPrivateKeyFromMnemonic(mnemonic);
-      var address = crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix);
-      return {
-        privateKey: privateKey,
-        address: address,
-        mnemonic: mnemonic
-      };
-    }
-    /**
-     * Recovers an account from a keystore object.
-     * @param {object} keystore object.
-     * @param {string} password password.
-     * {
-     * privateKey,
-     * address
-     * }
-     */
-
-  }, {
-    key: "recoverAccountFromKeystore",
-    value: function recoverAccountFromKeystore(keystore, password) {
-      var privateKey = crypto.getPrivateKeyFromKeyStore(keystore, password);
-      var address = crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix);
-      return {
-        privateKey: privateKey,
-        address: address
-      };
-    }
-    /**
-     * Recovers an account from a mnemonic seed phrase.
-     * @param {string} mneomnic
-     * {
-     * privateKey,
-     * address
-     * }
-     */
-
-  }, {
-    key: "recoverAccountFromMnemonic",
-    value: function recoverAccountFromMnemonic(mnemonic) {
-      var privateKey = crypto.getPrivateKeyFromMnemonic(mnemonic);
-      var address = crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix);
-      return {
-        privateKey: privateKey,
-        address: address
-      };
-    } // support an old method name containing a typo
-
-  }, {
-    key: "recoverAccountFromMneomnic",
-    value: function recoverAccountFromMneomnic(mnemonic) {
-      return this.recoverAccountFromMnemonic(mnemonic);
-    }
-    /**
-     * Recovers an account using private key.
-     * @param {String} privateKey
-     * {
-     * privateKey,
-     * address
-     * }
-     */
-
-  }, {
-    key: "recoverAccountFromPrivateKey",
-    value: function recoverAccountFromPrivateKey(privateKey) {
-      var address = crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix);
-      return {
-        privateKey: privateKey,
-        address: address
-      };
-    }
-    /**
-     * Validates an address.
-     * @param {String} address
-     * @param {String} prefix
-     * @return {Boolean}
-     */
-
-  }, {
-    key: "checkAddress",
-    value: function checkAddress(address) {
-      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.addressPrefix;
-      return crypto.checkAddress(address, prefix);
-    }
-    /**
-     * Returns the address for the current account if setPrivateKey has been called on this client.
-     * @return {String}
-     */
-
-  }, {
-    key: "getClientKeyAddress",
-    value: function getClientKeyAddress() {
-      if (!this._privateKey) throw new Error("no private key is set on this client");
-      var address = crypto.getAddressFromPrivateKey(this._privateKey, this.addressPrefix);
-      this.address = address;
-      return address;
-    }
-  }]);
-  return BncClient;
-}();
-
-exports.BncClient = BncClient;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/stake/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/client/stake/index.d.ts
deleted file mode 100644
index 54acedd..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/stake/index.d.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-import { BncClient } from "../";
-/**
- * Stake
- */
-export declare class Stake {
-    private _bncClient;
-    /**
-     * @param {BncClient} bncClient
-     */
-    constructor(bncClient: BncClient);
-    bscDelegate({ delegateAddress, validatorAddress, amount, symbol, sideChainId, }: {
-        delegateAddress: string;
-        validatorAddress: string;
-        amount: number;
-        symbol?: string;
-        sideChainId?: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    bscUndelegate({ delegateAddress, validatorAddress, amount, symbol, sideChainId, }: {
-        delegateAddress: string;
-        validatorAddress: string;
-        amount: number;
-        symbol?: string;
-        sideChainId?: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    bscReDelegate({ delegateAddress, validatorSrcAddress, validatorDstAddress, amount, symbol, sideChainId, }: {
-        delegateAddress: string;
-        validatorSrcAddress: string;
-        validatorDstAddress: string;
-        amount: number;
-        symbol?: string;
-        sideChainId?: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    private broadcast;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/stake/index.js b/node_modules/@binance-chain/javascript-sdk/lib/client/stake/index.js
deleted file mode 100644
index 8638d6f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/stake/index.js
+++ /dev/null
@@ -1,282 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.Stake = void 0;
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var crypto = _interopRequireWildcard(require("../../crypto"));
-
-var _types = require("../../types");
-
-/**
- * Stake
- */
-var Stake = /*#__PURE__*/function () {
-  /**
-   * @param {BncClient} bncClient
-   */
-  function Stake(bncClient) {
-    (0, _classCallCheck2["default"])(this, Stake);
-    (0, _defineProperty2["default"])(this, "_bncClient", void 0);
-    this._bncClient = bncClient;
-  }
-
-  (0, _createClass2["default"])(Stake, [{
-    key: "bscDelegate",
-    value: function () {
-      var _bscDelegate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
-        var delegateAddress, validatorAddress, amount, _ref$symbol, symbol, _ref$sideChainId, sideChainId, bscDelegateMsg;
-
-        return _regenerator["default"].wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                delegateAddress = _ref.delegateAddress, validatorAddress = _ref.validatorAddress, amount = _ref.amount, _ref$symbol = _ref.symbol, symbol = _ref$symbol === void 0 ? "BNB" : _ref$symbol, _ref$sideChainId = _ref.sideChainId, sideChainId = _ref$sideChainId === void 0 ? "chapel" : _ref$sideChainId;
-
-                if (amount) {
-                  _context.next = 3;
-                  break;
-                }
-
-                throw new Error("amount should not be empty");
-
-              case 3:
-                if (delegateAddress) {
-                  _context.next = 5;
-                  break;
-                }
-
-                throw new Error("delegate address should not be null");
-
-              case 5:
-                if (crypto.checkAddress(validatorAddress, "bva")) {
-                  _context.next = 7;
-                  break;
-                }
-
-                throw new Error("validator address is not valid");
-
-              case 7:
-                amount = Number(new _big["default"](amount).mul(Math.pow(10, 8)).toString());
-                bscDelegateMsg = new _types.BscDelegateMsg({
-                  delegator_addr: delegateAddress,
-                  validator_addr: validatorAddress,
-                  delegation: {
-                    denom: symbol,
-                    amount: amount
-                  },
-                  side_chain_id: sideChainId
-                });
-                _context.next = 11;
-                return this.broadcast(bscDelegateMsg, delegateAddress);
-
-              case 11:
-                return _context.abrupt("return", _context.sent);
-
-              case 12:
-              case "end":
-                return _context.stop();
-            }
-          }
-        }, _callee, this);
-      }));
-
-      function bscDelegate(_x) {
-        return _bscDelegate.apply(this, arguments);
-      }
-
-      return bscDelegate;
-    }()
-  }, {
-    key: "bscUndelegate",
-    value: function () {
-      var _bscUndelegate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref2) {
-        var delegateAddress, validatorAddress, amount, _ref2$symbol, symbol, _ref2$sideChainId, sideChainId, unDelegateMsg;
-
-        return _regenerator["default"].wrap(function _callee2$(_context2) {
-          while (1) {
-            switch (_context2.prev = _context2.next) {
-              case 0:
-                delegateAddress = _ref2.delegateAddress, validatorAddress = _ref2.validatorAddress, amount = _ref2.amount, _ref2$symbol = _ref2.symbol, symbol = _ref2$symbol === void 0 ? "BNB" : _ref2$symbol, _ref2$sideChainId = _ref2.sideChainId, sideChainId = _ref2$sideChainId === void 0 ? "chapel" : _ref2$sideChainId;
-
-                if (amount) {
-                  _context2.next = 3;
-                  break;
-                }
-
-                throw new Error("amount should not be empty");
-
-              case 3:
-                if (delegateAddress) {
-                  _context2.next = 5;
-                  break;
-                }
-
-                throw new Error("delegate address should not be null");
-
-              case 5:
-                if (crypto.checkAddress(validatorAddress, "bva")) {
-                  _context2.next = 7;
-                  break;
-                }
-
-                throw new Error("validator address is not valid");
-
-              case 7:
-                amount = Number(new _big["default"](amount).mul(Math.pow(10, 8)).toString());
-                unDelegateMsg = new _types.BscUndelegateMsg({
-                  delegator_addr: delegateAddress,
-                  validator_addr: validatorAddress,
-                  amount: {
-                    denom: symbol,
-                    amount: amount
-                  },
-                  side_chain_id: sideChainId
-                });
-                _context2.next = 11;
-                return this.broadcast(unDelegateMsg, delegateAddress);
-
-              case 11:
-                return _context2.abrupt("return", _context2.sent);
-
-              case 12:
-              case "end":
-                return _context2.stop();
-            }
-          }
-        }, _callee2, this);
-      }));
-
-      function bscUndelegate(_x2) {
-        return _bscUndelegate.apply(this, arguments);
-      }
-
-      return bscUndelegate;
-    }()
-  }, {
-    key: "bscReDelegate",
-    value: function () {
-      var _bscReDelegate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref3) {
-        var delegateAddress, validatorSrcAddress, validatorDstAddress, amount, _ref3$symbol, symbol, _ref3$sideChainId, sideChainId, bscReDelegateMsg;
-
-        return _regenerator["default"].wrap(function _callee3$(_context3) {
-          while (1) {
-            switch (_context3.prev = _context3.next) {
-              case 0:
-                delegateAddress = _ref3.delegateAddress, validatorSrcAddress = _ref3.validatorSrcAddress, validatorDstAddress = _ref3.validatorDstAddress, amount = _ref3.amount, _ref3$symbol = _ref3.symbol, symbol = _ref3$symbol === void 0 ? "BNB" : _ref3$symbol, _ref3$sideChainId = _ref3.sideChainId, sideChainId = _ref3$sideChainId === void 0 ? "chapel" : _ref3$sideChainId;
-
-                if (amount) {
-                  _context3.next = 3;
-                  break;
-                }
-
-                throw new Error("amount should not be empty");
-
-              case 3:
-                if (delegateAddress) {
-                  _context3.next = 5;
-                  break;
-                }
-
-                throw new Error("delegate address should not be null");
-
-              case 5:
-                if (crypto.checkAddress(validatorSrcAddress, "bva")) {
-                  _context3.next = 7;
-                  break;
-                }
-
-                throw new Error("validator source address is not valid");
-
-              case 7:
-                if (crypto.checkAddress(validatorDstAddress, "bva")) {
-                  _context3.next = 9;
-                  break;
-                }
-
-                throw new Error("validator dest address is not valid");
-
-              case 9:
-                amount = Number(new _big["default"](amount).mul(Math.pow(10, 8)).toString());
-                bscReDelegateMsg = new _types.BscReDelegateMsg({
-                  delegator_addr: delegateAddress,
-                  validator_src_addr: validatorSrcAddress,
-                  validator_dst_addr: validatorDstAddress,
-                  amount: {
-                    denom: symbol,
-                    amount: amount
-                  },
-                  side_chain_id: sideChainId
-                });
-                _context3.next = 13;
-                return this.broadcast(bscReDelegateMsg, delegateAddress);
-
-              case 13:
-                return _context3.abrupt("return", _context3.sent);
-
-              case 14:
-              case "end":
-                return _context3.stop();
-            }
-          }
-        }, _callee3, this);
-      }));
-
-      function bscReDelegate(_x3) {
-        return _bscReDelegate.apply(this, arguments);
-      }
-
-      return bscReDelegate;
-    }()
-  }, {
-    key: "broadcast",
-    value: function () {
-      var _broadcast = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(msg, fromAddress, sequence) {
-        var signedTx;
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                _context4.next = 2;
-                return this._bncClient._prepareTransaction(msg.getMsg(), msg.getSignMsg(), fromAddress, sequence);
-
-              case 2:
-                signedTx = _context4.sent;
-                return _context4.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 4:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this);
-      }));
-
-      function broadcast(_x4, _x5, _x6) {
-        return _broadcast.apply(this, arguments);
-      }
-
-      return broadcast;
-    }()
-  }]);
-  return Stake;
-}();
-
-exports.Stake = Stake;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/swap/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/client/swap/index.d.ts
deleted file mode 100644
index 53d260e..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/swap/index.d.ts
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * @module Swap
- */
-import { BncClient } from "..";
-import { Coin } from "../../types";
-declare class Swap {
-    static instance: Swap;
-    private _bncClient;
-    /**
-     * @param {Object} bncClient
-     */
-    constructor(bncClient: BncClient);
-    /**
-     * HTLT(Hash timer locked transfer, create an atomic swap)
-     * @param {String} from
-     * @param {String} recipient
-     * @param {String} recipientOtherChain
-     * @param {String} senderOtherChain
-     * @param {String} randomNumberHash
-     * @param {Number} timestamp
-     * @param {Array} amount
-     * @param {String} expectedIncome
-     * @param {Number} heightSpan
-     * @param {boolean} crossChain
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    HTLT(from: string, recipient: string, recipientOtherChain: string, senderOtherChain: string, randomNumberHash: string, timestamp: number, amount: Coin[], expectedIncome: string, heightSpan: number, crossChain: boolean): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * depositHTLT(deposit assets to an existing swap)
-     * @param {String} from
-     * @param {String} swapID
-     * @param {Array} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    depositHTLT(from: string, swapID: string, amount: Coin[]): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * claimHTLT(claim assets from an swap)
-     * @param {String} from
-     * @param {String} swapID
-     * @param {String} randomNumber
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    claimHTLT(from: string, swapID: string, randomNumber: string): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * refundHTLT(refund assets from an swap)
-     * @param {String} from
-     * @param {String} swapID
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    refundHTLT(from: string, swapID: string): Promise<{
-        result: any;
-        status: number;
-    }>;
-}
-export default Swap;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/swap/index.js b/node_modules/@binance-chain/javascript-sdk/lib/client/swap/index.js
deleted file mode 100644
index 5b9c6ef..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/swap/index.js
+++ /dev/null
@@ -1,271 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _buffer = require("buffer");
-
-var crypto = _interopRequireWildcard(require("../../crypto"));
-
-var _types = require("../../types");
-
-var _validateHelper = require("../../utils/validateHelper");
-
-/**
- * @module Swap
- */
-var Swap = /*#__PURE__*/function () {
-  /**
-   * @param {Object} bncClient
-   */
-  function Swap(bncClient) {
-    (0, _classCallCheck2["default"])(this, Swap);
-    (0, _defineProperty2["default"])(this, "_bncClient", void 0);
-
-    if (!Swap.instance) {
-      this._bncClient = bncClient;
-      Swap.instance = this;
-    }
-
-    return Swap.instance;
-  }
-  /**
-   * HTLT(Hash timer locked transfer, create an atomic swap)
-   * @param {String} from
-   * @param {String} recipient
-   * @param {String} recipientOtherChain
-   * @param {String} senderOtherChain
-   * @param {String} randomNumberHash
-   * @param {Number} timestamp
-   * @param {Array} amount
-   * @param {String} expectedIncome
-   * @param {Number} heightSpan
-   * @param {boolean} crossChain
-   * @returns {Promise}  resolves with response (success or fail)
-   */
-
-
-  (0, _createClass2["default"])(Swap, [{
-    key: "HTLT",
-    value: function () {
-      var _HTLT = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(from, recipient, recipientOtherChain, senderOtherChain, randomNumberHash, timestamp, amount, expectedIncome, heightSpan, crossChain) {
-        var htltMsg, signHTLTMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                (0, _validateHelper.checkCoins)(amount);
-                htltMsg = {
-                  from: crypto.decodeAddress(from),
-                  to: crypto.decodeAddress(recipient),
-                  recipient_other_chain: recipientOtherChain,
-                  sender_other_chain: senderOtherChain,
-                  random_number_hash: _buffer.Buffer.from(randomNumberHash, "hex"),
-                  timestamp: timestamp,
-                  amount: amount,
-                  expected_income: expectedIncome,
-                  height_span: heightSpan,
-                  cross_chain: crossChain,
-                  aminoPrefix: _types.AminoPrefix.HTLTMsg
-                };
-                signHTLTMsg = {
-                  from: from,
-                  to: recipient,
-                  recipient_other_chain: recipientOtherChain,
-                  sender_other_chain: senderOtherChain,
-                  random_number_hash: randomNumberHash,
-                  timestamp: timestamp,
-                  amount: amount,
-                  expected_income: expectedIncome,
-                  height_span: heightSpan,
-                  cross_chain: crossChain
-                };
-                _context.next = 5;
-                return this._bncClient._prepareTransaction(htltMsg, signHTLTMsg, from);
-
-              case 5:
-                signedTx = _context.sent;
-                return _context.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 7:
-              case "end":
-                return _context.stop();
-            }
-          }
-        }, _callee, this);
-      }));
-
-      function HTLT(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {
-        return _HTLT.apply(this, arguments);
-      }
-
-      return HTLT;
-    }()
-    /**
-     * depositHTLT(deposit assets to an existing swap)
-     * @param {String} from
-     * @param {String} swapID
-     * @param {Array} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "depositHTLT",
-    value: function () {
-      var _depositHTLT = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(from, swapID, amount) {
-        var depositHTLTMsg, signDepositHTLTMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee2$(_context2) {
-          while (1) {
-            switch (_context2.prev = _context2.next) {
-              case 0:
-                (0, _validateHelper.checkCoins)(amount);
-                depositHTLTMsg = {
-                  from: crypto.decodeAddress(from),
-                  amount: amount,
-                  swap_id: _buffer.Buffer.from(swapID, "hex"),
-                  aminoPrefix: _types.AminoPrefix.DepositHTLTMsg
-                };
-                signDepositHTLTMsg = {
-                  from: from,
-                  amount: amount,
-                  swap_id: swapID
-                };
-                _context2.next = 5;
-                return this._bncClient._prepareTransaction(depositHTLTMsg, signDepositHTLTMsg, from);
-
-              case 5:
-                signedTx = _context2.sent;
-                return _context2.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 7:
-              case "end":
-                return _context2.stop();
-            }
-          }
-        }, _callee2, this);
-      }));
-
-      function depositHTLT(_x11, _x12, _x13) {
-        return _depositHTLT.apply(this, arguments);
-      }
-
-      return depositHTLT;
-    }()
-    /**
-     * claimHTLT(claim assets from an swap)
-     * @param {String} from
-     * @param {String} swapID
-     * @param {String} randomNumber
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "claimHTLT",
-    value: function () {
-      var _claimHTLT = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(from, swapID, randomNumber) {
-        var claimHTLTMsg, signClaimHTLTMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee3$(_context3) {
-          while (1) {
-            switch (_context3.prev = _context3.next) {
-              case 0:
-                claimHTLTMsg = {
-                  from: crypto.decodeAddress(from),
-                  swap_id: _buffer.Buffer.from(swapID, "hex"),
-                  random_number: _buffer.Buffer.from(randomNumber, "hex"),
-                  aminoPrefix: _types.AminoPrefix.ClaimHTLTMsg
-                };
-                signClaimHTLTMsg = {
-                  from: from,
-                  swap_id: swapID,
-                  random_number: randomNumber
-                };
-                _context3.next = 4;
-                return this._bncClient._prepareTransaction(claimHTLTMsg, signClaimHTLTMsg, from);
-
-              case 4:
-                signedTx = _context3.sent;
-                return _context3.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 6:
-              case "end":
-                return _context3.stop();
-            }
-          }
-        }, _callee3, this);
-      }));
-
-      function claimHTLT(_x14, _x15, _x16) {
-        return _claimHTLT.apply(this, arguments);
-      }
-
-      return claimHTLT;
-    }()
-    /**
-     * refundHTLT(refund assets from an swap)
-     * @param {String} from
-     * @param {String} swapID
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "refundHTLT",
-    value: function () {
-      var _refundHTLT = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(from, swapID) {
-        var refundHTLTMsg, signRefundHTLTMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                refundHTLTMsg = {
-                  from: crypto.decodeAddress(from),
-                  swap_id: _buffer.Buffer.from(swapID, "hex"),
-                  aminoPrefix: _types.AminoPrefix.RefundHTLTMsg
-                };
-                signRefundHTLTMsg = {
-                  from: from,
-                  swap_id: swapID
-                };
-                _context4.next = 4;
-                return this._bncClient._prepareTransaction(refundHTLTMsg, signRefundHTLTMsg, from);
-
-              case 4:
-                signedTx = _context4.sent;
-                return _context4.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 6:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this);
-      }));
-
-      function refundHTLT(_x17, _x18) {
-        return _refundHTLT.apply(this, arguments);
-      }
-
-      return refundHTLT;
-    }()
-  }]);
-  return Swap;
-}();
-
-(0, _defineProperty2["default"])(Swap, "instance", void 0);
-var _default = Swap;
-exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/token/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/client/token/index.d.ts
deleted file mode 100644
index 8ad1109..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/token/index.d.ts
+++ /dev/null
@@ -1,146 +0,0 @@
-import { BigSource } from "big.js";
-import { BncClient } from "..";
-import { Coin } from "../../types";
-export declare const validateMiniTokenSymbol: (symbol: string) => void;
-/**
- * issue or view tokens
- */
-declare class TokenManagement {
-    private _bncClient;
-    /**
-     * @param {Object} bncClient
-     */
-    constructor(bncClient: BncClient);
-    /**
-     * create a new asset on Binance Chain
-     * @param {String} - senderAddress
-     * @param {String} - tokenName
-     * @param {String} - symbol
-     * @param {Number} - totalSupply
-     * @param {Boolean} - mintable
-     * @returns {Promise} resolves with response (success or fail)
-     */
-    issue(senderAddress: string, tokenName: string, symbol: string, totalSupply?: number, mintable?: boolean): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * issue a new mini-token, total supply should be less than 1M
-     * @param {String} - senderAddress
-     * @param {String} - tokenName
-     * @param {String} - symbol
-     * @param {Number} - totalSupply
-     * @param {Boolean} - mintable
-     * @param {string} - token_uri
-     * @returns {Promise} resolves with response (success or fail)
-     */
-    issueMiniToken(senderAddress: string, tokenName: string, symbol: string, totalSupply?: number, mintable?: boolean, tokenUri?: string): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * issue a new tiny-token, total supply should be less than 10K
-     * @param {String} - senderAddress
-     * @param {String} - tokenName
-     * @param {String} - symbol
-     * @param {Number} - totalSupply
-     * @param {Boolean} - mintable
-     * @param {string} - token_uri
-     * @returns {Promise} resolves with response (success or fail)
-     */
-    issueTinyToken(senderAddress: string, tokenName: string, symbol: string, totalSupply?: number, mintable?: boolean, tokenUri?: string): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * set token URI of mini-token
-     */
-    setTokenUri({ fromAddress, tokenUri, symbol, }: {
-        fromAddress: string;
-        tokenUri: string;
-        symbol: string;
-    }): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * freeze some amount of token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {String} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    freeze(fromAddress: string, symbol: string, amount: BigSource): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * unfreeze some amount of token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {String} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    unfreeze(fromAddress: string, symbol: string, amount: BigSource): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * burn some amount of token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {Number} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    burn(fromAddress: string, symbol: string, amount: BigSource): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * mint tokens for an existing token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {Number} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    mint(fromAddress: string, symbol: string, amount: BigSource): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * lock token for a while
-     * @param {String} fromAddress
-     * @param {String} description
-     * @param {Array} amount
-     * @param {Number} lockTime
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    timeLock(fromAddress: string, description: string, amount: Coin[], lockTime: number): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * lock more token or increase locked period
-     * @param {String} fromAddress
-     * @param {Number} id
-     * @param {String} description
-     * @param {Array} amount
-     * @param {Number} lockTime
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    timeRelock(fromAddress: string, id: number, description: string, amount: Coin[], lockTime: number): Promise<{
-        result: any;
-        status: number;
-    }>;
-    /**
-     * unlock locked tokens
-     * @param {String} fromAddress
-     * @param {Number} id
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-    timeUnlock(fromAddress: string, id: number): Promise<{
-        result: any;
-        status: number;
-    }>;
-}
-export default TokenManagement;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/client/token/index.js b/node_modules/@binance-chain/javascript-sdk/lib/client/token/index.js
deleted file mode 100644
index 9d4c22f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/client/token/index.js
+++ /dev/null
@@ -1,893 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = exports.validateMiniTokenSymbol = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var _ = require("..");
-
-var crypto = _interopRequireWildcard(require("../../crypto"));
-
-var _types = require("../../types");
-
-var _validateHelper = require("../../utils/validateHelper");
-
-var MAXTOTALSUPPLY = 9000000000000000000;
-var MINI_TOKEN_MAX_TOTAL_SUPPAY = 1000000;
-var TINY_TOKEN_MAX_TOTAL_SUPPAY = 10000;
-
-var validateNonZeroAmount = /*#__PURE__*/function () {
-  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(amountParam, symbol, fromAddress, httpClient) {
-    var type,
-        amount,
-        _yield$httpClient$req,
-        result,
-        balance,
-        _args = arguments;
-
-    return _regenerator["default"].wrap(function _callee$(_context) {
-      while (1) {
-        switch (_context.prev = _context.next) {
-          case 0:
-            type = _args.length > 4 && _args[4] !== undefined ? _args[4] : "free";
-            amount = new _big["default"](amountParam);
-
-            if (!(amount.lte(0) || amount.gt(MAXTOTALSUPPLY))) {
-              _context.next = 4;
-              break;
-            }
-
-            throw new Error("invalid amount");
-
-          case 4:
-            _context.prev = 4;
-            _context.next = 7;
-            return httpClient.request("get", "".concat(_.api.getAccount, "/").concat(fromAddress));
-
-          case 7:
-            _yield$httpClient$req = _context.sent;
-            result = _yield$httpClient$req.result;
-            balance = result.balances.find(function (b) {
-              return b.symbol.toUpperCase() === symbol.toUpperCase();
-            });
-
-            if (balance) {
-              _context.next = 12;
-              break;
-            }
-
-            throw new Error("the account doesn't have ".concat(symbol));
-
-          case 12:
-            if (!amount.gte(balance[type])) {
-              _context.next = 14;
-              break;
-            }
-
-            throw new Error("the account doesn't have enougth balance");
-
-          case 14:
-            _context.next = 18;
-            break;
-
-          case 16:
-            _context.prev = 16;
-            _context.t0 = _context["catch"](4);
-
-          case 18:
-          case "end":
-            return _context.stop();
-        }
-      }
-    }, _callee, null, [[4, 16]]);
-  }));
-
-  return function validateNonZeroAmount(_x, _x2, _x3, _x4) {
-    return _ref.apply(this, arguments);
-  };
-}();
-
-var validateMiniTokenSymbol = function validateMiniTokenSymbol(symbol) {
-  if (!symbol) {
-    throw new Error("suffixed token symbol cannot be empty");
-  }
-
-  var splitedSymbol = symbol.split("-");
-
-  if (splitedSymbol.length != 2) {
-    throw new Error("suffixed mini-token symbol must contain a hyphen ('-')");
-  }
-
-  if (!splitedSymbol[1]) {
-    throw new Error("suffixed mini-token symbol must contain just one hyphen (\" - \")");
-  }
-
-  if (!/^[a-zA-z\d]{3,8}$/.test(splitedSymbol[0])) {
-    throw new Error("symbol should be alphanumeric and length is limited to 3~8");
-  }
-
-  if (!splitedSymbol[1].endsWith("M")) {
-    throw new Error("mini-token symbol suffix must end with M");
-  }
-};
-/**
- * issue or view tokens
- */
-
-
-exports.validateMiniTokenSymbol = validateMiniTokenSymbol;
-
-var TokenManagement = /*#__PURE__*/function () {
-  /**
-   * @param {Object} bncClient
-   */
-  function TokenManagement(bncClient) {
-    (0, _classCallCheck2["default"])(this, TokenManagement);
-    (0, _defineProperty2["default"])(this, "_bncClient", void 0);
-    this._bncClient = bncClient;
-  }
-  /**
-   * create a new asset on Binance Chain
-   * @param {String} - senderAddress
-   * @param {String} - tokenName
-   * @param {String} - symbol
-   * @param {Number} - totalSupply
-   * @param {Boolean} - mintable
-   * @returns {Promise} resolves with response (success or fail)
-   */
-
-
-  (0, _createClass2["default"])(TokenManagement, [{
-    key: "issue",
-    value: function () {
-      var _issue = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(senderAddress, tokenName, symbol) {
-        var totalSupply,
-            mintable,
-            issueMsg,
-            signIssueMsg,
-            signedTx,
-            _args2 = arguments;
-        return _regenerator["default"].wrap(function _callee2$(_context2) {
-          while (1) {
-            switch (_context2.prev = _context2.next) {
-              case 0:
-                totalSupply = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 0;
-                mintable = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : false;
-
-                if (senderAddress) {
-                  _context2.next = 4;
-                  break;
-                }
-
-                throw new Error("sender address cannot be empty");
-
-              case 4:
-                if (!(tokenName.length > 32)) {
-                  _context2.next = 6;
-                  break;
-                }
-
-                throw new Error("token name is limited to 32 characters");
-
-              case 6:
-                if (/^[a-zA-z\d]{3,8}$/.test(symbol)) {
-                  _context2.next = 8;
-                  break;
-                }
-
-                throw new Error("symbol should be alphanumeric and length is limited to 3~8");
-
-              case 8:
-                if (!(totalSupply <= 0 || totalSupply > MAXTOTALSUPPLY)) {
-                  _context2.next = 10;
-                  break;
-                }
-
-                throw new Error("invalid supply amount");
-
-              case 10:
-                totalSupply = Number(new _big["default"](totalSupply).mul(Math.pow(10, 8)).toString());
-                issueMsg = {
-                  from: crypto.decodeAddress(senderAddress),
-                  name: tokenName,
-                  symbol: symbol,
-                  total_supply: totalSupply,
-                  mintable: mintable,
-                  aminoPrefix: _types.AminoPrefix.IssueMsg
-                };
-                signIssueMsg = {
-                  from: senderAddress,
-                  name: tokenName,
-                  symbol: symbol,
-                  total_supply: totalSupply,
-                  mintable: mintable
-                };
-                _context2.next = 15;
-                return this._bncClient._prepareTransaction(issueMsg, signIssueMsg, senderAddress);
-
-              case 15:
-                signedTx = _context2.sent;
-                return _context2.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 17:
-              case "end":
-                return _context2.stop();
-            }
-          }
-        }, _callee2, this);
-      }));
-
-      function issue(_x5, _x6, _x7) {
-        return _issue.apply(this, arguments);
-      }
-
-      return issue;
-    }()
-    /**
-     * issue a new mini-token, total supply should be less than 1M
-     * @param {String} - senderAddress
-     * @param {String} - tokenName
-     * @param {String} - symbol
-     * @param {Number} - totalSupply
-     * @param {Boolean} - mintable
-     * @param {string} - token_uri
-     * @returns {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "issueMiniToken",
-    value: function () {
-      var _issueMiniToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(senderAddress, tokenName, symbol) {
-        var totalSupply,
-            mintable,
-            tokenUri,
-            issueMiniMsg,
-            signedTx,
-            _args3 = arguments;
-        return _regenerator["default"].wrap(function _callee3$(_context3) {
-          while (1) {
-            switch (_context3.prev = _context3.next) {
-              case 0:
-                totalSupply = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;
-                mintable = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : false;
-                tokenUri = _args3.length > 5 ? _args3[5] : undefined;
-
-                if (senderAddress) {
-                  _context3.next = 5;
-                  break;
-                }
-
-                throw new Error("sender address cannot be empty");
-
-              case 5:
-                if (!(tokenName.length > 32)) {
-                  _context3.next = 7;
-                  break;
-                }
-
-                throw new Error("token name is limited to 32 characters");
-
-              case 7:
-                if (/^[a-zA-z\d]{3,8}$/.test(symbol)) {
-                  _context3.next = 9;
-                  break;
-                }
-
-                throw new Error("symbol should be alphanumeric and length is limited to 3~8");
-
-              case 9:
-                if (!(totalSupply <= 0 || totalSupply > MINI_TOKEN_MAX_TOTAL_SUPPAY)) {
-                  _context3.next = 11;
-                  break;
-                }
-
-                throw new Error("invalid supply amount");
-
-              case 11:
-                totalSupply = Number(new _big["default"](totalSupply).mul(Math.pow(10, 8)).toString());
-                issueMiniMsg = new _types.IssueMiniTokenMsg({
-                  name: tokenName,
-                  symbol: symbol,
-                  total_supply: totalSupply,
-                  mintable: mintable,
-                  token_uri: tokenUri,
-                  from: senderAddress
-                });
-                _context3.next = 15;
-                return this._bncClient._prepareTransaction(issueMiniMsg.getMsg(), issueMiniMsg.getSignMsg(), senderAddress);
-
-              case 15:
-                signedTx = _context3.sent;
-                return _context3.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 17:
-              case "end":
-                return _context3.stop();
-            }
-          }
-        }, _callee3, this);
-      }));
-
-      function issueMiniToken(_x8, _x9, _x10) {
-        return _issueMiniToken.apply(this, arguments);
-      }
-
-      return issueMiniToken;
-    }()
-    /**
-     * issue a new tiny-token, total supply should be less than 10K
-     * @param {String} - senderAddress
-     * @param {String} - tokenName
-     * @param {String} - symbol
-     * @param {Number} - totalSupply
-     * @param {Boolean} - mintable
-     * @param {string} - token_uri
-     * @returns {Promise} resolves with response (success or fail)
-     */
-
-  }, {
-    key: "issueTinyToken",
-    value: function () {
-      var _issueTinyToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(senderAddress, tokenName, symbol) {
-        var totalSupply,
-            mintable,
-            tokenUri,
-            issueMiniMsg,
-            signedTx,
-            _args4 = arguments;
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                totalSupply = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : 0;
-                mintable = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : false;
-                tokenUri = _args4.length > 5 ? _args4[5] : undefined;
-
-                if (senderAddress) {
-                  _context4.next = 5;
-                  break;
-                }
-
-                throw new Error("sender address cannot be empty");
-
-              case 5:
-                if (!(tokenName.length > 32)) {
-                  _context4.next = 7;
-                  break;
-                }
-
-                throw new Error("token name is limited to 32 characters");
-
-              case 7:
-                if (/^[a-zA-z\d]{3,8}$/.test(symbol)) {
-                  _context4.next = 9;
-                  break;
-                }
-
-                throw new Error("symbol should be alphanumeric and length is limited to 3~8");
-
-              case 9:
-                if (!(totalSupply <= 0 || totalSupply > TINY_TOKEN_MAX_TOTAL_SUPPAY)) {
-                  _context4.next = 11;
-                  break;
-                }
-
-                throw new Error("invalid supply amount");
-
-              case 11:
-                totalSupply = Number(new _big["default"](totalSupply).mul(Math.pow(10, 8)).toString());
-                issueMiniMsg = new _types.IssueTinyTokenMsg({
-                  name: tokenName,
-                  symbol: symbol,
-                  total_supply: totalSupply,
-                  mintable: mintable,
-                  token_uri: tokenUri,
-                  from: senderAddress
-                });
-                _context4.next = 15;
-                return this._bncClient._prepareTransaction(issueMiniMsg.getMsg(), issueMiniMsg.getSignMsg(), senderAddress);
-
-              case 15:
-                signedTx = _context4.sent;
-                return _context4.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 17:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this);
-      }));
-
-      function issueTinyToken(_x11, _x12, _x13) {
-        return _issueTinyToken.apply(this, arguments);
-      }
-
-      return issueTinyToken;
-    }()
-    /**
-     * set token URI of mini-token
-     */
-
-  }, {
-    key: "setTokenUri",
-    value: function () {
-      var _setTokenUri = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(_ref2) {
-        var fromAddress, tokenUri, symbol, setUriMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee5$(_context5) {
-          while (1) {
-            switch (_context5.prev = _context5.next) {
-              case 0:
-                fromAddress = _ref2.fromAddress, tokenUri = _ref2.tokenUri, symbol = _ref2.symbol;
-                validateMiniTokenSymbol(symbol);
-
-                if (!(tokenUri.length > 2048)) {
-                  _context5.next = 4;
-                  break;
-                }
-
-                throw new Error("uri cannot be longer than 2048 characters");
-
-              case 4:
-                if (fromAddress) {
-                  _context5.next = 6;
-                  break;
-                }
-
-                throw new Error("address cannot be empty");
-
-              case 6:
-                setUriMsg = new _types.SetTokenUriMsg({
-                  from: fromAddress,
-                  token_uri: tokenUri,
-                  symbol: symbol
-                });
-                _context5.next = 9;
-                return this._bncClient._prepareTransaction(setUriMsg.getMsg(), setUriMsg.getSignMsg(), fromAddress);
-
-              case 9:
-                signedTx = _context5.sent;
-                return _context5.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 11:
-              case "end":
-                return _context5.stop();
-            }
-          }
-        }, _callee5, this);
-      }));
-
-      function setTokenUri(_x14) {
-        return _setTokenUri.apply(this, arguments);
-      }
-
-      return setTokenUri;
-    }()
-    /**
-     * freeze some amount of token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {String} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "freeze",
-    value: function () {
-      var _freeze = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(fromAddress, symbol, amount) {
-        var freezeMsg, freezeSignMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee6$(_context6) {
-          while (1) {
-            switch (_context6.prev = _context6.next) {
-              case 0:
-                (0, _validateHelper.validateSymbol)(symbol);
-                validateNonZeroAmount(amount, symbol, fromAddress, this._bncClient._httpClient, "free");
-                amount = +Number(new _big["default"](amount).mul(Math.pow(10, 8)).toString());
-                freezeMsg = {
-                  from: crypto.decodeAddress(fromAddress),
-                  symbol: symbol,
-                  amount: amount,
-                  aminoPrefix: _types.AminoPrefix.FreezeMsg
-                };
-                freezeSignMsg = {
-                  amount: amount,
-                  from: fromAddress,
-                  symbol: symbol
-                };
-                _context6.next = 7;
-                return this._bncClient._prepareTransaction(freezeMsg, freezeSignMsg, fromAddress);
-
-              case 7:
-                signedTx = _context6.sent;
-                return _context6.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 9:
-              case "end":
-                return _context6.stop();
-            }
-          }
-        }, _callee6, this);
-      }));
-
-      function freeze(_x15, _x16, _x17) {
-        return _freeze.apply(this, arguments);
-      }
-
-      return freeze;
-    }()
-    /**
-     * unfreeze some amount of token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {String} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "unfreeze",
-    value: function () {
-      var _unfreeze = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(fromAddress, symbol, amount) {
-        var unfreezeMsg, unfreezeSignMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee7$(_context7) {
-          while (1) {
-            switch (_context7.prev = _context7.next) {
-              case 0:
-                (0, _validateHelper.validateSymbol)(symbol);
-                validateNonZeroAmount(amount, symbol, fromAddress, this._bncClient._httpClient, "frozen");
-                amount = +Number(new _big["default"](amount).mul(Math.pow(10, 8)).toString());
-                unfreezeMsg = {
-                  from: crypto.decodeAddress(fromAddress),
-                  symbol: symbol,
-                  amount: amount,
-                  aminoPrefix: _types.AminoPrefix.UnfreezeMsg
-                };
-                unfreezeSignMsg = {
-                  amount: amount,
-                  from: fromAddress,
-                  symbol: symbol
-                };
-                _context7.next = 7;
-                return this._bncClient._prepareTransaction(unfreezeMsg, unfreezeSignMsg, fromAddress);
-
-              case 7:
-                signedTx = _context7.sent;
-                return _context7.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 9:
-              case "end":
-                return _context7.stop();
-            }
-          }
-        }, _callee7, this);
-      }));
-
-      function unfreeze(_x18, _x19, _x20) {
-        return _unfreeze.apply(this, arguments);
-      }
-
-      return unfreeze;
-    }()
-    /**
-     * burn some amount of token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {Number} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "burn",
-    value: function () {
-      var _burn = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(fromAddress, symbol, amount) {
-        var burnMsg, burnSignMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee8$(_context8) {
-          while (1) {
-            switch (_context8.prev = _context8.next) {
-              case 0:
-                (0, _validateHelper.validateSymbol)(symbol);
-                validateNonZeroAmount(amount, symbol, fromAddress, this._bncClient._httpClient);
-                amount = +Number(new _big["default"](amount).mul(Math.pow(10, 8)).toString());
-                burnMsg = {
-                  from: crypto.decodeAddress(fromAddress),
-                  symbol: symbol,
-                  amount: amount,
-                  aminoPrefix: _types.AminoPrefix.BurnMsg
-                };
-                burnSignMsg = {
-                  amount: amount,
-                  from: fromAddress,
-                  symbol: symbol
-                };
-                _context8.next = 7;
-                return this._bncClient._prepareTransaction(burnMsg, burnSignMsg, fromAddress);
-
-              case 7:
-                signedTx = _context8.sent;
-                return _context8.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 9:
-              case "end":
-                return _context8.stop();
-            }
-          }
-        }, _callee8, this);
-      }));
-
-      function burn(_x21, _x22, _x23) {
-        return _burn.apply(this, arguments);
-      }
-
-      return burn;
-    }()
-    /**
-     * mint tokens for an existing token
-     * @param {String} fromAddress
-     * @param {String} symbol
-     * @param {Number} amount
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "mint",
-    value: function () {
-      var _mint = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(fromAddress, symbol, amount) {
-        var mintMsg, mintSignMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee9$(_context9) {
-          while (1) {
-            switch (_context9.prev = _context9.next) {
-              case 0:
-                (0, _validateHelper.validateSymbol)(symbol);
-
-                if (!(amount <= 0 || amount > MAXTOTALSUPPLY)) {
-                  _context9.next = 3;
-                  break;
-                }
-
-                throw new Error("invalid amount");
-
-              case 3:
-                amount = Number(new _big["default"](amount).mul(Math.pow(10, 8)).toString());
-                mintMsg = {
-                  from: crypto.decodeAddress(fromAddress),
-                  symbol: symbol,
-                  amount: amount,
-                  aminoPrefix: _types.AminoPrefix.MintMsg
-                };
-                mintSignMsg = {
-                  amount: amount,
-                  from: fromAddress,
-                  symbol: symbol
-                };
-                _context9.next = 8;
-                return this._bncClient._prepareTransaction(mintMsg, mintSignMsg, fromAddress);
-
-              case 8:
-                signedTx = _context9.sent;
-                return _context9.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 10:
-              case "end":
-                return _context9.stop();
-            }
-          }
-        }, _callee9, this);
-      }));
-
-      function mint(_x24, _x25, _x26) {
-        return _mint.apply(this, arguments);
-      }
-
-      return mint;
-    }()
-    /**
-     * lock token for a while
-     * @param {String} fromAddress
-     * @param {String} description
-     * @param {Array} amount
-     * @param {Number} lockTime
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "timeLock",
-    value: function () {
-      var _timeLock = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(fromAddress, description, amount, lockTime) {
-        var timeLockMsg, signTimeLockMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee10$(_context10) {
-          while (1) {
-            switch (_context10.prev = _context10.next) {
-              case 0:
-                (0, _validateHelper.checkCoins)(amount);
-
-                if (!(description.length > 128)) {
-                  _context10.next = 3;
-                  break;
-                }
-
-                throw new Error("description is too long");
-
-              case 3:
-                if (!(lockTime < 60 || lockTime > 253402300800)) {
-                  _context10.next = 5;
-                  break;
-                }
-
-                throw new Error("timeTime must be in [60, 253402300800]");
-
-              case 5:
-                timeLockMsg = {
-                  from: crypto.decodeAddress(fromAddress),
-                  description: description,
-                  amount: amount,
-                  lock_time: lockTime,
-                  aminoPrefix: _types.AminoPrefix.TimeLockMsg
-                };
-                signTimeLockMsg = {
-                  from: fromAddress,
-                  description: description,
-                  amount: amount,
-                  lock_time: lockTime
-                };
-                _context10.next = 9;
-                return this._bncClient._prepareTransaction(timeLockMsg, signTimeLockMsg, fromAddress);
-
-              case 9:
-                signedTx = _context10.sent;
-                return _context10.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 11:
-              case "end":
-                return _context10.stop();
-            }
-          }
-        }, _callee10, this);
-      }));
-
-      function timeLock(_x27, _x28, _x29, _x30) {
-        return _timeLock.apply(this, arguments);
-      }
-
-      return timeLock;
-    }()
-    /**
-     * lock more token or increase locked period
-     * @param {String} fromAddress
-     * @param {Number} id
-     * @param {String} description
-     * @param {Array} amount
-     * @param {Number} lockTime
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "timeRelock",
-    value: function () {
-      var _timeRelock = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(fromAddress, id, description, amount, lockTime) {
-        var timeRelockMsg, signTimeRelockMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee11$(_context11) {
-          while (1) {
-            switch (_context11.prev = _context11.next) {
-              case 0:
-                (0, _validateHelper.checkCoins)(amount);
-
-                if (!(description.length > 128)) {
-                  _context11.next = 3;
-                  break;
-                }
-
-                throw new Error("description is too long");
-
-              case 3:
-                if (!(lockTime < 60 || lockTime > 253402300800)) {
-                  _context11.next = 5;
-                  break;
-                }
-
-                throw new Error("timeTime must be in [60, 253402300800]");
-
-              case 5:
-                timeRelockMsg = {
-                  from: crypto.decodeAddress(fromAddress),
-                  time_lock_id: id,
-                  description: description,
-                  amount: amount,
-                  lock_time: lockTime,
-                  aminoPrefix: _types.AminoPrefix.TimeRelockMsg
-                };
-                signTimeRelockMsg = {
-                  from: fromAddress,
-                  time_lock_id: id,
-                  description: description,
-                  amount: amount,
-                  lock_time: lockTime
-                };
-                _context11.next = 9;
-                return this._bncClient._prepareTransaction(timeRelockMsg, signTimeRelockMsg, fromAddress);
-
-              case 9:
-                signedTx = _context11.sent;
-                return _context11.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 11:
-              case "end":
-                return _context11.stop();
-            }
-          }
-        }, _callee11, this);
-      }));
-
-      function timeRelock(_x31, _x32, _x33, _x34, _x35) {
-        return _timeRelock.apply(this, arguments);
-      }
-
-      return timeRelock;
-    }()
-    /**
-     * unlock locked tokens
-     * @param {String} fromAddress
-     * @param {Number} id
-     * @returns {Promise}  resolves with response (success or fail)
-     */
-
-  }, {
-    key: "timeUnlock",
-    value: function () {
-      var _timeUnlock = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(fromAddress, id) {
-        var timeUnlockMsg, signTimeUnlockMsg, signedTx;
-        return _regenerator["default"].wrap(function _callee12$(_context12) {
-          while (1) {
-            switch (_context12.prev = _context12.next) {
-              case 0:
-                timeUnlockMsg = {
-                  from: crypto.decodeAddress(fromAddress),
-                  time_lock_id: id,
-                  aminoPrefix: _types.AminoPrefix.TimeUnlockMsg
-                };
-                signTimeUnlockMsg = {
-                  from: fromAddress,
-                  time_lock_id: id
-                };
-                _context12.next = 4;
-                return this._bncClient._prepareTransaction(timeUnlockMsg, signTimeUnlockMsg, fromAddress);
-
-              case 4:
-                signedTx = _context12.sent;
-                return _context12.abrupt("return", this._bncClient._broadcastDelegate(signedTx));
-
-              case 6:
-              case "end":
-                return _context12.stop();
-            }
-          }
-        }, _callee12, this);
-      }));
-
-      function timeUnlock(_x36, _x37) {
-        return _timeUnlock.apply(this, arguments);
-      }
-
-      return timeUnlock;
-    }()
-  }]);
-  return TokenManagement;
-}();
-
-var _default = TokenManagement;
-exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/crypto/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/crypto/index.d.ts
deleted file mode 100644
index 220f075..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/crypto/index.d.ts
+++ /dev/null
@@ -1,148 +0,0 @@
-/// <reference types="node" />
-import * as bip39 from "bip39";
-import { curve } from "elliptic";
-export interface KeyStore {
-    version: number;
-    id: string;
-    crypto: {
-        ciphertext: string;
-        cipherparams: {
-            iv: string;
-        };
-        cipher: string;
-        kdf: string;
-        kdfparams: {
-            dklen: number;
-            salt: string;
-            c: number;
-            prf: string;
-        };
-        /** Must use sha3 according to web3 secret storage spec. */
-        mac: string;
-    };
-}
-/**
- * Decodes an address in bech32 format.
- * @category crypto
- * @param {string} value the bech32 address to decode
- */
-export declare const decodeAddress: (value: string) => Buffer;
-/**
- * Checks whether an address is valid.
- * @category crypto
- * @param {string} address the bech32 address to decode
- * @param {string} hrp the prefix to check for the bech32 address
- * @return {boolean}
- */
-export declare const checkAddress: (address: string, hrp: string) => boolean;
-/**
- * Encodes an address from input data bytes.
- * @category crypto
- * @param {string} value the public key to encode
- * @param {*} prefix the address prefix
- * @param {*} type the output type (default: hex)
- */
-export declare const encodeAddress: (value: string | Buffer, prefix?: string, type?: BufferEncoding) => string;
-/**
- * Generates 32 bytes of random entropy
- * @category crypto
- * @param {number} len output length (default: 32 bytes)
- * @returns {string} entropy bytes hexstring
- */
-export declare const generatePrivateKey: (len?: number) => string;
-/**
- * Generates an arrayBuffer filled with random bits.
- * @category crypto
- * @param {number} length - Length of buffer.
- * @returns {ArrayBuffer}
- */
-export declare const generateRandomArray: (length: number) => ArrayBuffer;
-/**
- * @category crypto
- * @param {string} publicKey - Encoded public key
- * @return {Elliptic.PublicKey} public key hexstring
- */
-export declare const getPublicKey: (publicKey: string) => curve.base.BasePoint;
-/**
- * Calculates the public key from a given private key.
- * @category crypto
- * @param {string} privateKeyHex the private key hexstring
- * @return {string} public key hexstring
- */
-export declare const getPublicKeyFromPrivateKey: (privateKeyHex: string) => string;
-/**
- * PubKey performs the point-scalar multiplication from the privKey on the
- * generator point to get the pubkey.
- * @category crypto
- * @param {Buffer} privateKey
- * @return {Elliptic.PublicKey} PubKey
- * */
-export declare const generatePubKey: (privateKey: Buffer) => curve.base.BasePoint;
-/**
- * Gets an address from a public key hex.
- * @category crypto
- * @param {string} publicKeyHex the public key hexstring
- * @param {string} prefix the address prefix
- */
-export declare const getAddressFromPublicKey: (publicKeyHex: string, prefix?: string | undefined) => string;
-/**
- * Gets an address from a private key.
- * @category crypto
- * @param {string} privateKeyHex the private key hexstring
- * @param {string} prefix the address prefix
- */
-export declare const getAddressFromPrivateKey: (privateKeyHex: string, prefix?: string | undefined) => string;
-/**
- * Generates a signature (64 byte <r,s>) for a transaction based on given private key.
- * @category crypto
- * @param {string} signBytesHex - Unsigned transaction sign bytes hexstring.
- * @param {string | Buffer} privateKey - The private key.
- * @return {Buffer} Signature. Does not include tx.
- */
-export declare const generateSignature: (signBytesHex: string, privateKey: string | Buffer) => Buffer;
-/**
- * Verifies a signature (64 byte <r,s>) given the sign bytes and public key.
- * @category crypto
- * @param {string} sigHex - The signature hexstring.
- * @param {string} signBytesHex - Unsigned transaction sign bytes hexstring.
- * @param {string} publicKeyHex - The public key.
- * @return {boolean}
- */
-export declare const verifySignature: (sigHex: string, signBytesHex: string, publicKeyHex: string) => boolean;
-/**
- * Generates a keystore object (web3 secret storage format) given a private key to store and a password.
- * @category crypto
- * @param {string} privateKeyHex the private key hexstring.
- * @param {string} password the password.
- * @return {object} the keystore object.
- */
-export declare const generateKeyStore: (privateKeyHex: string, password: string) => KeyStore;
-/**
- * Gets a private key from a keystore given its password.
- * @category crypto
- * @param {string} keystore the keystore in json format
- * @param {string} password the password.
- */
-export declare const getPrivateKeyFromKeyStore: (keystore: string, password: string) => string;
-/**
- * Generates mnemonic phrase words using random entropy.
- * @category crypto
- */
-export declare const generateMnemonic: () => string;
-/**
- * Validates mnemonic phrase words.
- * @ignore
- * @param {string} mnemonic the mnemonic phrase words
- * @return {bool} validation result
- */
-export declare const validateMnemonic: typeof bip39.validateMnemonic;
-/**
- * Get a private key from mnemonic words.
- * @category crypto
- * @param {string} mnemonic the mnemonic phrase words
- * @param {Boolean} derive derive a private key using the default HD path (default: true)
- * @param {number} index the bip44 address index (default: 0)
- * @param {string} password according to bip39
- * @return {string} hexstring
- */
-export declare const getPrivateKeyFromMnemonic: (mnemonic: string, derive?: boolean, index?: number, password?: string) => string;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/crypto/index.js b/node_modules/@binance-chain/javascript-sdk/lib/crypto/index.js
deleted file mode 100644
index e8a5927..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/crypto/index.js
+++ /dev/null
@@ -1,407 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.getPrivateKeyFromMnemonic = exports.validateMnemonic = exports.generateMnemonic = exports.getPrivateKeyFromKeyStore = exports.generateKeyStore = exports.verifySignature = exports.generateSignature = exports.getAddressFromPrivateKey = exports.getAddressFromPublicKey = exports.generatePubKey = exports.getPublicKeyFromPrivateKey = exports.getPublicKey = exports.generateRandomArray = exports.generatePrivateKey = exports.encodeAddress = exports.checkAddress = exports.decodeAddress = void 0;
-
-var _bech = _interopRequireDefault(require("bech32"));
-
-var bip32 = _interopRequireWildcard(require("bip32"));
-
-var bip39 = _interopRequireWildcard(require("bip39"));
-
-var _cryptoBrowserify = _interopRequireDefault(require("crypto-browserify"));
-
-var _elliptic = require("elliptic");
-
-var _is_js = _interopRequireDefault(require("is_js"));
-
-var _secureRandom = _interopRequireDefault(require("secure-random"));
-
-var _tinySecp256k = _interopRequireDefault(require("tiny-secp256k1"));
-
-var _uuid = _interopRequireDefault(require("uuid"));
-
-var _utils = require("../utils");
-
-// secp256k1 privkey is 32 bytes
-var PRIVKEY_LEN = 32;
-var MNEMONIC_LEN = 256;
-var DECODED_ADDRESS_LEN = 20;
-var CURVE = "secp256k1"; //hdpath
-
-var HDPATH = "44'/714'/0'/0/";
-var ec = new _elliptic.ec(CURVE);
-/**
- * Decodes an address in bech32 format.
- * @category crypto
- * @param {string} value the bech32 address to decode
- */
-
-var decodeAddress = function decodeAddress(value) {
-  var decodeAddress = _bech["default"].decode(value);
-
-  return Buffer.from(_bech["default"].fromWords(decodeAddress.words));
-};
-/**
- * Checks whether an address is valid.
- * @category crypto
- * @param {string} address the bech32 address to decode
- * @param {string} hrp the prefix to check for the bech32 address
- * @return {boolean}
- */
-
-
-exports.decodeAddress = decodeAddress;
-
-var checkAddress = function checkAddress(address, hrp) {
-  try {
-    if (!address.startsWith(hrp)) {
-      return false;
-    }
-
-    var decodedAddress = _bech["default"].decode(address);
-
-    var decodedAddressLength = decodeAddress(address).length;
-
-    if (decodedAddressLength === DECODED_ADDRESS_LEN && decodedAddress.prefix === hrp) {
-      return true;
-    }
-
-    return false;
-  } catch (err) {
-    return false;
-  }
-};
-/**
- * Encodes an address from input data bytes.
- * @category crypto
- * @param {string} value the public key to encode
- * @param {*} prefix the address prefix
- * @param {*} type the output type (default: hex)
- */
-
-
-exports.checkAddress = checkAddress;
-
-var encodeAddress = function encodeAddress(value) {
-  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "tbnb";
-  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "hex";
-  var words;
-
-  if (Buffer.isBuffer(value)) {
-    words = _bech["default"].toWords(Buffer.from(value));
-  } else {
-    words = _bech["default"].toWords(Buffer.from(value, type));
-  }
-
-  return _bech["default"].encode(prefix, words);
-};
-/**
- * Generates 32 bytes of random entropy
- * @category crypto
- * @param {number} len output length (default: 32 bytes)
- * @returns {string} entropy bytes hexstring
- */
-
-
-exports.encodeAddress = encodeAddress;
-
-var generatePrivateKey = function generatePrivateKey() {
-  var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRIVKEY_LEN;
-  return (0, _utils.ab2hexstring)((0, _secureRandom["default"])(len));
-};
-/**
- * Generates an arrayBuffer filled with random bits.
- * @category crypto
- * @param {number} length - Length of buffer.
- * @returns {ArrayBuffer}
- */
-
-
-exports.generatePrivateKey = generatePrivateKey;
-
-var generateRandomArray = function generateRandomArray(length) {
-  return (0, _secureRandom["default"])(length);
-};
-/**
- * @category crypto
- * @param {string} publicKey - Encoded public key
- * @return {Elliptic.PublicKey} public key hexstring
- */
-
-
-exports.generateRandomArray = generateRandomArray;
-
-var getPublicKey = function getPublicKey(publicKey) {
-  var keyPair = ec.keyFromPublic(publicKey, "hex");
-  return keyPair.getPublic();
-};
-/**
- * Calculates the public key from a given private key.
- * @category crypto
- * @param {string} privateKeyHex the private key hexstring
- * @return {string} public key hexstring
- */
-
-
-exports.getPublicKey = getPublicKey;
-
-var getPublicKeyFromPrivateKey = function getPublicKeyFromPrivateKey(privateKeyHex) {
-  if (!privateKeyHex || privateKeyHex.length !== PRIVKEY_LEN * 2) {
-    throw new Error("invalid privateKey");
-  }
-
-  var curve = new _elliptic.ec(CURVE);
-  var keypair = curve.keyFromPrivate(privateKeyHex, "hex");
-  var unencodedPubKey = keypair.getPublic().encode("hex", false);
-  return unencodedPubKey;
-};
-/**
- * PubKey performs the point-scalar multiplication from the privKey on the
- * generator point to get the pubkey.
- * @category crypto
- * @param {Buffer} privateKey
- * @return {Elliptic.PublicKey} PubKey
- * */
-
-
-exports.getPublicKeyFromPrivateKey = getPublicKeyFromPrivateKey;
-
-var generatePubKey = function generatePubKey(privateKey) {
-  var curve = new _elliptic.ec(CURVE);
-  var keypair = curve.keyFromPrivate(privateKey);
-  return keypair.getPublic();
-};
-/**
- * Gets an address from a public key hex.
- * @category crypto
- * @param {string} publicKeyHex the public key hexstring
- * @param {string} prefix the address prefix
- */
-
-
-exports.generatePubKey = generatePubKey;
-
-var getAddressFromPublicKey = function getAddressFromPublicKey(publicKeyHex, prefix) {
-  var pubKey = ec.keyFromPublic(publicKeyHex, "hex");
-  var pubPoint = pubKey.getPublic();
-  var compressed = pubPoint.encodeCompressed();
-  var hexed = (0, _utils.ab2hexstring)(compressed);
-  var hash = (0, _utils.sha256ripemd160)(hexed); // https://git.io/fAn8N
-
-  var address = encodeAddress(hash, prefix);
-  return address;
-};
-/**
- * Gets an address from a private key.
- * @category crypto
- * @param {string} privateKeyHex the private key hexstring
- * @param {string} prefix the address prefix
- */
-
-
-exports.getAddressFromPublicKey = getAddressFromPublicKey;
-
-var getAddressFromPrivateKey = function getAddressFromPrivateKey(privateKeyHex, prefix) {
-  return getAddressFromPublicKey(getPublicKeyFromPrivateKey(privateKeyHex), prefix);
-};
-/**
- * Generates a signature (64 byte <r,s>) for a transaction based on given private key.
- * @category crypto
- * @param {string} signBytesHex - Unsigned transaction sign bytes hexstring.
- * @param {string | Buffer} privateKey - The private key.
- * @return {Buffer} Signature. Does not include tx.
- */
-
-
-exports.getAddressFromPrivateKey = getAddressFromPrivateKey;
-
-var generateSignature = function generateSignature(signBytesHex, privateKey) {
-  var msgHash = (0, _utils.sha256)(signBytesHex);
-  var msgHashHex = Buffer.from(msgHash, "hex");
-
-  var signature = _tinySecp256k["default"].sign(msgHashHex, typeof privateKey === "string" ? Buffer.from(privateKey, "hex") : privateKey);
-
-  return signature;
-};
-/**
- * Verifies a signature (64 byte <r,s>) given the sign bytes and public key.
- * @category crypto
- * @param {string} sigHex - The signature hexstring.
- * @param {string} signBytesHex - Unsigned transaction sign bytes hexstring.
- * @param {string} publicKeyHex - The public key.
- * @return {boolean}
- */
-
-
-exports.generateSignature = generateSignature;
-
-var verifySignature = function verifySignature(sigHex, signBytesHex, publicKeyHex) {
-  var publicKey = Buffer.from(publicKeyHex, "hex");
-  if (!_tinySecp256k["default"].isPoint(publicKey)) throw new Error("Invalid public key provided");
-  var msgHash = (0, _utils.sha256)(signBytesHex);
-  var msgHashHex = Buffer.from(msgHash, "hex");
-  return _tinySecp256k["default"].verify(msgHashHex, publicKey, Buffer.from(sigHex, "hex"));
-};
-/**
- * Generates a keystore object (web3 secret storage format) given a private key to store and a password.
- * @category crypto
- * @param {string} privateKeyHex the private key hexstring.
- * @param {string} password the password.
- * @return {object} the keystore object.
- */
-
-
-exports.verifySignature = verifySignature;
-
-var generateKeyStore = function generateKeyStore(privateKeyHex, password) {
-  var salt = _cryptoBrowserify["default"].randomBytes(32);
-
-  var iv = _cryptoBrowserify["default"].randomBytes(16);
-
-  var cipherAlg = "aes-256-ctr";
-  var kdf = "pbkdf2";
-  var kdfparams = {
-    dklen: 32,
-    salt: salt.toString("hex"),
-    c: 262144,
-    prf: "hmac-sha256"
-  };
-
-  var derivedKey = _cryptoBrowserify["default"].pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, "sha256");
-
-  var cipher = _cryptoBrowserify["default"].createCipheriv(cipherAlg, derivedKey.slice(0, 32), iv);
-
-  if (!cipher) {
-    throw new Error("Unsupported cipher");
-  }
-
-  var ciphertext = Buffer.concat([cipher.update(Buffer.from(privateKeyHex, "hex")), cipher["final"]()]);
-  var bufferValue = Buffer.concat([derivedKey.slice(16, 32), ciphertext]);
-  return {
-    version: 1,
-    id: _uuid["default"].v4({
-      random: _cryptoBrowserify["default"].randomBytes(16)
-    }),
-    crypto: {
-      ciphertext: ciphertext.toString("hex"),
-      cipherparams: {
-        iv: iv.toString("hex")
-      },
-      cipher: cipherAlg,
-      kdf: kdf,
-      kdfparams: kdfparams,
-      // mac must use sha3 according to web3 secret storage spec
-      mac: (0, _utils.sha3)(bufferValue.toString("hex"))
-    }
-  };
-};
-/**
- * Gets a private key from a keystore given its password.
- * @category crypto
- * @param {string} keystore the keystore in json format
- * @param {string} password the password.
- */
-
-
-exports.generateKeyStore = generateKeyStore;
-
-var getPrivateKeyFromKeyStore = function getPrivateKeyFromKeyStore(keystore, password) {
-  if (!_is_js["default"].string(password)) {
-    throw new Error("No password given.");
-  }
-
-  var json = _is_js["default"].object(keystore) ? keystore : JSON.parse(keystore);
-  var kdfparams = json.crypto.kdfparams;
-
-  if (kdfparams.prf !== "hmac-sha256") {
-    throw new Error("Unsupported parameters to PBKDF2");
-  }
-
-  var derivedKey = _cryptoBrowserify["default"].pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, "hex"), kdfparams.c, kdfparams.dklen, "sha256");
-
-  var ciphertext = Buffer.from(json.crypto.ciphertext, "hex");
-  var bufferValue = Buffer.concat([derivedKey.slice(16, 32), ciphertext]); // try sha3 (new / ethereum keystore) mac first
-
-  var mac = (0, _utils.sha3)(bufferValue.toString("hex"));
-
-  if (mac !== json.crypto.mac) {
-    // the legacy (sha256) mac is next to be checked. pre-testnet keystores used a sha256 digest for the mac.
-    // the sha256 mac was not compatible with ethereum keystores, so it was changed to sha3 for mainnet.
-    var macLegacy = (0, _utils.sha256)(bufferValue.toString("hex"));
-
-    if (macLegacy !== json.crypto.mac) {
-      throw new Error("Keystore mac check failed (sha3 & sha256) - wrong password?");
-    }
-  }
-
-  var decipher = _cryptoBrowserify["default"].createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 32), Buffer.from(json.crypto.cipherparams.iv, "hex"));
-
-  var privateKey = Buffer.concat([decipher.update(ciphertext), decipher["final"]()]).toString("hex");
-  return privateKey;
-};
-/**
- * Generates mnemonic phrase words using random entropy.
- * @category crypto
- */
-
-
-exports.getPrivateKeyFromKeyStore = getPrivateKeyFromKeyStore;
-
-var generateMnemonic = function generateMnemonic() {
-  return bip39.generateMnemonic(MNEMONIC_LEN);
-};
-/**
- * Validates mnemonic phrase words.
- * @ignore
- * @param {string} mnemonic the mnemonic phrase words
- * @return {bool} validation result
- */
-
-
-exports.generateMnemonic = generateMnemonic;
-var validateMnemonic = bip39.validateMnemonic;
-/**
- * Get a private key from mnemonic words.
- * @category crypto
- * @param {string} mnemonic the mnemonic phrase words
- * @param {Boolean} derive derive a private key using the default HD path (default: true)
- * @param {number} index the bip44 address index (default: 0)
- * @param {string} password according to bip39
- * @return {string} hexstring
- */
-
-exports.validateMnemonic = validateMnemonic;
-
-var getPrivateKeyFromMnemonic = function getPrivateKeyFromMnemonic(mnemonic) {
-  var derive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
-  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
-  var password = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
-
-  if (!bip39.validateMnemonic(mnemonic, bip39.wordlists.english) && !bip39.validateMnemonic(mnemonic, bip39.wordlists.chinese_simplified) && !bip39.validateMnemonic(mnemonic, bip39.wordlists.chinese_traditional) && !bip39.validateMnemonic(mnemonic, bip39.wordlists.korean) && !bip39.validateMnemonic(mnemonic, bip39.wordlists.french) && !bip39.validateMnemonic(mnemonic, bip39.wordlists.italian) && !bip39.validateMnemonic(mnemonic, bip39.wordlists.spanish) && !bip39.validateMnemonic(mnemonic, bip39.wordlists.japanese)) {
-    throw new Error("wrong mnemonic format");
-  }
-
-  var seed = bip39.mnemonicToSeedSync(mnemonic, password);
-
-  if (derive) {
-    var master = bip32.fromSeed(seed);
-    var child = master.derivePath(HDPATH + index);
-
-    if (!child.privateKey) {
-      throw new Error("child does not have a privateKey");
-    }
-
-    return child.privateKey.toString("hex");
-  }
-
-  return seed.toString("hex");
-};
-
-exports.getPrivateKeyFromMnemonic = getPrivateKeyFromMnemonic;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/declarations.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/declarations.d.ts
deleted file mode 100644
index c5cdbee..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/declarations.d.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-/// <reference types="node" />
-declare module "is_js" {
-    const boolean: (a: any) => a is boolean;
-    const number: (a: any) => a is number;
-    const integer: (a: any) => a is number;
-    const string: (a: any) => a is string;
-    const array: (a: any) => a is Array<any>;
-    const object: (a: any) => a is object;
-}
-declare module "secure-random" {
-    const csprng: (lenght: number) => ArrayBuffer;
-    export default csprng;
-}
-declare module "crypto-browserify" {
-    import _crypto from "crypto";
-    const crypto: Pick<typeof _crypto, "createHash" | "createHmac" | "pbkdf2" | "pbkdf2Sync" | "randomBytes" | "pseudoRandomBytes" | "createCipher" | "createDecipher" | "createDiffieHellman" | "createSign" | "createVerify" | "createECDH" | "publicEncrypt" | "privateDecrypt" | "privateEncrypt" | "publicDecrypt" | "createCipheriv" | "createDecipheriv">;
-    export default crypto;
-}
-declare module "protocol-buffers-encodings" {
-    namespace string {
-        const encode: (val: any, buffer: Buffer, offset?: number) => Buffer;
-        const decode: (buf: Buffer | number[], offset?: number) => any;
-        const encodingLength: (val: any) => number;
-    }
-    namespace bytes {
-        const encode: (val: any, buffer: Buffer, offset?: number) => Buffer;
-        const decode: (buf: Buffer | number[], offset?: number) => any;
-        const encodingLength: (val: any) => number;
-    }
-    namespace bool {
-        const encode: (val: any, buffer: Buffer, offset?: number) => Buffer;
-        const decode: (buf: Buffer | number[], offset?: number) => any;
-        const encodingLength: (val: any) => number;
-    }
-    namespace varint {
-        const encode: (val: any, buffer: Buffer, offset?: number) => Buffer;
-        const decode: (buf: Buffer | number[], offset?: number) => any;
-        const encodingLength: (val: any) => number;
-    }
-}
-declare module "ndjson" {
-    import { Stream } from "stream";
-    const wat: {
-        stringify: () => Stream;
-    };
-    export default wat;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/declarations.js b/node_modules/@binance-chain/javascript-sdk/lib/declarations.js
deleted file mode 100644
index 9a390c3..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/declarations.js
+++ /dev/null
@@ -1 +0,0 @@
-"use strict";
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/index.d.ts
deleted file mode 100644
index 1583c6c..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/index.d.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import "./declarations";
-import * as amino from "./amino";
-import { BncClient } from "./client";
-import * as crypto from "./crypto";
-import * as types from "./types";
-import * as utils from "./utils";
-export { default as ledger } from "./ledger";
-export { default as rpc } from "./rpc";
-export { default as Transaction } from "./tx";
-export { BncClient, crypto, amino, types, utils };
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/index.js b/node_modules/@binance-chain/javascript-sdk/lib/index.js
index 3872d58..bf6a4ae 100644
--- a/node_modules/@binance-chain/javascript-sdk/lib/index.js
+++ b/node_modules/@binance-chain/javascript-sdk/lib/index.js
@@ -1,60 +1 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-Object.defineProperty(exports, "BncClient", {
-  enumerable: true,
-  get: function get() {
-    return _client.BncClient;
-  }
-});
-Object.defineProperty(exports, "ledger", {
-  enumerable: true,
-  get: function get() {
-    return _ledger["default"];
-  }
-});
-Object.defineProperty(exports, "rpc", {
-  enumerable: true,
-  get: function get() {
-    return _rpc["default"];
-  }
-});
-Object.defineProperty(exports, "Transaction", {
-  enumerable: true,
-  get: function get() {
-    return _tx["default"];
-  }
-});
-exports.utils = exports.types = exports.crypto = exports.amino = void 0;
-
-require("./declarations");
-
-var amino = _interopRequireWildcard(require("./amino"));
-
-exports.amino = amino;
-
-var _client = require("./client");
-
-var crypto = _interopRequireWildcard(require("./crypto"));
-
-exports.crypto = crypto;
-
-var types = _interopRequireWildcard(require("./types"));
-
-exports.types = types;
-
-var utils = _interopRequireWildcard(require("./utils"));
-
-exports.utils = utils;
-
-var _ledger = _interopRequireDefault(require("./ledger"));
-
-var _rpc = _interopRequireDefault(require("./rpc"));
-
-var _tx = _interopRequireDefault(require("./tx"));
\ No newline at end of file
+export * from '../src'
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/ledger/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/ledger/index.d.ts
deleted file mode 100644
index 00fd8e7..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/ledger/index.d.ts
+++ /dev/null
@@ -1,2 +0,0 @@
-declare const Ledger: any;
-export default Ledger;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/ledger/index.js b/node_modules/@binance-chain/javascript-sdk/lib/ledger/index.js
deleted file mode 100644
index 8b4f334..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/ledger/index.js
+++ /dev/null
@@ -1,54 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-
-var _ledgerApp = _interopRequireDefault(require("./ledger-app"));
-
-/********************************************************************************
- *   Binance Chain Ledger App Interface
- *   (c) 2018-2019 Binance
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- ********************************************************************************/
-
-/* eslint-disable*/
-// intentionally ambiguous to confuse webpack (we don't need this in web builds)
-var LEDGER_NODE_HID_TRANSPORT_MODULE = "@ledgerhq/hw-transport-node-hid";
-var isBrowser = typeof window !== "undefined"; // const Ledger  = module.exports
-
-var Ledger = {
-  app: _ledgerApp["default"],
-  LedgerApp: _ledgerApp["default"],
-  transports: {
-    u2f: require("@ledgerhq/hw-transport-u2f")["default"],
-    wble: require("@ledgerhq/hw-transport-web-ble")["default"],
-    // requiring the node transport in the browser causes a bit of an issue with webpack! this is a conditional require
-    node: !isBrowser && moduleExists(LEDGER_NODE_HID_TRANSPORT_MODULE) ? require(LEDGER_NODE_HID_TRANSPORT_MODULE)["default"] : null
-  }
-};
-module.exports = Ledger;
-var _default = Ledger;
-exports["default"] = _default;
-
-function moduleExists(name) {
-  try {
-    return require.resolve(name);
-  } catch (e) {
-    return false;
-  }
-}
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/ledger/ledger-app.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/ledger/ledger-app.d.ts
deleted file mode 100644
index b4adfaa..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/ledger/ledger-app.d.ts
+++ /dev/null
@@ -1,105 +0,0 @@
-/********************************************************************************
- *   Binance Chain Ledger App Interface
- *   (c) 2018-2019 Binance
- *   (c) 2018 ZondaX GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *******************************************************************************
- */
-/// <reference types="node" />
-/// <reference types="ledgerhq__hw-transport" />
-import Transport from "@ledgerhq/hw-transport";
-export interface Version {
-    test_mode?: boolean;
-    major?: number;
-    minor?: number;
-    patch?: number;
-    device_locked?: boolean;
-    return_code?: number;
-    error_message?: string;
-}
-export interface PublicKey {
-    pk?: Buffer;
-    return_code?: number;
-    error_message?: string;
-}
-export interface SignedSignature {
-    return_code?: number;
-    error_message?: string;
-    signature?: Buffer | null;
-}
-export interface ReturnResponse {
-    return_code?: number;
-    error_message?: string;
-}
-/**
- * Ledger app interface.
- * @static
- */
-declare class LedgerApp {
-    private _transport;
-    private _interactiveTimeout;
-    private _nonInteractiveTimeout;
-    /**
-     * Constructs a new LedgerApp.
-     * @param {Transport} transport Ledger Transport, a subclass of ledgerjs Transport.
-     * @param {Number} interactiveTimeout The interactive (user input) timeout in ms. Default 45s.
-     * @param {Number} nonInteractiveTimeout The non-interactive timeout in ms. Default 3s.
-     */
-    constructor(transport: Transport, interactiveTimeout?: number, nonInteractiveTimeout?: number);
-    _serialize(cla: number | undefined, ins: number, p1?: number, p2?: number, data?: any): Buffer;
-    _serializeHRP(hrp: string): Buffer;
-    _serializeHDPath(path: number[]): Buffer;
-    _errorMessage(code: number): "U2F: Unknown" | "U2F: Bad request" | "U2F: Configuration unsupported" | "U2F: Device Ineligible" | "U2F: Timeout" | "Timeout" | "No errors" | "Device is busy" | "Execution Error" | "Wrong Length" | "Empty Buffer" | "Output buffer too small" | "Data is invalid" | "Conditions not satisfied" | "Transaction rejected" | "Bad key handle" | "Invalid P1/P2" | "Instruction not supported" | "The app does not seem to be open" | "Unknown error" | "Sign/verify error" | "Unknown error code";
-    /**
-     * Gets the version of the Ledger app that is currently open on the device.
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-    getVersion(): Promise<Version>;
-    /**
-     * Gets the public key from the Ledger app that is currently open on the device.
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-    publicKeySecp256k1(hdPath?: number[]): Promise<PublicKey>;
-    _signGetChunks(data: any, hdPath: number[]): Buffer[];
-    _signSendChunk(chunkIdx: any, chunksCount: any, chunk: any): Promise<SignedSignature>;
-    /**
-     * Sends a transaction sign doc to the Ledger app to be signed.
-     * @param {Buffer} signBytes The TX sign doc bytes to sign
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-    signSecp256k1(signBytes: Buffer, hdPath?: number[]): Promise<SignedSignature>;
-    /**
-     * Shows the user's address for the given HD path on the device display.
-     * @param {string} hrp The bech32 human-readable prefix
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-    showAddress(hrp?: string, hdPath?: number[]): Promise<ReturnResponse>;
-    /**
-     * Gets the public key from the Ledger app that is currently open on the device.
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-    getPublicKey(hdPath: number[]): Promise<PublicKey>;
-    /**
-     * Sends a transaction sign doc to the Ledger app to be signed.
-     * @param {Buffer} signBytes The TX sign doc bytes to sign
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-    sign(signBytes: Buffer, hdPath: number[]): Promise<SignedSignature>;
-}
-export default LedgerApp;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/ledger/ledger-app.js b/node_modules/@binance-chain/javascript-sdk/lib/ledger/ledger-app.js
deleted file mode 100644
index d2700ed..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/ledger/ledger-app.js
+++ /dev/null
@@ -1,849 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-/* eslint-disable */
-
-/********************************************************************************
- *   Binance Chain Ledger App Interface
- *   (c) 2018-2019 Binance
- *   (c) 2018 ZondaX GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *******************************************************************************
- */
-var DEFAULT_LEDGER_INTERACTIVE_TIMEOUT = 50000;
-var DEFAULT_LEDGER_NONINTERACTIVE_TIMEOUT = 3000;
-var CLA = 0xbc;
-var SCRAMBLE_KEY = "CSM";
-var ACCEPT_STATUSES = [0x9000]; // throw if not
-
-var CHUNK_SIZE = 250;
-var INS_GET_VERSION = 0x00;
-var INS_PUBLIC_KEY_SECP256K1 = 0x01;
-var INS_SIGN_SECP256K1 = 0x02;
-var INS_SHOW_ADDR_SECP256K1 = 0x03; // const INS_GET_ADDR_SECP256K1 = 0x04
-
-// The general structure of commands and responses is as follows:
-// #### Commands
-// | Field   | Type     | Content                | Note |
-// |:------- |:-------- |:---------------------- | ---- |
-// | CLA     | byte (1) | Application Identifier | 0xBC |
-// | INS     | byte (1) | Instruction ID         |      |
-// | P1      | byte (1) | Parameter 1            |      |
-// | P2      | byte (1) | Parameter 2            |      |
-// | L       | byte (1) | Bytes in payload       |      |
-// | PAYLOAD | byte (L) | Payload                |      |
-// #### Response
-// | Field   | Type     | Content     | Note                     |
-// | ------- | -------- | ----------- | ------------------------ |
-// | ANSWER  | byte (?) | Answer      | depends on the command   |
-// | SW1-SW2 | byte (2) | Return code | see list of return codes |
-
-/**
- * Ledger app interface.
- * @static
- */
-var LedgerApp = /*#__PURE__*/function () {
-  /**
-   * Constructs a new LedgerApp.
-   * @param {Transport} transport Ledger Transport, a subclass of ledgerjs Transport.
-   * @param {Number} interactiveTimeout The interactive (user input) timeout in ms. Default 45s.
-   * @param {Number} nonInteractiveTimeout The non-interactive timeout in ms. Default 3s.
-   */
-  function LedgerApp(transport) {
-    var interactiveTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LEDGER_INTERACTIVE_TIMEOUT;
-    var nonInteractiveTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_LEDGER_NONINTERACTIVE_TIMEOUT;
-    (0, _classCallCheck2["default"])(this, LedgerApp);
-    (0, _defineProperty2["default"])(this, "_transport", void 0);
-    (0, _defineProperty2["default"])(this, "_interactiveTimeout", void 0);
-    (0, _defineProperty2["default"])(this, "_nonInteractiveTimeout", void 0);
-
-    if (!transport || !transport.send) {
-      throw new Error("LedgerApp expected a Transport");
-    }
-
-    this._transport = transport;
-    this._interactiveTimeout = interactiveTimeout;
-    this._nonInteractiveTimeout = nonInteractiveTimeout;
-
-    this._transport.setScrambleKey(SCRAMBLE_KEY);
-  }
-
-  (0, _createClass2["default"])(LedgerApp, [{
-    key: "_serialize",
-    value: function _serialize() {
-      var cla = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CLA;
-      var ins = arguments.length > 1 ? arguments[1] : undefined;
-      var p1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
-      var p2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
-      var data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
-      var size = 5;
-
-      if (data != null) {
-        if (data.length > 255) {
-          throw new Error("maximum data size = 255");
-        }
-
-        size += data.length;
-      }
-
-      var buffer = Buffer.alloc(size);
-      buffer[0] = cla;
-      buffer[1] = ins;
-      buffer[2] = p1;
-      buffer[3] = p2;
-      buffer[4] = 0;
-
-      if (data != null) {
-        buffer[4] = data.length;
-        buffer.set(data, 5);
-      }
-
-      return buffer;
-    }
-  }, {
-    key: "_serializeHRP",
-    value: function _serializeHRP(hrp) {
-      if (hrp == null || hrp.length < 3 || hrp.length > 83) {
-        throw new Error("Invalid HRP");
-      }
-
-      var buf = Buffer.alloc(1 + hrp.length);
-      buf.writeUInt8(hrp.length, 0);
-      buf.write(hrp, 1);
-      return buf;
-    }
-  }, {
-    key: "_serializeHDPath",
-    value: function _serializeHDPath(path) {
-      if (path == null || path.length < 3) {
-        throw new Error("Invalid path.");
-      }
-
-      if (path.length > 10) {
-        throw new Error("Invalid path. Length should be <= 10");
-      }
-
-      var buf = Buffer.alloc(1 + 4 * path.length);
-      buf.writeUInt8(path.length, 0);
-
-      for (var i = 0; i < path.length; i++) {
-        var v = path[i];
-
-        if (i < 3) {
-          v |= 0x80000000; // Harden
-        }
-
-        buf.writeInt32LE(v, 1 + i * 4);
-      }
-
-      return buf;
-    }
-  }, {
-    key: "_errorMessage",
-    value: function _errorMessage(code) {
-      switch (code) {
-        case 1:
-          return "U2F: Unknown";
-
-        case 2:
-          return "U2F: Bad request";
-
-        case 3:
-          return "U2F: Configuration unsupported";
-
-        case 4:
-          return "U2F: Device Ineligible";
-
-        case 5:
-          return "U2F: Timeout";
-
-        case 14:
-          return "Timeout";
-
-        case 0x9000:
-          return "No errors";
-
-        case 0x9001:
-          return "Device is busy";
-
-        case 0x6400:
-          return "Execution Error";
-
-        case 0x6700:
-          return "Wrong Length";
-
-        case 0x6982:
-          return "Empty Buffer";
-
-        case 0x6983:
-          return "Output buffer too small";
-
-        case 0x6984:
-          return "Data is invalid";
-
-        case 0x6985:
-          return "Conditions not satisfied";
-
-        case 0x6986:
-          return "Transaction rejected";
-
-        case 0x6a80:
-          return "Bad key handle";
-
-        case 0x6b00:
-          return "Invalid P1/P2";
-
-        case 0x6d00:
-          return "Instruction not supported";
-
-        case 0x6e00:
-          return "The app does not seem to be open";
-
-        case 0x6f00:
-          return "Unknown error";
-
-        case 0x6f01:
-          return "Sign/verify error";
-
-        default:
-          return "Unknown error code";
-      }
-    }
-    /* GET_VERSION */
-    // #### Payload
-    // | Field | Type     | Content                | Expected |
-    // | ----- | -------- | ---------------------- | -------- |
-    // | CLA   | byte (1) | Application Identifier | 0xBC     |
-    // | INS   | byte (1) | Instruction ID         | 0x00     |
-    // | P1    | byte (1) | Parameter 1            | ignored  |
-    // | P2    | byte (1) | Parameter 2            | ignored  |
-    // | L     | byte (1) | Bytes in payload       | 0        |
-    // #### Response
-    // | Field   | Type     | Content       | Note                            |
-    // | ------- | -------- | ------------- | ------------------------------- |
-    // | CLA     | byte (1) | Test Mode     | 0xFF means test mode is enabled |
-    // | MAJOR   | byte (1) | Version Major |                                 |
-    // | MINOR   | byte (1) | Version Minor |                                 |
-    // | PATCH   | byte (1) | Version Patch |                                 |
-    // | LOCKED  | byte (1) | Device Locked | boolean                         |
-    // | SW1-SW2 | byte (2) | Return code   | see list of return codes        |
-
-    /**
-     * Gets the version of the Ledger app that is currently open on the device.
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-
-  }, {
-    key: "getVersion",
-    value: function () {
-      var _getVersion = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
-        var result, apduResponse, returnCode, statusCode, statusText, message, stack;
-        return _regenerator["default"].wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                result = {};
-                _context.prev = 1;
-
-                this._transport.setExchangeTimeout(this._nonInteractiveTimeout);
-
-                _context.next = 5;
-                return this._transport.send(CLA, INS_GET_VERSION, 0, 0, Buffer.alloc(0), ACCEPT_STATUSES);
-
-              case 5:
-                apduResponse = _context.sent;
-
-                if (Buffer.isBuffer(apduResponse)) {
-                  _context.next = 8;
-                  break;
-                }
-
-                throw new Error("expected apduResponse to be Buffer");
-
-              case 8:
-                returnCode = apduResponse.slice(-2);
-                result["test_mode"] = apduResponse[0] !== 0;
-                result["major"] = apduResponse[1];
-                result["minor"] = apduResponse[2];
-                result["patch"] = apduResponse[3];
-                result["device_locked"] = apduResponse[4] === 1;
-                result["return_code"] = returnCode[0] * 256 + returnCode[1];
-                result["error_message"] = this._errorMessage(result["return_code"]);
-                _context.next = 23;
-                break;
-
-              case 18:
-                _context.prev = 18;
-                _context.t0 = _context["catch"](1);
-                statusCode = _context.t0.statusCode, statusText = _context.t0.statusText, message = _context.t0.message, stack = _context.t0.stack;
-                console.warn("Ledger getVersion error:", this._errorMessage(statusCode), message, statusText, stack);
-                throw _context.t0;
-
-              case 23:
-                return _context.abrupt("return", result);
-
-              case 24:
-              case "end":
-                return _context.stop();
-            }
-          }
-        }, _callee, this, [[1, 18]]);
-      }));
-
-      function getVersion() {
-        return _getVersion.apply(this, arguments);
-      }
-
-      return getVersion;
-    }()
-    /* PUBLIC_KEY_SECP256K1 */
-    // #### Payload
-    // | Field | Type     | Content                 | Expected |
-    // | ----- | -------- | ----------------------  | -------- |
-    // | CLA   | byte (1) | Application Identifier  | 0xBC     |
-    // | INS   | byte (1) | Instruction ID          | 0x01     |
-    // | P1    | byte (1) | Parameter 1             | ignored  |
-    // | P2    | byte (1) | Parameter 2             | ignored  |
-    // | L     | byte (1) | Bytes in payload        | (depends) |
-    // | PL    | byte (1) | Derivation Path Length  | 3<=PL<=10 |
-    // | Path[0] | byte (4) | Derivation Path Data    | 44 |
-    // | Path[1] | byte (4) | Derivation Path Data    | 118 |
-    // | ..  | byte (4) | Derivation Path Data    |  |
-    // | Path[PL-1]  | byte (4) | Derivation Path Data    |  |
-    // First three items in the derivation path will be hardened automatically hardened
-    // #### Response
-    // | Field   | Type      | Content       | Note                            |
-    // | ------- | --------- | ------------- | ------------------------------- |
-    // | PK      | byte (65) | Public Key    |  |
-    // | SW1-SW2 | byte (2)  | Return code   | see list of return codes        |
-
-    /**
-     * Gets the public key from the Ledger app that is currently open on the device.
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-
-  }, {
-    key: "publicKeySecp256k1",
-    value: function () {
-      var _publicKeySecp256k = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
-        var hdPath,
-            result,
-            apduResponse,
-            returnCode,
-            statusCode,
-            statusText,
-            message,
-            stack,
-            _args2 = arguments;
-        return _regenerator["default"].wrap(function _callee2$(_context2) {
-          while (1) {
-            switch (_context2.prev = _context2.next) {
-              case 0:
-                hdPath = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [44, 714, 0, 0, 0];
-                result = {};
-                _context2.prev = 2;
-
-                this._transport.setExchangeTimeout(this._nonInteractiveTimeout);
-
-                _context2.next = 6;
-                return this._transport.send(CLA, INS_PUBLIC_KEY_SECP256K1, 0, 0, this._serializeHDPath(hdPath), ACCEPT_STATUSES);
-
-              case 6:
-                apduResponse = _context2.sent;
-
-                if (Buffer.isBuffer(apduResponse)) {
-                  _context2.next = 9;
-                  break;
-                }
-
-                throw new Error("expected apduResponse to be Buffer");
-
-              case 9:
-                returnCode = apduResponse.slice(-2);
-                result["pk"] = apduResponse.slice(0, 1 + 64);
-                result["return_code"] = returnCode[0] * 256 + returnCode[1];
-                result["error_message"] = this._errorMessage(result["return_code"]);
-                _context2.next = 20;
-                break;
-
-              case 15:
-                _context2.prev = 15;
-                _context2.t0 = _context2["catch"](2);
-                statusCode = _context2.t0.statusCode, statusText = _context2.t0.statusText, message = _context2.t0.message, stack = _context2.t0.stack;
-                console.warn("Ledger publicKeySecp256k1 error:", this._errorMessage(statusCode), message, statusText, stack);
-                throw _context2.t0;
-
-              case 20:
-                return _context2.abrupt("return", result);
-
-              case 21:
-              case "end":
-                return _context2.stop();
-            }
-          }
-        }, _callee2, this, [[2, 15]]);
-      }));
-
-      function publicKeySecp256k1() {
-        return _publicKeySecp256k.apply(this, arguments);
-      }
-
-      return publicKeySecp256k1;
-    }()
-    /* SIGN_SECP256K1 */
-    // #### Payload
-    // | Field | Type     | Content                | Expected |
-    // | ----- | -------- | ---------------------- | -------- |
-    // | CLA   | byte (1) | Application Identifier | 0xBC     |
-    // | INS   | byte (1) | Instruction ID         | 0x02     |
-    // | P1    | byte (1) | Packet Current Index   |   |
-    // | P2    | byte (1) | Packet Total Count     |
-    //   |
-    // | L     | byte (1) | Bytes in payload       | (depends)        |
-    // The first packet/chunk includes only the derivation path
-    // All other packets/chunks should contain message to sign
-    // *First Packet*
-    // | Field | Type     | Content                | Expected |
-    // | ----- | -------- | ---------------------- | -------- |
-    // | PL    | byte (1) | Derivation Path Length  | 3<=PL<=10 |
-    // | Path[0] | byte (4) | Derivation Path Data    | 44 |
-    // | Path[1] | byte (4) | Derivation Path Data    | 118 |
-    // | ..  | byte (4) | Derivation Path Data    |  |
-    // | Path[PL-1]  | byte (4) | Derivation Path Data    |  |
-    // | Message | bytes... | Message to Sign | |
-    // *Other Chunks/Packets*
-    // | Field | Type     | Content                | Expected |
-    // | ----- | -------- | ---------------------- | -------- |
-    // | Message | bytes... | Message to Sign | |
-    // #### Response
-    // | Field   | Type      | Content       | Note                            |
-    // | ------- | --------- | ------------- | ------------------------------- |
-    // | SIG     | byte (~71) | Signature     | DER encoded (length prefixed parts) |
-    // | SW1-SW2 | byte (2)  | Return code   | see list of return codes        |
-
-  }, {
-    key: "_signGetChunks",
-    value: function _signGetChunks(data, hdPath) {
-      var chunks = [];
-      chunks.push(this._serializeHDPath(hdPath));
-      var buffer = Buffer.from(data);
-
-      for (var i = 0; i < buffer.length; i += CHUNK_SIZE) {
-        var end = i + CHUNK_SIZE;
-
-        if (i > buffer.length) {
-          end = buffer.length;
-        }
-
-        chunks.push(buffer.slice(i, end));
-      }
-
-      return chunks;
-    }
-  }, {
-    key: "_signSendChunk",
-    value: function () {
-      var _signSendChunk2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(chunkIdx, chunksCount, chunk) {
-        var result, apduResponse, returnCode, statusCode, statusText, message, stack;
-        return _regenerator["default"].wrap(function _callee3$(_context3) {
-          while (1) {
-            switch (_context3.prev = _context3.next) {
-              case 0:
-                result = {};
-                _context3.prev = 1;
-                _context3.next = 4;
-                return this._transport.send(CLA, INS_SIGN_SECP256K1, chunkIdx, chunksCount, chunk);
-
-              case 4:
-                apduResponse = _context3.sent;
-
-                if (Buffer.isBuffer(apduResponse)) {
-                  _context3.next = 7;
-                  break;
-                }
-
-                throw new Error("expected apduResponse to be Buffer");
-
-              case 7:
-                returnCode = apduResponse.slice(-2);
-                result["return_code"] = returnCode[0] * 256 + returnCode[1];
-                result["error_message"] = this._errorMessage(result["return_code"]);
-                result["signature"] = null;
-
-                if (apduResponse.length > 2) {
-                  result["signature"] = apduResponse.slice(0, apduResponse.length - 2);
-                }
-
-                _context3.next = 19;
-                break;
-
-              case 14:
-                _context3.prev = 14;
-                _context3.t0 = _context3["catch"](1);
-                statusCode = _context3.t0.statusCode, statusText = _context3.t0.statusText, message = _context3.t0.message, stack = _context3.t0.stack;
-                console.warn("Ledger signSendChunk error:", this._errorMessage(statusCode), message, statusText, stack);
-                throw _context3.t0;
-
-              case 19:
-                return _context3.abrupt("return", result);
-
-              case 20:
-              case "end":
-                return _context3.stop();
-            }
-          }
-        }, _callee3, this, [[1, 14]]);
-      }));
-
-      function _signSendChunk(_x, _x2, _x3) {
-        return _signSendChunk2.apply(this, arguments);
-      }
-
-      return _signSendChunk;
-    }()
-    /**
-     * Sends a transaction sign doc to the Ledger app to be signed.
-     * @param {Buffer} signBytes The TX sign doc bytes to sign
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-
-  }, {
-    key: "signSecp256k1",
-    value: function () {
-      var _signSecp256k = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(signBytes) {
-        var hdPath,
-            result,
-            chunks,
-            response,
-            statusCode,
-            statusText,
-            message,
-            stack,
-            i,
-            _statusCode,
-            _statusText,
-            _message,
-            _stack,
-            signature,
-            rOffset,
-            rLen,
-            sLen,
-            sOffset,
-            sigR,
-            sigS,
-            _args4 = arguments;
-
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                hdPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : [44, 714, 0, 0, 0];
-                result = {};
-                chunks = this._signGetChunks(signBytes, hdPath); // _signSendChunk doesn't throw, it catches exceptions itself. no need for try/catch
-
-                _context4.prev = 3;
-
-                if (chunks.length <= 1) {
-                  this._transport.setExchangeTimeout(this._interactiveTimeout);
-                } else {
-                  // more to come, non-interactive
-                  this._transport.setExchangeTimeout(this._nonInteractiveTimeout);
-                }
-
-                _context4.next = 7;
-                return this._signSendChunk(1, chunks.length, chunks[0]);
-
-              case 7:
-                response = _context4.sent;
-                result["return_code"] = response.return_code;
-                result["error_message"] = response.error_message;
-                result["signature"] = null;
-                _context4.next = 18;
-                break;
-
-              case 13:
-                _context4.prev = 13;
-                _context4.t0 = _context4["catch"](3);
-                statusCode = _context4.t0.statusCode, statusText = _context4.t0.statusText, message = _context4.t0.message, stack = _context4.t0.stack;
-                console.warn("Ledger signSecp256k1 error (chunk 1):", this._errorMessage(statusCode), message, statusText, stack);
-                throw _context4.t0;
-
-              case 18:
-                if (!(response.return_code === 0x9000)) {
-                  _context4.next = 60;
-                  break;
-                }
-
-                i = 1;
-
-              case 20:
-                if (!(i < chunks.length)) {
-                  _context4.next = 40;
-                  break;
-                }
-
-                _context4.prev = 21;
-
-                if (i === chunks.length - 1) {
-                  // last?
-                  this._transport.setExchangeTimeout(this._interactiveTimeout);
-                }
-
-                _context4.next = 25;
-                return this._signSendChunk(1 + i, chunks.length, chunks[i]);
-
-              case 25:
-                response = _context4.sent;
-                result["return_code"] = response.return_code;
-                result["error_message"] = response.error_message;
-                _context4.next = 35;
-                break;
-
-              case 30:
-                _context4.prev = 30;
-                _context4.t1 = _context4["catch"](21);
-                _statusCode = _context4.t1.statusCode, _statusText = _context4.t1.statusText, _message = _context4.t1.message, _stack = _context4.t1.stack;
-                console.warn("Ledger signSecp256k1 error (chunk 2):", this._errorMessage(_statusCode), _message, _statusText, _stack);
-                throw _context4.t1;
-
-              case 35:
-                if (!(response.return_code !== 0x9000)) {
-                  _context4.next = 37;
-                  break;
-                }
-
-                return _context4.abrupt("break", 40);
-
-              case 37:
-                i++;
-                _context4.next = 20;
-                break;
-
-              case 40:
-                result["return_code"] = response.return_code;
-                result["error_message"] = response.error_message; // Ledger has encoded the sig in ASN1 DER format, but we need a 64-byte buffer of <r,s>
-                // DER-encoded signature from Ledger:
-                // 0 0x30: a header byte indicating a compound structure
-                // 1 A 1-byte length descriptor for all what follows (ignore)
-                // 2 0x02: a header byte indicating an integer
-                // 3 A 1-byte length descriptor for the R value
-                // 4 The R coordinate, as a big-endian integer
-                //   0x02: a header byte indicating an integer
-                //   A 1-byte length descriptor for the S value
-                //   The S coordinate, as a big-endian integer
-                //  = 7 bytes of overhead
-
-                signature = response.signature;
-
-                if (!(!signature || !signature.length)) {
-                  _context4.next = 45;
-                  break;
-                }
-
-                throw new Error("Ledger assertion failed: Expected a non-empty signature from the device");
-
-              case 45:
-                if (!(signature[0] !== 0x30)) {
-                  _context4.next = 47;
-                  break;
-                }
-
-                throw new Error("Ledger assertion failed: Expected a signature header of 0x30");
-
-              case 47:
-                // decode DER string format
-                rOffset = 4;
-                rLen = signature[3];
-                sLen = signature[4 + rLen + 1]; // skip over following 0x02 type prefix for s
-
-                sOffset = signature.length - sLen; // we can safely ignore the first byte in the 33 bytes cases
-
-                if (rLen === 33) {
-                  rOffset++; // chop off 0x00 padding
-
-                  rLen--;
-                }
-
-                if (sLen === 33) sOffset++; // as above
-
-                sigR = signature.slice(rOffset, rOffset + rLen); // skip e.g. 3045022100 and pad
-
-                sigS = signature.slice(sOffset);
-                signature = result["signature"] = Buffer.concat([sigR, sigS]);
-
-                if (!(signature.length !== 64)) {
-                  _context4.next = 58;
-                  break;
-                }
-
-                throw new Error("Ledger assertion failed: incorrect signature length ".concat(signature.length));
-
-              case 58:
-                _context4.next = 61;
-                break;
-
-              case 60:
-                throw new Error("Unable to sign the transaction. Return code " + response.return_code);
-
-              case 61:
-                return _context4.abrupt("return", result);
-
-              case 62:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this, [[3, 13], [21, 30]]);
-      }));
-
-      function signSecp256k1(_x4) {
-        return _signSecp256k.apply(this, arguments);
-      }
-
-      return signSecp256k1;
-    }()
-    /* INS_SHOW_ADDR_SECP256K1 */
-    // #### Command
-    // | Field      | Type           | Content                | Expected       |
-    // | ---------- | -------------- | ---------------------- | -------------- |
-    // | CLA        | byte (1)       | Application Identifier | 0xBC           |
-    // | INS        | byte (1)       | Instruction ID         | 0x03           |
-    // | P1         | byte (1)       | Parameter 1            | ignored        |
-    // | P2         | byte (1)       | Parameter 2            | ignored        |
-    // | L          | byte (1)       | Bytes in payload       | (depends)      |
-    // | HRP_LEN    | byte(1)        | Bech32 HRP Length      | 1<=HRP_LEN<=83 |
-    // | HRP        | byte (HRP_LEN) | Bech32 HRP             |                |
-    // | PL         | byte (1)       | Derivation Path Length | 3<=PL<=5       |
-    // | Path[0]    | byte (4)       | Derivation Path Data   | 44             |
-    // | Path[1]    | byte (4)       | Derivation Path Data   | 714            |
-    // | ..         | byte (4)       | Derivation Path Data   |                |
-    // | Path[PL-1] | byte (4)       | Derivation Path Data   |                |
-    // First three items in the derivation path will be automatically hardened
-
-    /**
-     * Shows the user's address for the given HD path on the device display.
-     * @param {string} hrp The bech32 human-readable prefix
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-
-  }, {
-    key: "showAddress",
-    value: function () {
-      var _showAddress = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
-        var hrp,
-            hdPath,
-            result,
-            data,
-            apduResponse,
-            returnCode,
-            _args5 = arguments;
-        return _regenerator["default"].wrap(function _callee5$(_context5) {
-          while (1) {
-            switch (_context5.prev = _context5.next) {
-              case 0:
-                hrp = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : "bnb";
-                hdPath = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : [44, 714, 0, 0, 0];
-                result = {};
-                data = Buffer.concat([this._serializeHRP(hrp), this._serializeHDPath(hdPath)]);
-
-                this._transport.setExchangeTimeout(this._interactiveTimeout);
-
-                _context5.next = 7;
-                return this._transport.send(CLA, INS_SHOW_ADDR_SECP256K1, 0, 0, data, ACCEPT_STATUSES);
-
-              case 7:
-                apduResponse = _context5.sent;
-
-                if (Buffer.isBuffer(apduResponse)) {
-                  _context5.next = 10;
-                  break;
-                }
-
-                throw new Error("expected apduResponse to be Buffer");
-
-              case 10:
-                returnCode = apduResponse.slice(-2);
-                result["return_code"] = returnCode[0] * 256 + returnCode[1];
-                result["error_message"] = this._errorMessage(result["return_code"]);
-
-                if (result.return_code === 0x6a80) {
-                  result["error_message"] = apduResponse.slice(0, apduResponse.length - 2).toString("ascii");
-                }
-
-                return _context5.abrupt("return", result);
-
-              case 15:
-              case "end":
-                return _context5.stop();
-            }
-          }
-        }, _callee5, this);
-      }));
-
-      function showAddress() {
-        return _showAddress.apply(this, arguments);
-      }
-
-      return showAddress;
-    }() // convenience aliases
-
-    /**
-     * Gets the public key from the Ledger app that is currently open on the device.
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-
-  }, {
-    key: "getPublicKey",
-    value: function getPublicKey(hdPath) {
-      return this.publicKeySecp256k1(hdPath);
-    }
-    /**
-     * Sends a transaction sign doc to the Ledger app to be signed.
-     * @param {Buffer} signBytes The TX sign doc bytes to sign
-     * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
-     * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
-     */
-
-  }, {
-    key: "sign",
-    value: function sign(signBytes, hdPath) {
-      return this.signSecp256k1(signBytes, hdPath);
-    }
-  }]);
-  return LedgerApp;
-}();
-
-module.exports = LedgerApp;
-var _default = LedgerApp;
-exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/rpc/baseRpc.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/rpc/baseRpc.d.ts
deleted file mode 100644
index 9e1decd..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/rpc/baseRpc.d.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * https://github.com/nomic-io/js-tendermint/blob/master/src/rpc.js
- */
-/// <reference types="node" />
-import { EventEmitter } from "events";
-export declare type Args = {
-    [k: string]: any;
-};
-export default class BaseRpc extends EventEmitter {
-    private uri;
-    call: BaseRpc["callWs"] | BaseRpc["callHttp"];
-    private closed;
-    private ws?;
-    constructor(uriString?: string);
-    connectWs(): void;
-    callHttp(method: string, args?: Args): Promise<any>;
-    callWs(method: string, args?: Args, listener?: (value: any) => void): Promise<unknown>;
-    close(): void;
-    private createCallBasedMethod;
-    subscribe: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    unsubscribe: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    unsubscribeAll: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    status: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    netInfo: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    blockchain: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    genesis: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    health: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    block: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    blockResults: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    validators: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    consensusState: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    dumpConsensusState: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    broadcastTxCommit: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    broadcastTxSync: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    broadcastTxAsync: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    unconfirmedTxs: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    numUnconfirmedTxs: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    commit: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    tx: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    txSearch: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    abciQuery: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-    abciInfo: (args?: Args | undefined, listener?: Parameters<BaseRpc["call"]>[2]) => any;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/rpc/baseRpc.js b/node_modules/@binance-chain/javascript-sdk/lib/rpc/baseRpc.js
deleted file mode 100644
index bf1f5cb..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/rpc/baseRpc.js
+++ /dev/null
@@ -1,253 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _axios = _interopRequireDefault(require("axios"));
-
-var _events = require("events");
-
-var _is_js = _interopRequireDefault(require("is_js"));
-
-var _ndjson = _interopRequireDefault(require("ndjson"));
-
-var _pumpify = _interopRequireDefault(require("pumpify"));
-
-var _url = _interopRequireDefault(require("url"));
-
-var _websocketStream = _interopRequireDefault(require("websocket-stream"));
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-function convertHttpArgs(url) {
-  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
-  var search = [];
-
-  for (var _k in args) {
-    if (_is_js["default"].string(args[_k])) {
-      search.push("".concat(_k, "=\"").concat(args[_k], "\""));
-    } else if (Buffer.isBuffer(args[_k])) {
-      search.push("".concat(_k, "=0x").concat(args[_k].toString("hex")));
-    } else {
-      search.push("".concat(_k, "=").concat(args[_k]));
-    }
-  }
-
-  return "".concat(url, "?").concat(search.join("&"));
-}
-
-function convertWsArgs() {
-  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-
-  for (var _k2 in args) {
-    var v = args[_k2];
-
-    if (typeof v === "number") {
-      args[_k2] = String(v);
-    } else if (Buffer.isBuffer(v)) {
-      args[_k2] = "0x" + v.toString("hex");
-    } else if (v instanceof Uint8Array) {
-      args[_k2] = "0x" + Buffer.from(v).toString("hex");
-    }
-  }
-
-  return args;
-}
-
-var wsProtocols = ["ws:", "wss:"];
-var httpProtocols = ["http:", "https:"];
-var allProtocols = wsProtocols.concat(httpProtocols);
-
-var BaseRpc = /*#__PURE__*/function (_EventEmitter) {
-  (0, _inherits2["default"])(BaseRpc, _EventEmitter);
-
-  var _super = _createSuper(BaseRpc);
-
-  function BaseRpc() {
-    var _this;
-
-    var uriString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "localhost:27146";
-    (0, _classCallCheck2["default"])(this, BaseRpc);
-    _this = _super.call(this); // parse full-node URI
-
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "uri", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "call", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "closed", false);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "ws", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "createCallBasedMethod", function (name) {
-      return function (args, listener) {
-        return _this.call(name, args, listener).then(function (res) {
-          return res;
-        });
-      };
-    });
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "subscribe", _this.createCallBasedMethod("subscribe"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "unsubscribe", _this.createCallBasedMethod("unsubscribe"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "unsubscribeAll", _this.createCallBasedMethod("unsubscribe_all"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "status", _this.createCallBasedMethod("status"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "netInfo", _this.createCallBasedMethod("net_info"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "blockchain", _this.createCallBasedMethod("blockchain"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "genesis", _this.createCallBasedMethod("genesis"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "health", _this.createCallBasedMethod("health"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "block", _this.createCallBasedMethod("block"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "blockResults", _this.createCallBasedMethod("block_results"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "validators", _this.createCallBasedMethod("validators"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "consensusState", _this.createCallBasedMethod("consensus_state"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dumpConsensusState", _this.createCallBasedMethod("dump_consensus_state"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "broadcastTxCommit", _this.createCallBasedMethod("broadcast_tx_commit"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "broadcastTxSync", _this.createCallBasedMethod("broadcast_tx_sync"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "broadcastTxAsync", _this.createCallBasedMethod("broadcast_tx_async"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "unconfirmedTxs", _this.createCallBasedMethod("unconfirmed_txs"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "numUnconfirmedTxs", _this.createCallBasedMethod("num_unconfirmed_txs"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "commit", _this.createCallBasedMethod("commit"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "tx", _this.createCallBasedMethod("tx"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "txSearch", _this.createCallBasedMethod("tx_search"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "abciQuery", _this.createCallBasedMethod("abci_query"));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "abciInfo", _this.createCallBasedMethod("abci_info"));
-
-    var _url$parse = _url["default"].parse(uriString),
-        protocol = _url$parse.protocol,
-        hostname = _url$parse.hostname,
-        port = _url$parse.port; // default to http
-
-
-    if (!protocol || !allProtocols.includes(protocol)) {
-      var uri = _url["default"].parse("http://".concat(uriString));
-
-      protocol = uri.protocol;
-      hostname = uri.hostname;
-      port = uri.port;
-    }
-
-    _this.uri = !port ? "".concat(protocol, "//").concat(hostname, "/") : "".concat(protocol, "//").concat(hostname, ":").concat(port, "/");
-
-    if (protocol && wsProtocols.includes(protocol)) {
-      _this.uri = "".concat(_this.uri, "websocket");
-      _this.call = _this.callWs;
-
-      _this.connectWs();
-    } else if (protocol && httpProtocols.includes(protocol)) {
-      _this.call = _this.callHttp;
-    }
-
-    return _this;
-  }
-
-  (0, _createClass2["default"])(BaseRpc, [{
-    key: "connectWs",
-    value: function connectWs() {
-      var _this2 = this;
-
-      this.ws = new _pumpify["default"].obj(_ndjson["default"].stringify(), (0, _websocketStream["default"])(this.uri));
-      this.ws.on("error", function (err) {
-        return _this2.emit("error", err);
-      });
-      this.ws.on("close", function () {
-        if (_this2.closed) return;
-
-        _this2.emit("error", Error("websocket disconnected"));
-      });
-      this.ws.on("data", function (data) {
-        data = JSON.parse(data);
-        if (!data.id) return;
-
-        _this2.emit(data.id, data.error, data.result);
-      });
-    }
-  }, {
-    key: "callHttp",
-    value: function callHttp(method, args) {
-      var url = this.uri + method;
-      url = convertHttpArgs(url, args);
-      return (0, _axios["default"])({
-        url: url
-      }).then(function (_ref) {
-        var data = _ref.data;
-
-        if (data.error) {
-          var err = Error(data.error.message);
-          Object.assign(err, data.error);
-          throw err;
-        }
-
-        return data.result;
-      }, function (err) {
-        throw Error(err);
-      });
-    }
-  }, {
-    key: "callWs",
-    value: function callWs(method, args, listener) {
-      var _this3 = this;
-
-      var self = this;
-      return new Promise(function (resolve, reject) {
-        var _this3$ws;
-
-        var id = Math.random().toString(36);
-        var params = convertWsArgs(args);
-
-        if (method === "subscribe") {
-          if (typeof listener !== "function") {
-            throw Error("Must provide listener function");
-          } // events get passed to listener
-
-
-          _this3.on(id + "#event", function (err, res) {
-            if (err) return self.emit("error", err);
-            return listener(res.data.value);
-          }); // promise resolves on successful subscription or error
-
-
-          _this3.on(id, function (err) {
-            if (err) return reject(err);
-            resolve();
-          });
-        } else {
-          // response goes to promise
-          _this3.once(id, function (err, res) {
-            if (err) return reject(err);
-            resolve(res);
-          });
-        }
-
-        (_this3$ws = _this3.ws) === null || _this3$ws === void 0 ? void 0 : _this3$ws.write({
-          jsonrpc: "2.0",
-          id: id,
-          method: method,
-          params: params
-        });
-      });
-    }
-  }, {
-    key: "close",
-    value: function close() {
-      this.closed = true;
-      if (!this.ws) return;
-      this.ws.destroy();
-    }
-  }]);
-  return BaseRpc;
-}(_events.EventEmitter);
-
-exports["default"] = BaseRpc;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/rpc/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/rpc/index.d.ts
deleted file mode 100644
index 7e6bab0..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/rpc/index.d.ts
+++ /dev/null
@@ -1,90 +0,0 @@
-/// <reference types="node" />
-import { NETWORK_PREFIX_MAPPING } from "../client";
-import Transaction from "../tx";
-import { TokenBalance, Coin, AminoPrefix } from "../types";
-import BaseRpc from "./baseRpc";
-/**
- * The Binance Chain Node rpc client
- */
-declare class RpcClient extends BaseRpc {
-    private netWork;
-    /**
-     * @param {String} uriString dataseed address
-     * @param {String} netWork Binance Chain network
-     */
-    constructor(uriString: string | undefined, netWork: keyof typeof NETWORK_PREFIX_MAPPING);
-    /**
-     * The RPC broadcast delegate broadcasts a transaction via RPC. This is intended for optional use as BncClient's broadcast delegate.
-     * @param {Transaction} signedTx the signed transaction
-     * @return {Promise}
-     */
-    broadcastDelegate(signedTx: Transaction): Promise<any>;
-    getBech32Prefix(): "" | "tbnb" | "bnb";
-    /**
-     * @param {String} symbol - required
-     * @returns {Object} token detail info
-     */
-    getTokenInfo(symbol: string): Promise<{
-        owner: string;
-        aminoPrefix: AminoPrefix;
-        name: string;
-        symbol: string;
-        original_symbol: string;
-        total_supply: number;
-        mintable: boolean;
-    }>;
-    /**
-     * get tokens by offset and limit
-     * @param {Number} offset
-     * @param {Number} limit
-     * @returns {Array} token list
-     */
-    listAllTokens(offset: number, limit: number): Promise<any>;
-    /**
-     * @param {String} address
-     * @returns {Object} Account info
-     */
-    getAccount(address: string): Promise<{
-        name: string;
-        locked: Coin[];
-        frozen: Coin[];
-        base: {
-            address: string;
-            coins: Coin[];
-            public_key: Buffer;
-            account_number: number;
-            sequence: number;
-        };
-    }>;
-    /**
-     * @param {Array} balances
-     */
-    getBalances(address: string): Promise<TokenBalance[]>;
-    /**
-     * get balance by symbol and address
-     * @param {String} address
-     * @param {String} symbol
-     * @returns {Object}
-     */
-    getBalance(address: string, symbol: string): Promise<TokenBalance | undefined>;
-    /**
-     * @param {String} address
-     * @param {String} symbol
-     * @returns {Object}
-     */
-    getOpenOrders(address: string, symbol: string): Promise<any>;
-    /**
-     * @param {Number} offset
-     * @param {Number} limit
-     * @returns {Array}
-     */
-    getTradingPairs(offset: number, limit: number): Promise<any>;
-    /**
-     * @param {String} tradePair
-     * @returns {Array}
-     */
-    getDepth(tradePair: string): Promise<any>;
-    getTxByHash(hash: Buffer | string, prove?: boolean): Promise<any>;
-    private parseTxResult;
-}
-export default RpcClient;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/rpc/index.js b/node_modules/@binance-chain/javascript-sdk/lib/rpc/index.js
deleted file mode 100644
index 212c04f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/rpc/index.js
+++ /dev/null
@@ -1,627 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-
-var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
-
-var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _big = require("big.js");
-
-var _amino = require("../amino");
-
-var crypto = _interopRequireWildcard(require("../crypto"));
-
-var _types = require("../types");
-
-var _utils = require("../utils");
-
-var _baseRpc = _interopRequireDefault(require("./baseRpc"));
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-/**
- * The Binance Chain Node rpc client
- */
-var RpcClient = /*#__PURE__*/function (_BaseRpc) {
-  (0, _inherits2["default"])(RpcClient, _BaseRpc);
-
-  var _super = _createSuper(RpcClient);
-
-  /**
-   * @param {String} uriString dataseed address
-   * @param {String} netWork Binance Chain network
-   */
-  function RpcClient() {
-    var _this;
-
-    var uriString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "localhost:27146";
-    var netWork = arguments.length > 1 ? arguments[1] : undefined;
-    (0, _classCallCheck2["default"])(this, RpcClient);
-    _this = _super.call(this, uriString);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "netWork", void 0);
-    _this.netWork = netWork || "mainnet";
-    return _this;
-  }
-  /**
-   * The RPC broadcast delegate broadcasts a transaction via RPC. This is intended for optional use as BncClient's broadcast delegate.
-   * @param {Transaction} signedTx the signed transaction
-   * @return {Promise}
-   */
-
-
-  (0, _createClass2["default"])(RpcClient, [{
-    key: "broadcastDelegate",
-    value: function () {
-      var _broadcastDelegate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(signedTx) {
-        var encoded, res;
-        return _regenerator["default"].wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                // amino encode the signed TX
-                encoded = signedTx.serialize(); // broadcast it via RPC; we have to use a promise here because that's
-                // what the BncClient expects as the return value of this function.
-
-                _context.next = 3;
-                return this.broadcastTxSync({
-                  tx: Buffer.from(encoded, "hex")
-                });
-
-              case 3:
-                res = _context.sent;
-
-                if (!("".concat(res.code) === "0")) {
-                  _context.next = 8;
-                  break;
-                }
-
-                return _context.abrupt("return", res);
-
-              case 8:
-                throw new Error("broadcastDelegate: non-zero status code ".concat(res.code));
-
-              case 9:
-              case "end":
-                return _context.stop();
-            }
-          }
-        }, _callee, this);
-      }));
-
-      function broadcastDelegate(_x) {
-        return _broadcastDelegate.apply(this, arguments);
-      }
-
-      return broadcastDelegate;
-    }()
-  }, {
-    key: "getBech32Prefix",
-    value: function getBech32Prefix() {
-      if (this.netWork === "mainnet") {
-        return "bnb";
-      }
-
-      if (this.netWork === "testnet") {
-        return "tbnb";
-      }
-
-      return "";
-    }
-    /**
-     * @param {String} symbol - required
-     * @returns {Object} token detail info
-     */
-
-  }, {
-    key: "getTokenInfo",
-    value: function () {
-      var _getTokenInfo = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(symbol) {
-        var path, res, bytes, tokenInfo, bech32Prefix, ownerAddress;
-        return _regenerator["default"].wrap(function _callee2$(_context2) {
-          while (1) {
-            switch (_context2.prev = _context2.next) {
-              case 0:
-                (0, _utils.validateSymbol)(symbol);
-                path = "/tokens/info/" + symbol;
-                _context2.next = 4;
-                return this.abciQuery({
-                  path: path
-                });
-
-              case 4:
-                res = _context2.sent;
-                bytes = Buffer.from(res.response.value, "base64");
-                tokenInfo = new _types.Token();
-                (0, _amino.unMarshalBinaryLengthPrefixed)(bytes, tokenInfo);
-                bech32Prefix = this.getBech32Prefix();
-                ownerAddress = crypto.encodeAddress(tokenInfo.owner, bech32Prefix);
-                delete tokenInfo.aminoPrefix; //TODO all the result contains aminoPrefix, need to improve
-
-                return _context2.abrupt("return", _objectSpread(_objectSpread({}, tokenInfo), {}, {
-                  owner: ownerAddress
-                }));
-
-              case 12:
-              case "end":
-                return _context2.stop();
-            }
-          }
-        }, _callee2, this);
-      }));
-
-      function getTokenInfo(_x2) {
-        return _getTokenInfo.apply(this, arguments);
-      }
-
-      return getTokenInfo;
-    }()
-    /**
-     * get tokens by offset and limit
-     * @param {Number} offset
-     * @param {Number} limit
-     * @returns {Array} token list
-     */
-
-  }, {
-    key: "listAllTokens",
-    value: function () {
-      var _listAllTokens = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(offset, limit) {
-        var _this2 = this;
-
-        var path, res, bytes, tokenArr, _unMarshalBinaryLengt, tokenList;
-
-        return _regenerator["default"].wrap(function _callee3$(_context3) {
-          while (1) {
-            switch (_context3.prev = _context3.next) {
-              case 0:
-                (0, _utils.validateOffsetLimit)(offset, limit);
-                path = "tokens/list/".concat(offset, "/").concat(limit);
-                _context3.next = 4;
-                return this.abciQuery({
-                  path: path
-                });
-
-              case 4:
-                res = _context3.sent;
-                bytes = Buffer.from(res.response.value, "base64");
-                tokenArr = [new _types.TokenOfList()];
-                _unMarshalBinaryLengt = (0, _amino.unMarshalBinaryLengthPrefixed)(bytes, tokenArr), tokenList = _unMarshalBinaryLengt.val;
-                (0, _amino.unMarshalBinaryLengthPrefixed)(bytes, tokenList);
-                return _context3.abrupt("return", tokenList.map(function (item) {
-                  return _objectSpread(_objectSpread({}, item), {}, {
-                    owner: crypto.encodeAddress(item.owner, _this2.getBech32Prefix())
-                  });
-                }));
-
-              case 10:
-              case "end":
-                return _context3.stop();
-            }
-          }
-        }, _callee3, this);
-      }));
-
-      function listAllTokens(_x3, _x4) {
-        return _listAllTokens.apply(this, arguments);
-      }
-
-      return listAllTokens;
-    }()
-    /**
-     * @param {String} address
-     * @returns {Object} Account info
-     */
-
-  }, {
-    key: "getAccount",
-    value: function () {
-      var _getAccount = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(address) {
-        var res, accountInfo, bytes, bech32Prefix;
-        return _regenerator["default"].wrap(function _callee4$(_context4) {
-          while (1) {
-            switch (_context4.prev = _context4.next) {
-              case 0:
-                _context4.next = 2;
-                return this.abciQuery({
-                  path: "/account/".concat(address)
-                });
-
-              case 2:
-                res = _context4.sent;
-                accountInfo = new _types.AppAccount();
-                bytes = Buffer.from(res.response.value, "base64");
-                (0, _amino.unMarshalBinaryBare)(bytes, accountInfo);
-                bech32Prefix = this.getBech32Prefix();
-                return _context4.abrupt("return", {
-                  name: accountInfo.name,
-                  locked: accountInfo.locked,
-                  frozen: accountInfo.frozen,
-                  base: _objectSpread(_objectSpread({}, accountInfo.base), {}, {
-                    address: crypto.encodeAddress(accountInfo.base.address, bech32Prefix)
-                  })
-                });
-
-              case 8:
-              case "end":
-                return _context4.stop();
-            }
-          }
-        }, _callee4, this);
-      }));
-
-      function getAccount(_x5) {
-        return _getAccount.apply(this, arguments);
-      }
-
-      return getAccount;
-    }()
-    /**
-     * @param {Array} balances
-     */
-
-  }, {
-    key: "getBalances",
-    value: function () {
-      var _getBalances = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(address) {
-        var account, coins, balances;
-        return _regenerator["default"].wrap(function _callee5$(_context5) {
-          while (1) {
-            switch (_context5.prev = _context5.next) {
-              case 0:
-                _context5.next = 2;
-                return this.getAccount(address);
-
-              case 2:
-                account = _context5.sent;
-                coins = [];
-                balances = [];
-
-                if (account) {
-                  coins = account.base && account.base.coins || [];
-                  (0, _utils.convertObjectArrayNum)(coins, ["amount"]);
-                  (0, _utils.convertObjectArrayNum)(account.locked, ["amount"]);
-                  (0, _utils.convertObjectArrayNum)(account.frozen, ["amount"]);
-                }
-
-                coins.forEach(function (item) {
-                  var locked = account.locked.find(function (lockedItem) {
-                    return item.denom === lockedItem.denom;
-                  }) || {};
-                  var frozen = account.frozen.find(function (frozenItem) {
-                    return item.denom === frozenItem.denom;
-                  }) || {};
-                  var bal = new _types.TokenBalance();
-                  bal.symbol = item.denom;
-                  bal.free = +new _big.Big(item.amount).toString();
-                  bal.locked = locked.amount || 0;
-                  bal.frozen = frozen.amount || 0;
-                  balances.push(bal);
-                });
-                return _context5.abrupt("return", balances);
-
-              case 8:
-              case "end":
-                return _context5.stop();
-            }
-          }
-        }, _callee5, this);
-      }));
-
-      function getBalances(_x6) {
-        return _getBalances.apply(this, arguments);
-      }
-
-      return getBalances;
-    }()
-    /**
-     * get balance by symbol and address
-     * @param {String} address
-     * @param {String} symbol
-     * @returns {Object}
-     */
-
-  }, {
-    key: "getBalance",
-    value: function () {
-      var _getBalance = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(address, symbol) {
-        var balances, bal;
-        return _regenerator["default"].wrap(function _callee6$(_context6) {
-          while (1) {
-            switch (_context6.prev = _context6.next) {
-              case 0:
-                (0, _utils.validateSymbol)(symbol);
-                _context6.next = 3;
-                return this.getBalances(address);
-
-              case 3:
-                balances = _context6.sent;
-                bal = balances.find(function (item) {
-                  return item.symbol.toUpperCase() === symbol.toUpperCase();
-                });
-                return _context6.abrupt("return", bal);
-
-              case 6:
-              case "end":
-                return _context6.stop();
-            }
-          }
-        }, _callee6, this);
-      }));
-
-      function getBalance(_x7, _x8) {
-        return _getBalance.apply(this, arguments);
-      }
-
-      return getBalance;
-    }()
-    /**
-     * @param {String} address
-     * @param {String} symbol
-     * @returns {Object}
-     */
-
-  }, {
-    key: "getOpenOrders",
-    value: function () {
-      var _getOpenOrders = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(address, symbol) {
-        var path, res, bytes, result, _unMarshalBinaryLengt2, openOrders;
-
-        return _regenerator["default"].wrap(function _callee7$(_context7) {
-          while (1) {
-            switch (_context7.prev = _context7.next) {
-              case 0:
-                path = "/dex/openorders/".concat(symbol, "/").concat(address);
-                _context7.next = 3;
-                return this.abciQuery({
-                  path: path
-                });
-
-              case 3:
-                res = _context7.sent;
-                bytes = Buffer.from(res.response.value, "base64");
-                result = [new _types.OpenOrder()];
-                _unMarshalBinaryLengt2 = (0, _amino.unMarshalBinaryLengthPrefixed)(bytes, result), openOrders = _unMarshalBinaryLengt2.val;
-                (0, _utils.convertObjectArrayNum)(openOrders, ["price", "quantity", "cumQty"]);
-                return _context7.abrupt("return", openOrders);
-
-              case 9:
-              case "end":
-                return _context7.stop();
-            }
-          }
-        }, _callee7, this);
-      }));
-
-      function getOpenOrders(_x9, _x10) {
-        return _getOpenOrders.apply(this, arguments);
-      }
-
-      return getOpenOrders;
-    }()
-    /**
-     * @param {Number} offset
-     * @param {Number} limit
-     * @returns {Array}
-     */
-
-  }, {
-    key: "getTradingPairs",
-    value: function () {
-      var _getTradingPairs = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(offset, limit) {
-        var path, res, bytes, result, _unMarshalBinaryLengt3, tradingPairs;
-
-        return _regenerator["default"].wrap(function _callee8$(_context8) {
-          while (1) {
-            switch (_context8.prev = _context8.next) {
-              case 0:
-                (0, _utils.validateOffsetLimit)(offset, limit);
-                path = "/dex/pairs/".concat(offset, "/").concat(limit);
-                _context8.next = 4;
-                return this.abciQuery({
-                  path: path
-                });
-
-              case 4:
-                res = _context8.sent;
-                bytes = Buffer.from(res.response.value, "base64");
-                result = [new _types.TradingPair()];
-                _unMarshalBinaryLengt3 = (0, _amino.unMarshalBinaryLengthPrefixed)(bytes, result), tradingPairs = _unMarshalBinaryLengt3.val;
-                (0, _utils.convertObjectArrayNum)(tradingPairs, ["list_price", "tick_size", "lot_size"]);
-                return _context8.abrupt("return", tradingPairs);
-
-              case 10:
-              case "end":
-                return _context8.stop();
-            }
-          }
-        }, _callee8, this);
-      }));
-
-      function getTradingPairs(_x11, _x12) {
-        return _getTradingPairs.apply(this, arguments);
-      }
-
-      return getTradingPairs;
-    }()
-    /**
-     * @param {String} tradePair
-     * @returns {Array}
-     */
-
-  }, {
-    key: "getDepth",
-    value: function () {
-      var _getDepth = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(tradePair) {
-        var path, res, bytes, result, _unMarshalBinaryLengt4, depth;
-
-        return _regenerator["default"].wrap(function _callee9$(_context9) {
-          while (1) {
-            switch (_context9.prev = _context9.next) {
-              case 0:
-                (0, _utils.validateTradingPair)(tradePair);
-                path = "dex/orderbook/".concat(tradePair);
-                _context9.next = 4;
-                return this.abciQuery({
-                  path: path
-                });
-
-              case 4:
-                res = _context9.sent;
-                bytes = Buffer.from(res.response.value, "base64");
-                result = new _types.OrderBook();
-                _unMarshalBinaryLengt4 = (0, _amino.unMarshalBinaryLengthPrefixed)(bytes, result), depth = _unMarshalBinaryLengt4.val;
-                (0, _utils.convertObjectArrayNum)(depth.levels, ["buyQty", "buyPrice", "sellQty", "sellPrice"]);
-                return _context9.abrupt("return", depth);
-
-              case 10:
-              case "end":
-                return _context9.stop();
-            }
-          }
-        }, _callee9, this);
-      }));
-
-      function getDepth(_x13) {
-        return _getDepth.apply(this, arguments);
-      }
-
-      return getDepth;
-    }()
-  }, {
-    key: "getTxByHash",
-    value: function () {
-      var _getTxByHash = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(hash) {
-        var prove,
-            res,
-            txBytes,
-            msgAminoPrefix,
-            msgType,
-            type,
-            _unMarshalBinaryLengt5,
-            result,
-            txResult,
-            _args10 = arguments;
-
-        return _regenerator["default"].wrap(function _callee10$(_context10) {
-          while (1) {
-            switch (_context10.prev = _context10.next) {
-              case 0:
-                prove = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : true;
-
-                if (!Buffer.isBuffer(hash)) {
-                  hash = Buffer.from(hash, "hex");
-                }
-
-                _context10.next = 4;
-                return this.tx({
-                  hash: hash,
-                  prove: prove
-                });
-
-              case 4:
-                res = _context10.sent;
-                txBytes = Buffer.from(res.tx, "base64");
-                msgAminoPrefix = txBytes.slice(8, 12).toString("hex");
-                msgType = (0, _utils.getMsgByAminoPrefix)(msgAminoPrefix);
-                type = {
-                  msg: [msgType.defaultMsg()],
-                  signatures: [{
-                    pub_key: Buffer.from(""),
-                    signature: Buffer.from(""),
-                    account_number: 0,
-                    sequence: 0
-                  }],
-                  memo: "",
-                  source: 0,
-                  data: "",
-                  aminoPrefix: _types.AminoPrefix.StdTx
-                };
-                _unMarshalBinaryLengt5 = (0, _amino.unMarshalBinaryLengthPrefixed)(txBytes, type), result = _unMarshalBinaryLengt5.val;
-                txResult = this.parseTxResult(res.tx_result); //TODO remove aminoPrefix
-
-                return _context10.abrupt("return", _objectSpread(_objectSpread({}, res), {}, {
-                  tx: result,
-                  tx_result: txResult
-                }));
-
-              case 12:
-              case "end":
-                return _context10.stop();
-            }
-          }
-        }, _callee10, this);
-      }));
-
-      function getTxByHash(_x14) {
-        return _getTxByHash.apply(this, arguments);
-      }
-
-      return getTxByHash;
-    }()
-  }, {
-    key: "parseTxResult",
-    value: function parseTxResult(txResult) {
-      if (txResult.data) {
-        txResult.data = Buffer.from(txResult.data, "base64").toString();
-      }
-
-      if (txResult.events && txResult.events.length > 0) {
-        for (var i = 0; i < txResult.events.length; i++) {
-          var event = txResult.events[i];
-
-          if (event.attributes && event.attributes.length > 0) {
-            event.attributes = event.attributes.map(function (item) {
-              return {
-                key: Buffer.from(item.key, "base64").toString(),
-                value: Buffer.from(item.value, "base64").toString()
-              };
-            });
-          }
-        }
-      }
-
-      if (txResult.tags && txResult.tags.length > 0) {
-        txResult.tags = txResult.tags.map(function (item) {
-          return {
-            key: Buffer.from(item.key, "base64").toString(),
-            value: Buffer.from(item.value, "base64").toString()
-          };
-        });
-      }
-
-      return _objectSpread({}, txResult);
-    }
-  }]);
-  return RpcClient;
-}(_baseRpc["default"]);
-
-var _default = RpcClient;
-exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/tx/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/tx/index.d.ts
deleted file mode 100644
index 6ace71f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/tx/index.d.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-/// <reference types="node" />
-import { curve } from "elliptic";
-import { SignMsg, StdSignMsg } from "../types";
-/**
- * Creates a new transaction object.
- * @example
- * var rawTx = {
- *   accountNumber: 1,
- *   chainId: 'bnbchain-1000',
- *   memo: '',
- *   msg: {},
- *   type: 'NewOrderMsg',
- *   sequence: 29,
- *   source: 0
- * };
- * var tx = new Transaction(rawTx);
- * @property {Buffer} raw The raw vstruct encoded transaction
- * @param {Number} data.account_number account number
- * @param {String} data.chain_id bnbChain Id
- * @param {String} data.memo transaction memo
- * @param {String} type transaction type
- * @param {Msg} data.msg object data of tx type
- * @param {Number} data.sequence transaction counts
- * @param {Number} data.source where does this transaction come from
- */
-export default class Transaction {
-    private sequence;
-    private accountNumber;
-    private chainId;
-    private msg?;
-    private baseMsg?;
-    private memo;
-    private source;
-    private signatures;
-    constructor(data: StdSignMsg);
-    /**
-     * generate the sign bytes for a transaction, given a msg
-     * @param {SignMsg} concrete msg object
-     * @return {Buffer}
-     **/
-    getSignBytes(msg?: SignMsg): Buffer;
-    /**
-     * attaches a signature to the transaction
-     * @param {Elliptic.PublicKey} pubKey
-     * @param {Buffer} signature
-     * @return {Transaction}
-     **/
-    addSignature(pubKey: curve.base.BasePoint, signature: Buffer): Transaction;
-    /**
-     * sign transaction with a given private key and msg
-     * @param {string} privateKey private key hex string
-     * @param {SignMsg} concrete msg object
-     * @return {Transaction}
-     **/
-    sign(privateKey: string, msg?: SignMsg): Transaction;
-    /**
-     * encode signed transaction to hex which is compatible with amino
-     */
-    serialize(): string;
-    /**
-     * serializes a public key in a 33-byte compressed format.
-     * @param {Elliptic.PublicKey} unencodedPubKey
-     * @return {Buffer}
-     */
-    private _serializePubKey;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/tx/index.js b/node_modules/@binance-chain/javascript-sdk/lib/tx/index.js
deleted file mode 100644
index e92f955..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/tx/index.js
+++ /dev/null
@@ -1,189 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _amino = require("../amino");
-
-var crypto = _interopRequireWildcard(require("../crypto"));
-
-var _types = require("../types");
-
-/**
- * Creates a new transaction object.
- * @example
- * var rawTx = {
- *   accountNumber: 1,
- *   chainId: 'bnbchain-1000',
- *   memo: '',
- *   msg: {},
- *   type: 'NewOrderMsg',
- *   sequence: 29,
- *   source: 0
- * };
- * var tx = new Transaction(rawTx);
- * @property {Buffer} raw The raw vstruct encoded transaction
- * @param {Number} data.account_number account number
- * @param {String} data.chain_id bnbChain Id
- * @param {String} data.memo transaction memo
- * @param {String} type transaction type
- * @param {Msg} data.msg object data of tx type
- * @param {Number} data.sequence transaction counts
- * @param {Number} data.source where does this transaction come from
- */
-var Transaction = /*#__PURE__*/function () {
-  // DEPRECATED: Retained for backward compatibility,
-  function Transaction(data) {
-    (0, _classCallCheck2["default"])(this, Transaction);
-    (0, _defineProperty2["default"])(this, "sequence", void 0);
-    (0, _defineProperty2["default"])(this, "accountNumber", void 0);
-    (0, _defineProperty2["default"])(this, "chainId", void 0);
-    (0, _defineProperty2["default"])(this, "msg", void 0);
-    (0, _defineProperty2["default"])(this, "baseMsg", void 0);
-    (0, _defineProperty2["default"])(this, "memo", void 0);
-    (0, _defineProperty2["default"])(this, "source", void 0);
-    (0, _defineProperty2["default"])(this, "signatures", void 0);
-    data = data || {};
-
-    if (!data.chainId) {
-      throw new Error("chain id should not be null");
-    }
-
-    this.sequence = data.sequence || 0;
-    this.accountNumber = data.accountNumber || 0;
-    this.chainId = data.chainId;
-    this.msg = data.msg;
-    this.baseMsg = data.baseMsg;
-    this.memo = data.memo;
-    this.source = data.source || 0; // default value is 0
-
-    this.signatures = [];
-  }
-  /**
-   * generate the sign bytes for a transaction, given a msg
-   * @param {SignMsg} concrete msg object
-   * @return {Buffer}
-   **/
-
-
-  (0, _createClass2["default"])(Transaction, [{
-    key: "getSignBytes",
-    value: function getSignBytes(msg) {
-      msg = msg || this.baseMsg && this.baseMsg.getSignMsg();
-      var signMsg = {
-        account_number: this.accountNumber.toString(),
-        chain_id: this.chainId,
-        data: null,
-        memo: this.memo,
-        msgs: [msg],
-        sequence: this.sequence.toString(),
-        source: this.source.toString()
-      };
-      return (0, _amino.convertObjectToSignBytes)(signMsg);
-    }
-    /**
-     * attaches a signature to the transaction
-     * @param {Elliptic.PublicKey} pubKey
-     * @param {Buffer} signature
-     * @return {Transaction}
-     **/
-
-  }, {
-    key: "addSignature",
-    value: function addSignature(pubKey, signature) {
-      var pubKeyBuf = this._serializePubKey(pubKey); // => Buffer
-
-
-      this.signatures = [{
-        pub_key: pubKeyBuf,
-        signature: signature,
-        account_number: this.accountNumber,
-        sequence: this.sequence
-      }];
-      return this;
-    }
-    /**
-     * sign transaction with a given private key and msg
-     * @param {string} privateKey private key hex string
-     * @param {SignMsg} concrete msg object
-     * @return {Transaction}
-     **/
-
-  }, {
-    key: "sign",
-    value: function sign(privateKey, msg) {
-      if (!privateKey) {
-        throw new Error("private key should not be null");
-      }
-
-      var signBytes = this.getSignBytes(msg);
-      var privKeyBuf = Buffer.from(privateKey, "hex");
-      var signature = crypto.generateSignature(signBytes.toString("hex"), privKeyBuf);
-      this.addSignature(crypto.generatePubKey(privKeyBuf), signature);
-      return this;
-    }
-    /**
-     * encode signed transaction to hex which is compatible with amino
-     */
-
-  }, {
-    key: "serialize",
-    value: function serialize() {
-      if (!this.signatures) {
-        throw new Error("need signature");
-      }
-
-      var msg = this.msg || this.baseMsg && this.baseMsg.getMsg();
-      var stdTx = {
-        msg: [msg],
-        signatures: this.signatures,
-        memo: this.memo,
-        source: this.source,
-        // sdk value is 0, web wallet value is 1
-        data: "",
-        aminoPrefix: _types.AminoPrefix.StdTx
-      };
-      var bytes = (0, _amino.marshalBinary)(stdTx);
-      return bytes.toString("hex");
-    }
-    /**
-     * serializes a public key in a 33-byte compressed format.
-     * @param {Elliptic.PublicKey} unencodedPubKey
-     * @return {Buffer}
-     */
-
-  }, {
-    key: "_serializePubKey",
-    value: function _serializePubKey(unencodedPubKey) {
-      var format = 0x2;
-      var y = unencodedPubKey.getY();
-      var x = unencodedPubKey.getX();
-
-      if (y && y.isOdd()) {
-        format |= 0x1;
-      }
-
-      var pubBz = Buffer.concat([_amino.UVarInt.encode(format), x.toArrayLike(Buffer, "be", 32)]); // prefixed with length
-
-      pubBz = (0, _amino.encodeBinaryByteArray)(pubBz); // add the amino prefix
-
-      pubBz = Buffer.concat([Buffer.from("EB5AE987", "hex"), pubBz]);
-      return pubBz;
-    }
-  }]);
-  return Transaction;
-}();
-
-exports["default"] = Transaction;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/index.d.ts
deleted file mode 100644
index 095cc78..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/index.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-export * from "./msg";
-export * from "./tx";
-export * from "./rpc";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/index.js
deleted file mode 100644
index a1618a2..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/index.js
+++ /dev/null
@@ -1,41 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _msg = require("./msg");
-
-Object.keys(_msg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _msg[key];
-    }
-  });
-});
-
-var _tx = require("./tx");
-
-Object.keys(_tx).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _tx[key];
-    }
-  });
-});
-
-var _rpc = require("./rpc");
-
-Object.keys(_rpc).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _rpc[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/base/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/base/index.d.ts
deleted file mode 100644
index 221807d..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/base/index.d.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-export interface SignMsg {
-}
-export interface Msg {
-}
-export declare abstract class BaseMsg {
-    abstract getSignMsg(): SignMsg;
-    abstract getMsg(): Msg;
-    static defaultMsg(): object;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/base/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/base/index.js
deleted file mode 100644
index 3fe9b4e..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/base/index.js
+++ /dev/null
@@ -1,29 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BaseMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-/* eslint-disable */
-var BaseMsg = /*#__PURE__*/function () {
-  function BaseMsg() {
-    (0, _classCallCheck2["default"])(this, BaseMsg);
-  }
-
-  (0, _createClass2["default"])(BaseMsg, null, [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {};
-    }
-  }]);
-  return BaseMsg;
-}();
-
-exports.BaseMsg = BaseMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/bindMsg.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/bindMsg.d.ts
deleted file mode 100644
index 69ca915..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/bindMsg.d.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedBindMsg extends SignMsg {
-    from: string;
-    symbol: string;
-    amount: number;
-    contract_address: string;
-    contract_decimals: number;
-    expire_time: number;
-}
-export interface BindMsgData extends Msg {
-    from: Buffer;
-    symbol: string;
-    amount: number;
-    contract_address: Buffer;
-    contract_decimals: number;
-    expire_time: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class BindMsg extends BaseMsg {
-    private from;
-    private symbol;
-    private amount;
-    private contract_address;
-    private contract_decimals;
-    private expire_time;
-    constructor({ from, symbol, amount, contract_address, contract_decimals, expire_time, }: {
-        from: string;
-        symbol: string;
-        amount: number;
-        contract_address: string;
-        contract_decimals: number;
-        expire_time: number;
-    });
-    getSignMsg(): SignedBindMsg;
-    getMsg(): BindMsgData;
-    static defaultMsg(): BindMsgData;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/bindMsg.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/bindMsg.js
deleted file mode 100644
index 5189f4e..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/bindMsg.js
+++ /dev/null
@@ -1,109 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BindMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var BindMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(BindMsg, _BaseMsg);
-
-  var _super = _createSuper(BindMsg);
-
-  function BindMsg(_ref) {
-    var _this;
-
-    var from = _ref.from,
-        symbol = _ref.symbol,
-        amount = _ref.amount,
-        contract_address = _ref.contract_address,
-        contract_decimals = _ref.contract_decimals,
-        expire_time = _ref.expire_time;
-    (0, _classCallCheck2["default"])(this, BindMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "contract_address", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "contract_decimals", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "expire_time", void 0);
-    _this.from = from;
-    _this.symbol = symbol;
-    _this.amount = amount;
-    _this.contract_address = contract_address;
-    _this.contract_decimals = contract_decimals;
-    _this.expire_time = expire_time;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(BindMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      return {
-        from: this.from,
-        symbol: this.symbol,
-        amount: this.amount,
-        contract_address: this.contract_address,
-        contract_decimals: this.contract_decimals,
-        expire_time: this.expire_time
-      };
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      return {
-        from: crypto.decodeAddress(this.from),
-        symbol: this.symbol,
-        amount: this.amount,
-        contract_address: Buffer.from(this.contract_address.slice(2), "hex"),
-        contract_decimals: this.contract_decimals,
-        expire_time: this.expire_time,
-        aminoPrefix: _tx.AminoPrefix.BindMsg
-      };
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        symbol: "",
-        amount: 0,
-        contract_address: Buffer.from(""),
-        contract_decimals: 0,
-        expire_time: 0,
-        aminoPrefix: _tx.AminoPrefix.BindMsg
-      };
-    }
-  }]);
-  return BindMsg;
-}(_.BaseMsg);
-
-exports.BindMsg = BindMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimMsg.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimMsg.d.ts
deleted file mode 100644
index c8d92bc..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimMsg.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-import { ClaimTypes } from "./claimTypes";
-export interface SignedClaimMsg extends SignMsg {
-    claim_type: ClaimTypes;
-    sequence: number;
-    claim: string;
-    validator_address: string;
-}
-export interface ClaimMsgData extends Msg {
-    claim_type: ClaimTypes;
-    sequence: number;
-    claim: string;
-    validator_address: Buffer;
-    aminoPrefix: AminoPrefix;
-}
-export declare class ClaimMsg extends BaseMsg {
-    private claim_type;
-    private sequence;
-    private claim;
-    private validator_address;
-    constructor({ claim_type, sequence, claim, validator_address, }: {
-        claim_type: ClaimTypes;
-        sequence: number;
-        claim: string;
-        validator_address: string;
-    });
-    getSignMsg(): SignedClaimMsg;
-    getMsg(): ClaimMsgData;
-    static defaultMsg(): ClaimMsgData;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimMsg.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimMsg.js
deleted file mode 100644
index 52ce876..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimMsg.js
+++ /dev/null
@@ -1,99 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.ClaimMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-var _claimTypes = require("./claimTypes");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var ClaimMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(ClaimMsg, _BaseMsg);
-
-  var _super = _createSuper(ClaimMsg);
-
-  function ClaimMsg(_ref) {
-    var _this;
-
-    var claim_type = _ref.claim_type,
-        sequence = _ref.sequence,
-        claim = _ref.claim,
-        validator_address = _ref.validator_address;
-    (0, _classCallCheck2["default"])(this, ClaimMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "claim_type", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "sequence", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "claim", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "validator_address", void 0);
-    _this.claim_type = claim_type;
-    _this.sequence = sequence;
-    _this.claim = claim;
-    _this.validator_address = validator_address;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(ClaimMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      return {
-        claim_type: this.claim_type,
-        sequence: this.sequence,
-        claim: this.claim,
-        validator_address: this.validator_address
-      };
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      return {
-        claim_type: this.claim_type,
-        sequence: this.sequence,
-        claim: this.claim,
-        validator_address: crypto.decodeAddress(this.validator_address),
-        aminoPrefix: _tx.AminoPrefix.ClaimMsg
-      };
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        claim_type: _claimTypes.ClaimTypes.ClaimTypeSkipSequence,
-        sequence: 0,
-        claim: "",
-        validator_address: Buffer.from(""),
-        aminoPrefix: _tx.AminoPrefix.ClaimMsg
-      };
-    }
-  }]);
-  return ClaimMsg;
-}(_.BaseMsg);
-
-exports.ClaimMsg = ClaimMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimTypes.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimTypes.d.ts
deleted file mode 100644
index b8d1aa0..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimTypes.d.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-import { Coin } from "..";
-export declare enum ClaimTypes {
-    ClaimTypeSkipSequence = 1,
-    ClaimTypeUpdateBind = 2,
-    ClaimTypeTransferOutRefund = 3,
-    ClaimTypeTransferIn = 4
-}
-export declare enum RefundReason {
-    UnboundToken = 1,
-    Timeout = 2,
-    InsufficientBalance = 3,
-    Unkown = 4
-}
-export declare enum BindStatus {
-    BindStatusSuccess = 0,
-    BindStatusRejected = 1,
-    BindStatusTimeout = 2,
-    BindStatusInvalidParameter = 3
-}
-export interface TransferInClaim {
-    contract_address: string;
-    refund_addresses: string[];
-    receiver_addresses: string[];
-    amounts: number[];
-    symbol: string;
-    relay_fee: Coin;
-    expire_time: number;
-}
-export interface TransferOutRefundClaim {
-    transfer_out_sequence: number;
-    refund_address: string;
-    amount: Coin;
-    refund_reason: RefundReason;
-}
-export interface UpdateBindClaim {
-    status: BindStatus;
-    symbol: string;
-    contract_address: string;
-}
-export interface SkipSequenceClaim {
-    claim_type: ClaimTypes;
-    sequenceToSkip: number;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimTypes.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimTypes.js
deleted file mode 100644
index 4d47868..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/claimTypes.js
+++ /dev/null
@@ -1,35 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BindStatus = exports.RefundReason = exports.ClaimTypes = void 0;
-var ClaimTypes;
-exports.ClaimTypes = ClaimTypes;
-
-(function (ClaimTypes) {
-  ClaimTypes[ClaimTypes["ClaimTypeSkipSequence"] = 1] = "ClaimTypeSkipSequence";
-  ClaimTypes[ClaimTypes["ClaimTypeUpdateBind"] = 2] = "ClaimTypeUpdateBind";
-  ClaimTypes[ClaimTypes["ClaimTypeTransferOutRefund"] = 3] = "ClaimTypeTransferOutRefund";
-  ClaimTypes[ClaimTypes["ClaimTypeTransferIn"] = 4] = "ClaimTypeTransferIn";
-})(ClaimTypes || (exports.ClaimTypes = ClaimTypes = {}));
-
-var RefundReason;
-exports.RefundReason = RefundReason;
-
-(function (RefundReason) {
-  RefundReason[RefundReason["UnboundToken"] = 1] = "UnboundToken";
-  RefundReason[RefundReason["Timeout"] = 2] = "Timeout";
-  RefundReason[RefundReason["InsufficientBalance"] = 3] = "InsufficientBalance";
-  RefundReason[RefundReason["Unkown"] = 4] = "Unkown";
-})(RefundReason || (exports.RefundReason = RefundReason = {}));
-
-var BindStatus;
-exports.BindStatus = BindStatus;
-
-(function (BindStatus) {
-  BindStatus[BindStatus["BindStatusSuccess"] = 0] = "BindStatusSuccess";
-  BindStatus[BindStatus["BindStatusRejected"] = 1] = "BindStatusRejected";
-  BindStatus[BindStatus["BindStatusTimeout"] = 2] = "BindStatusTimeout";
-  BindStatus[BindStatus["BindStatusInvalidParameter"] = 3] = "BindStatusInvalidParameter";
-})(BindStatus || (exports.BindStatus = BindStatus = {}));
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/index.d.ts
deleted file mode 100644
index e36d09e..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/index.d.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export * from "./bindMsg";
-export * from "./claimMsg";
-export * from "./claimTypes";
-export * from "./transferOutMsg";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/index.js
deleted file mode 100644
index 33d107c..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/index.js
+++ /dev/null
@@ -1,53 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _bindMsg = require("./bindMsg");
-
-Object.keys(_bindMsg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _bindMsg[key];
-    }
-  });
-});
-
-var _claimMsg = require("./claimMsg");
-
-Object.keys(_claimMsg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _claimMsg[key];
-    }
-  });
-});
-
-var _claimTypes = require("./claimTypes");
-
-Object.keys(_claimTypes).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _claimTypes[key];
-    }
-  });
-});
-
-var _transferOutMsg = require("./transferOutMsg");
-
-Object.keys(_transferOutMsg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _transferOutMsg[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/transferOutMsg.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/transferOutMsg.d.ts
deleted file mode 100644
index cc58531..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/transferOutMsg.d.ts
+++ /dev/null
@@ -1,31 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg, Coin } from "..";
-import { AminoPrefix } from "../../tx";
-export interface SignedTransferOutMsg extends SignMsg {
-    from: string;
-    to: string;
-    amount: Coin;
-    expire_time: number;
-}
-export interface TransferoutData extends Msg {
-    from: Buffer;
-    to: Buffer;
-    amount: Coin;
-    expire_time: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class TransferOutMsg extends BaseMsg {
-    private from;
-    private to;
-    private amount;
-    private expire_time;
-    constructor({ from, to, amount, expire_time, }: {
-        from: string;
-        to: string;
-        amount: Coin;
-        expire_time: number;
-    });
-    getSignMsg(): SignedTransferOutMsg;
-    getMsg(): TransferoutData;
-    static defaultMsg(): TransferoutData;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/transferOutMsg.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/transferOutMsg.js
deleted file mode 100644
index 418564a..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/claim/transferOutMsg.js
+++ /dev/null
@@ -1,108 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.TransferOutMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var _ = require("..");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var TransferOutMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(TransferOutMsg, _BaseMsg);
-
-  var _super = _createSuper(TransferOutMsg);
-
-  function TransferOutMsg(_ref) {
-    var _this;
-
-    var from = _ref.from,
-        to = _ref.to,
-        amount = _ref.amount,
-        expire_time = _ref.expire_time;
-    (0, _classCallCheck2["default"])(this, TransferOutMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "to", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "expire_time", void 0);
-    _this.from = from;
-    _this.to = to;
-    _this.amount = _objectSpread(_objectSpread({}, amount), {}, {
-      amount: Number(new _big["default"](amount.amount).mul(Math.pow(10, 8)).toString())
-    });
-    _this.expire_time = expire_time;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(TransferOutMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      return {
-        from: this.from,
-        to: this.to,
-        amount: this.amount,
-        expire_time: this.expire_time
-      };
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      return {
-        from: crypto.decodeAddress(this.from),
-        to: Buffer.from(this.to.slice(2), "hex"),
-        amount: this.amount,
-        expire_time: this.expire_time,
-        aminoPrefix: _tx.AminoPrefix.TransferOutMsg
-      };
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        to: Buffer.from(""),
-        amount: {
-          denom: "",
-          amount: 0
-        },
-        expire_time: 0,
-        aminoPrefix: _tx.AminoPrefix.TransferOutMsg
-      };
-    }
-  }]);
-  return TransferOutMsg;
-}(_.BaseMsg);
-
-exports.TransferOutMsg = TransferOutMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/cancelOrder.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/cancelOrder.d.ts
deleted file mode 100644
index 71fd08e..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/cancelOrder.d.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-/// <reference types="node" />
-import { AminoPrefix } from "../../tx";
-import { BaseMsg, Msg, SignMsg } from "../base";
-export interface SignedCancelOrder extends SignMsg {
-    sender: string;
-    symbol: string;
-    refid: string;
-}
-export interface CancelOrderData extends Msg {
-    sender: Buffer;
-    symbol: string;
-    refid: string;
-    aminoPrefix: AminoPrefix;
-}
-export declare class CancelOrderMsg extends BaseMsg {
-    private address;
-    private symbol;
-    private orderId;
-    readonly aminoPrefix: AminoPrefix;
-    constructor(address: string, sybmol: string, orderId: string);
-    getSignMsg(): SignedCancelOrder;
-    getMsg(): CancelOrderData;
-    static defaultMsg(): {
-        sender: Buffer;
-        symbol: string;
-        refid: string;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/cancelOrder.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/cancelOrder.js
deleted file mode 100644
index 6105c1f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/cancelOrder.js
+++ /dev/null
@@ -1,91 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.CancelOrderMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-var _base = require("../base");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var CancelOrderMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(CancelOrderMsg, _BaseMsg);
-
-  var _super = _createSuper(CancelOrderMsg);
-
-  function CancelOrderMsg(address, sybmol, orderId) {
-    var _this;
-
-    (0, _classCallCheck2["default"])(this, CancelOrderMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "address", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "orderId", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "aminoPrefix", _tx.AminoPrefix.CancelOrderMsg);
-    _this.address = address;
-    _this.symbol = sybmol;
-    _this.orderId = orderId;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(CancelOrderMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        sender: this.address,
-        symbol: this.symbol,
-        refid: this.orderId
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        sender: crypto.decodeAddress(this.address),
-        symbol: this.symbol,
-        refid: this.orderId,
-        aminoPrefix: _tx.AminoPrefix.CancelOrderMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        sender: Buffer.from(""),
-        symbol: "",
-        refid: "",
-        aminoPrefix: _tx.AminoPrefix.CancelOrderMsg
-      };
-    }
-  }]);
-  return CancelOrderMsg;
-}(_base.BaseMsg);
-
-exports.CancelOrderMsg = CancelOrderMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/index.d.ts
deleted file mode 100644
index d916c0c..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/index.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-export * from "./cancelOrder";
-export * from "./newOrder";
-export * from "./listMiniMsg";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/index.js
deleted file mode 100644
index 233e414..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/index.js
+++ /dev/null
@@ -1,41 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _cancelOrder = require("./cancelOrder");
-
-Object.keys(_cancelOrder).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _cancelOrder[key];
-    }
-  });
-});
-
-var _newOrder = require("./newOrder");
-
-Object.keys(_newOrder).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _newOrder[key];
-    }
-  });
-});
-
-var _listMiniMsg = require("./listMiniMsg");
-
-Object.keys(_listMiniMsg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _listMiniMsg[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/listMiniMsg.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/listMiniMsg.d.ts
deleted file mode 100644
index b050571..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/listMiniMsg.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-/// <reference types="node" />
-import { AminoPrefix } from "../../tx";
-import { BaseMsg, Msg, SignMsg } from "../base";
-export interface SignedListMini extends SignMsg {
-    from: string;
-    base_asset_symbol: string;
-    quote_asset_symbol: string;
-    init_price: number;
-}
-export interface ListMiniData extends Msg {
-    from: Buffer;
-    base_asset_symbol: string;
-    quote_asset_symbol: string;
-    init_price: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class ListMiniMsg extends BaseMsg {
-    private from;
-    private base_asset_symbol;
-    private quote_asset_symbol;
-    private init_price;
-    constructor({ from, base_asset_symbol, quote_asset_symbol, init_price, }: SignedListMini);
-    getSignMsg(): SignedListMini;
-    getMsg(): ListMiniData;
-    static defaultMsg(): {
-        from: Buffer;
-        base_asset_symbol: string;
-        quote_asset_symbol: string;
-        init_price: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/listMiniMsg.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/listMiniMsg.js
deleted file mode 100644
index 2bb4dde..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/listMiniMsg.js
+++ /dev/null
@@ -1,99 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.ListMiniMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-var _base = require("../base");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var ListMiniMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(ListMiniMsg, _BaseMsg);
-
-  var _super = _createSuper(ListMiniMsg);
-
-  function ListMiniMsg(_ref) {
-    var _this;
-
-    var from = _ref.from,
-        base_asset_symbol = _ref.base_asset_symbol,
-        quote_asset_symbol = _ref.quote_asset_symbol,
-        init_price = _ref.init_price;
-    (0, _classCallCheck2["default"])(this, ListMiniMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "base_asset_symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "quote_asset_symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "init_price", void 0);
-    _this.from = from;
-    _this.base_asset_symbol = base_asset_symbol;
-    _this.quote_asset_symbol = quote_asset_symbol;
-    _this.init_price = init_price;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(ListMiniMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        base_asset_symbol: this.base_asset_symbol,
-        quote_asset_symbol: this.quote_asset_symbol,
-        init_price: this.init_price
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        base_asset_symbol: this.base_asset_symbol,
-        quote_asset_symbol: this.quote_asset_symbol,
-        init_price: this.init_price,
-        aminoPrefix: _tx.AminoPrefix.ListMiniMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        base_asset_symbol: "",
-        quote_asset_symbol: "",
-        init_price: 0,
-        aminoPrefix: _tx.AminoPrefix.ListMiniMsg
-      };
-    }
-  }]);
-  return ListMiniMsg;
-}(_base.BaseMsg);
-
-exports.ListMiniMsg = ListMiniMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/newOrder.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/newOrder.d.ts
deleted file mode 100644
index c8db7c8..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/newOrder.d.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface NewOrder {
-    id: string;
-    symbol: string;
-    ordertype: number;
-    side: number;
-    price: number;
-    quantity: number;
-    timeinforce: number;
-}
-export interface SignedNewOrder extends SignMsg, NewOrder {
-    sender: string;
-}
-export interface NewOrderData extends Msg, NewOrder {
-    sender: Buffer;
-    aminoPrefix: AminoPrefix;
-}
-export declare class NewOrderMsg extends BaseMsg {
-    private newOrder;
-    private address;
-    readonly aminoPrefix: AminoPrefix;
-    constructor(data: NewOrder, address: string);
-    getSignMsg(): SignedNewOrder;
-    getMsg(): NewOrderData;
-    static defaultMsg(): {
-        sender: Buffer;
-        id: string;
-        symbol: string;
-        orderType: number;
-        side: number;
-        price: number;
-        quantity: number;
-        timeinforce: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/newOrder.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/newOrder.js
deleted file mode 100644
index 29b05c7..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/dex/newOrder.js
+++ /dev/null
@@ -1,110 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.NewOrderMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var BASENUMBER = Math.pow(10, 8);
-
-var NewOrderMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(NewOrderMsg, _BaseMsg);
-
-  var _super = _createSuper(NewOrderMsg);
-
-  function NewOrderMsg(data, address) {
-    var _this;
-
-    (0, _classCallCheck2["default"])(this, NewOrderMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "newOrder", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "address", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "aminoPrefix", _tx.AminoPrefix.NewOrderMsg);
-    var bigPrice = new _big["default"](data.price);
-    var bigQuantity = new _big["default"](data.quantity);
-    _this.newOrder = data;
-    _this.newOrder.price = Number(bigPrice.mul(BASENUMBER).toString());
-    _this.newOrder.quantity = Number(bigQuantity.mul(BASENUMBER).toString());
-    _this.address = address;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(NewOrderMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = _objectSpread({
-        sender: this.address
-      }, this.newOrder);
-
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        sender: crypto.decodeAddress(this.address),
-        id: this.newOrder.id,
-        symbol: this.newOrder.symbol,
-        ordertype: this.newOrder.ordertype,
-        side: this.newOrder.side,
-        price: this.newOrder.price,
-        quantity: this.newOrder.quantity,
-        timeinforce: this.newOrder.timeinforce,
-        aminoPrefix: this.aminoPrefix
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        sender: Buffer.from(""),
-        id: "",
-        symbol: "",
-        orderType: 0,
-        side: 0,
-        price: 0,
-        quantity: 0,
-        timeinforce: 0,
-        aminoPrefix: _tx.AminoPrefix.NewOrderMsg
-      };
-    }
-  }]);
-  return NewOrderMsg;
-}(_.BaseMsg);
-
-exports.NewOrderMsg = NewOrderMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/index.d.ts
deleted file mode 100644
index 19a4269..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/index.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export * from "./submitProposal";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/index.js
deleted file mode 100644
index 0e5dda2..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/index.js
+++ /dev/null
@@ -1,17 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _submitProposal = require("./submitProposal");
-
-Object.keys(_submitProposal).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _submitProposal[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/submitProposal.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/submitProposal.d.ts
deleted file mode 100644
index 1b600d7..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/submitProposal.d.ts
+++ /dev/null
@@ -1,64 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg, Coin } from "../";
-import { AminoPrefix } from "../../tx";
-declare const proposalTypeMapping: {
-    readonly 4: "ListTradingPair";
-    readonly 0: "Nil";
-    readonly 1: "Text";
-    readonly 2: "ParameterChange";
-    readonly 3: "SoftwareUpgrade";
-    readonly 5: "FeeChange";
-    readonly 6: "CreateValidator";
-    readonly 7: "RemoveValidator";
-};
-export interface SignedSubmitProposal extends SignMsg {
-    title: string;
-    description: string;
-    proposal_type: string;
-    proposer: string;
-    initial_deposit: {
-        denom: string;
-        amount: string;
-    }[];
-    voting_period: string;
-}
-export interface SubmitProposalData extends Msg {
-    title: string;
-    description: string;
-    proposal_type: keyof typeof proposalTypeMapping;
-    proposer: Buffer;
-    initial_deposit: Coin[];
-    voting_period: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class SubmitProposalMsg extends BaseMsg {
-    private title;
-    private description;
-    private proposal_type;
-    private address;
-    private initialDeposit;
-    private voting_period;
-    constructor({ address, title, proposal_type, initialDeposit, voting_period, description, }: {
-        title: string;
-        description: string;
-        proposal_type: keyof typeof proposalTypeMapping;
-        address: string;
-        initialDeposit: number;
-        voting_period: number;
-    });
-    getSignMsg(): SignedSubmitProposal;
-    getMsg(): SubmitProposalData;
-    static defaultMsg(): {
-        title: string;
-        description: string;
-        propsal_type: number;
-        proposer: Buffer;
-        inital_deposit: {
-            denom: string;
-            amount: number;
-        }[];
-        voting_period: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
-export {};
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/submitProposal.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/submitProposal.js
deleted file mode 100644
index 2b69dc7..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/gov/submitProposal.js
+++ /dev/null
@@ -1,131 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.SubmitProposalMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var proposalTypeMapping = {
-  0x04: "ListTradingPair",
-  0x00: "Nil",
-  0x01: "Text",
-  0x02: "ParameterChange",
-  0x03: "SoftwareUpgrade",
-  0x05: "FeeChange",
-  0x06: "CreateValidator",
-  0x07: "RemoveValidator"
-};
-
-var SubmitProposalMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(SubmitProposalMsg, _BaseMsg);
-
-  var _super = _createSuper(SubmitProposalMsg);
-
-  function SubmitProposalMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        title = _ref.title,
-        proposal_type = _ref.proposal_type,
-        initialDeposit = _ref.initialDeposit,
-        voting_period = _ref.voting_period,
-        description = _ref.description;
-    (0, _classCallCheck2["default"])(this, SubmitProposalMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "title", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "description", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "proposal_type", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "address", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "initialDeposit", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "voting_period", void 0);
-    _this.address = address;
-    _this.title = title;
-    _this.proposal_type = proposal_type;
-    _this.initialDeposit = initialDeposit;
-    _this.voting_period = voting_period;
-    _this.description = description;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(SubmitProposalMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        title: this.title,
-        description: this.description,
-        proposal_type: proposalTypeMapping[this.proposal_type],
-        proposer: this.address,
-        voting_period: this.voting_period.toString(),
-        initial_deposit: [{
-          denom: "BNB",
-          amount: new Big(this.initialDeposit).mul(Math.pow(10, 8)).toString()
-        }]
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        title: this.title,
-        description: this.description,
-        proposal_type: this.proposal_type,
-        proposer: crypto.decodeAddress(this.address),
-        initial_deposit: [{
-          denom: "BNB",
-          amount: +new Big(this.initialDeposit).mul(Math.pow(10, 8)).toString()
-        }],
-        voting_period: this.voting_period,
-        aminoPrefix: _tx.AminoPrefix.MsgSubmitProposal
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        title: "",
-        description: "",
-        propsal_type: 0,
-        proposer: Buffer.from(""),
-        inital_deposit: [{
-          denom: "",
-          amount: 0
-        }],
-        voting_period: 0,
-        aminoPrefix: _tx.AminoPrefix.MsgSubmitProposal
-      };
-    }
-  }]);
-  return SubmitProposalMsg;
-}(_.BaseMsg);
-
-exports.SubmitProposalMsg = SubmitProposalMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/index.d.ts
deleted file mode 100644
index 1fc2038..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/index.d.ts
+++ /dev/null
@@ -1,6 +0,0 @@
-export * from "./base";
-export * from "./dex";
-export * from "./token";
-export * from "./send";
-export * from "./claim";
-export * from "./stake";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/index.js
deleted file mode 100644
index 9727b3f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/index.js
+++ /dev/null
@@ -1,77 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _base = require("./base");
-
-Object.keys(_base).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _base[key];
-    }
-  });
-});
-
-var _dex = require("./dex");
-
-Object.keys(_dex).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _dex[key];
-    }
-  });
-});
-
-var _token = require("./token");
-
-Object.keys(_token).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _token[key];
-    }
-  });
-});
-
-var _send = require("./send");
-
-Object.keys(_send).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _send[key];
-    }
-  });
-});
-
-var _claim = require("./claim");
-
-Object.keys(_claim).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _claim[key];
-    }
-  });
-});
-
-var _stake = require("./stake");
-
-Object.keys(_stake).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _stake[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/send.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/send.d.ts
deleted file mode 100644
index 10813f7..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/send.d.ts
+++ /dev/null
@@ -1,56 +0,0 @@
-/// <reference types="node" />
-import { BigSource } from "big.js";
-import { AminoPrefix } from "../tx";
-import { BaseMsg, Msg, SignMsg } from "./";
-export interface Coin {
-    denom: string;
-    amount: BigSource;
-}
-export interface SignInputOutput {
-    address: string;
-    coins: Coin[];
-}
-interface InputOutput {
-    address: Buffer;
-    coins: Coin[];
-}
-export interface SignedSend extends SignMsg {
-    inputs: SignInputOutput[];
-    outputs: SignInputOutput[];
-}
-export interface SendData extends Msg {
-    inputs: InputOutput[];
-    outputs: InputOutput[];
-    aminoPrefix: AminoPrefix;
-}
-/**
- * @ignore
- * Only support transfers of one-to-one, one-to-many
- */
-export declare class SendMsg extends BaseMsg {
-    private sender;
-    private outputs;
-    readonly aminoPrefix: AminoPrefix;
-    constructor(sender: string, outputs: SignInputOutput[]);
-    calInputCoins(inputsCoins: Coin[], coins: Coin[]): void;
-    getSignMsg(): SignedSend;
-    getMsg(): SendData;
-    static defaultMsg(): {
-        inputs: {
-            address: Buffer;
-            coins: {
-                denom: string;
-                amount: number;
-            }[];
-        }[];
-        outputs: {
-            address: Buffer;
-            coins: {
-                denom: string;
-                amount: number;
-            }[];
-        }[];
-        aminoPrefix: AminoPrefix;
-    };
-}
-export {};
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/send.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/send.js
deleted file mode 100644
index 337d861..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/send.js
+++ /dev/null
@@ -1,146 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.SendMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var crypto = _interopRequireWildcard(require("../../crypto"));
-
-var _tx = require("../tx");
-
-var _ = require("./");
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-/**
- * @ignore
- * Only support transfers of one-to-one, one-to-many
- */
-var SendMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(SendMsg, _BaseMsg);
-
-  var _super = _createSuper(SendMsg);
-
-  function SendMsg(sender, outputs) {
-    var _this;
-
-    (0, _classCallCheck2["default"])(this, SendMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "sender", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "outputs", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "aminoPrefix", _tx.AminoPrefix.MsgSend);
-    _this.sender = sender;
-    _this.outputs = outputs;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(SendMsg, [{
-    key: "calInputCoins",
-    value: function calInputCoins(inputsCoins, coins) {
-      coins.forEach(function (coin) {
-        var existCoin = inputsCoins.find(function (c) {
-          return c.denom === coin.denom;
-        });
-
-        if (existCoin) {
-          var existAmount = new _big["default"](existCoin.amount);
-          existCoin.amount = Number(existAmount.plus(coin.amount).toString());
-        } else {
-          inputsCoins.push(_objectSpread({}, coin));
-        }
-      });
-    }
-  }, {
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var _this2 = this;
-
-      var signMsg = {
-        inputs: [{
-          address: this.sender,
-          coins: []
-        }],
-        outputs: this.outputs
-      };
-      this.outputs.forEach(function (item) {
-        _this2.calInputCoins(signMsg.inputs[0].coins, item.coins);
-      });
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var _this3 = this;
-
-      var msg = {
-        inputs: [{
-          address: crypto.decodeAddress(this.sender),
-          coins: []
-        }],
-        outputs: [],
-        aminoPrefix: this.aminoPrefix
-      };
-      this.outputs.forEach(function (item) {
-        _this3.calInputCoins(msg.inputs[0].coins, item.coins);
-
-        var output = {
-          address: crypto.decodeAddress(item.address),
-          coins: item.coins
-        };
-        msg.outputs.push(output);
-      });
-      return msg;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        inputs: [{
-          address: Buffer.from(""),
-          coins: [{
-            denom: "",
-            amount: 0
-          }]
-        }],
-        outputs: [{
-          address: Buffer.from(""),
-          coins: [{
-            denom: "",
-            amount: 0
-          }]
-        }],
-        aminoPrefix: _tx.AminoPrefix.MsgSend
-      };
-    }
-  }]);
-  return SendMsg;
-}(_.BaseMsg);
-
-exports.SendMsg = SendMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscDelegateMsg.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscDelegateMsg.d.ts
deleted file mode 100644
index d57d848..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscDelegateMsg.d.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg, Coin } from "..";
-import { AminoPrefix } from "../../tx";
-export interface SignedBscDelegate extends SignMsg {
-    delegator_addr: string;
-    validator_addr: string;
-    delegation: Coin;
-    side_chain_id: string;
-}
-export interface BscDelegateData extends Msg {
-    delegator_addr: Buffer;
-    validator_addr: Buffer;
-    delegation: Coin;
-    side_chain_id: string;
-    aminoPrefix: AminoPrefix;
-}
-export declare class BscDelegateMsg extends BaseMsg {
-    private delegator_addr;
-    private validator_addr;
-    private delegation;
-    private side_chain_id;
-    constructor({ delegator_addr, validator_addr, delegation, side_chain_id, }: {
-        delegator_addr: string;
-        validator_addr: string;
-        delegation: Coin;
-        side_chain_id: string;
-    });
-    getSignMsg(): {
-        type: string;
-        value: SignedBscDelegate;
-    };
-    getMsg(): BscDelegateData;
-    static defaultMsg(): {
-        delegator_addr: Buffer;
-        validator_addr: Buffer;
-        delegation: {
-            denom: string;
-            amount: number;
-        }[];
-        side_chain_id: string;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscDelegateMsg.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscDelegateMsg.js
deleted file mode 100644
index b33a6e5..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscDelegateMsg.js
+++ /dev/null
@@ -1,111 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BscDelegateMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("..");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var BscDelegateMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(BscDelegateMsg, _BaseMsg);
-
-  var _super = _createSuper(BscDelegateMsg);
-
-  function BscDelegateMsg(_ref) {
-    var _this;
-
-    var delegator_addr = _ref.delegator_addr,
-        validator_addr = _ref.validator_addr,
-        delegation = _ref.delegation,
-        side_chain_id = _ref.side_chain_id;
-    (0, _classCallCheck2["default"])(this, BscDelegateMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "delegator_addr", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "validator_addr", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "delegation", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "side_chain_id", void 0);
-    _this.delegator_addr = delegator_addr;
-    _this.validator_addr = validator_addr;
-    _this.delegation = delegation;
-    _this.side_chain_id = side_chain_id;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(BscDelegateMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var _this$delegation = this.delegation,
-          denom = _this$delegation.denom,
-          amount = _this$delegation.amount;
-      var signMsg = {
-        delegator_addr: this.delegator_addr,
-        validator_addr: this.validator_addr,
-        delegation: {
-          denom: denom,
-          amount: String(amount)
-        },
-        side_chain_id: this.side_chain_id
-      };
-      return {
-        type: "cosmos-sdk/MsgSideChainDelegate",
-        value: signMsg
-      };
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        delegator_addr: crypto.decodeAddress(this.delegator_addr),
-        validator_addr: crypto.decodeAddress(this.validator_addr),
-        delegation: this.delegation,
-        side_chain_id: this.side_chain_id,
-        aminoPrefix: _tx.AminoPrefix.MsgSideChainDelegate
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        delegator_addr: Buffer.from(""),
-        validator_addr: Buffer.from(""),
-        delegation: [{
-          denom: "",
-          amount: 0
-        }],
-        side_chain_id: "",
-        aminoPrefix: _tx.AminoPrefix.MsgSideChainDelegate
-      };
-    }
-  }]);
-  return BscDelegateMsg;
-}(_.BaseMsg);
-
-exports.BscDelegateMsg = BscDelegateMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscRedelegateMsg.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscRedelegateMsg.d.ts
deleted file mode 100644
index e5e42e3..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscRedelegateMsg.d.ts
+++ /dev/null
@@ -1,48 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg, Coin } from "..";
-import { AminoPrefix } from "../../tx";
-export interface SignedBscReDelegate extends SignMsg {
-    delegator_addr: string;
-    validator_src_addr: string;
-    validator_dst_addr: string;
-    amount: Coin;
-    side_chain_id: string;
-}
-export interface BscReDelegateData extends Msg {
-    delegator_addr: Buffer;
-    validator_src_addr: Buffer;
-    validator_dst_addr: Buffer;
-    amount: Coin;
-    side_chain_id: string;
-    aminoPrefix: AminoPrefix;
-}
-export declare class BscReDelegateMsg extends BaseMsg {
-    private delegator_addr;
-    private validator_src_addr;
-    private validator_dst_addr;
-    private amount;
-    private side_chain_id;
-    constructor({ delegator_addr, validator_src_addr, validator_dst_addr, amount, side_chain_id, }: {
-        delegator_addr: string;
-        validator_src_addr: string;
-        validator_dst_addr: string;
-        amount: Coin;
-        side_chain_id: string;
-    });
-    getSignMsg(): {
-        type: string;
-        value: SignedBscReDelegate;
-    };
-    getMsg(): BscReDelegateData;
-    static defaultMsg(): {
-        delegator_addr: Buffer;
-        validator_src_addr: Buffer;
-        validator_dst_addr: Buffer;
-        amount: {
-            denom: string;
-            amount: number;
-        }[];
-        side_chain_id: string;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscRedelegateMsg.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscRedelegateMsg.js
deleted file mode 100644
index d499100..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscRedelegateMsg.js
+++ /dev/null
@@ -1,117 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BscReDelegateMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("..");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var BscReDelegateMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(BscReDelegateMsg, _BaseMsg);
-
-  var _super = _createSuper(BscReDelegateMsg);
-
-  function BscReDelegateMsg(_ref) {
-    var _this;
-
-    var delegator_addr = _ref.delegator_addr,
-        validator_src_addr = _ref.validator_src_addr,
-        validator_dst_addr = _ref.validator_dst_addr,
-        amount = _ref.amount,
-        side_chain_id = _ref.side_chain_id;
-    (0, _classCallCheck2["default"])(this, BscReDelegateMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "delegator_addr", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "validator_src_addr", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "validator_dst_addr", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "side_chain_id", void 0);
-    _this.delegator_addr = delegator_addr;
-    _this.validator_src_addr = validator_src_addr;
-    _this.validator_dst_addr = validator_dst_addr;
-    _this.amount = amount;
-    _this.side_chain_id = side_chain_id;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(BscReDelegateMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var _this$amount = this.amount,
-          denom = _this$amount.denom,
-          amount = _this$amount.amount;
-      var signMsg = {
-        delegator_addr: this.delegator_addr,
-        validator_src_addr: this.validator_src_addr,
-        validator_dst_addr: this.validator_dst_addr,
-        amount: {
-          denom: denom,
-          amount: String(amount)
-        },
-        side_chain_id: this.side_chain_id
-      };
-      return {
-        type: "cosmos-sdk/MsgSideChainRedelegate",
-        value: signMsg
-      };
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        delegator_addr: crypto.decodeAddress(this.delegator_addr),
-        validator_src_addr: crypto.decodeAddress(this.validator_src_addr),
-        validator_dst_addr: crypto.decodeAddress(this.validator_dst_addr),
-        amount: this.amount,
-        side_chain_id: this.side_chain_id,
-        aminoPrefix: _tx.AminoPrefix.MsgSideChainRedelegate
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        delegator_addr: Buffer.from(""),
-        validator_src_addr: Buffer.from(""),
-        validator_dst_addr: Buffer.from(""),
-        amount: [{
-          denom: "",
-          amount: 0
-        }],
-        side_chain_id: "",
-        aminoPrefix: _tx.AminoPrefix.MsgSideChainRedelegate
-      };
-    }
-  }]);
-  return BscReDelegateMsg;
-}(_.BaseMsg);
-
-exports.BscReDelegateMsg = BscReDelegateMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscUndelegateMsg.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscUndelegateMsg.d.ts
deleted file mode 100644
index 76335fb..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscUndelegateMsg.d.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg, Coin } from "..";
-import { AminoPrefix } from "../../tx";
-export interface SignedBscUndelegate extends SignMsg {
-    delegator_addr: string;
-    validator_addr: string;
-    amount: Coin;
-    side_chain_id: string;
-}
-export interface BscUndelegateData extends Msg {
-    delegator_addr: Buffer;
-    validator_addr: Buffer;
-    amount: Coin;
-    side_chain_id: string;
-    aminoPrefix: AminoPrefix;
-}
-export declare class BscUndelegateMsg extends BaseMsg {
-    private delegator_addr;
-    private validator_addr;
-    private amount;
-    private side_chain_id;
-    constructor({ delegator_addr, validator_addr, amount, side_chain_id, }: {
-        delegator_addr: string;
-        validator_addr: string;
-        amount: Coin;
-        side_chain_id: string;
-    });
-    getSignMsg(): {
-        type: string;
-        value: SignedBscUndelegate;
-    };
-    getMsg(): BscUndelegateData;
-    static defaultMsg(): {
-        delegator_addr: Buffer;
-        validator_addr: Buffer;
-        amount: {
-            denom: string;
-            amount: number;
-        }[];
-        side_chain_id: string;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscUndelegateMsg.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscUndelegateMsg.js
deleted file mode 100644
index 657eb0d..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/bscUndelegateMsg.js
+++ /dev/null
@@ -1,111 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BscUndelegateMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("..");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var BscUndelegateMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(BscUndelegateMsg, _BaseMsg);
-
-  var _super = _createSuper(BscUndelegateMsg);
-
-  function BscUndelegateMsg(_ref) {
-    var _this;
-
-    var delegator_addr = _ref.delegator_addr,
-        validator_addr = _ref.validator_addr,
-        amount = _ref.amount,
-        side_chain_id = _ref.side_chain_id;
-    (0, _classCallCheck2["default"])(this, BscUndelegateMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "delegator_addr", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "validator_addr", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "side_chain_id", void 0);
-    _this.delegator_addr = delegator_addr;
-    _this.validator_addr = validator_addr;
-    _this.amount = amount;
-    _this.side_chain_id = side_chain_id;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(BscUndelegateMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var _this$amount = this.amount,
-          denom = _this$amount.denom,
-          amount = _this$amount.amount;
-      var signMsg = {
-        delegator_addr: this.delegator_addr,
-        validator_addr: this.validator_addr,
-        amount: {
-          denom: denom,
-          amount: String(amount)
-        },
-        side_chain_id: this.side_chain_id
-      };
-      return {
-        type: "cosmos-sdk/MsgSideChainUndelegate",
-        value: signMsg
-      };
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        delegator_addr: crypto.decodeAddress(this.delegator_addr),
-        validator_addr: crypto.decodeAddress(this.validator_addr),
-        amount: this.amount,
-        side_chain_id: this.side_chain_id,
-        aminoPrefix: _tx.AminoPrefix.MsgSideChainUndelegate
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        delegator_addr: Buffer.from(""),
-        validator_addr: Buffer.from(""),
-        amount: [{
-          denom: "",
-          amount: 0
-        }],
-        side_chain_id: "",
-        aminoPrefix: _tx.AminoPrefix.MsgSideChainUndelegate
-      };
-    }
-  }]);
-  return BscUndelegateMsg;
-}(_.BaseMsg);
-
-exports.BscUndelegateMsg = BscUndelegateMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/index.d.ts
deleted file mode 100644
index d2a9064..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/index.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-export * from "./bscDelegateMsg";
-export * from "./bscUndelegateMsg";
-export * from "./bscRedelegateMsg";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/index.js
deleted file mode 100644
index 723e69d..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/stake/index.js
+++ /dev/null
@@ -1,41 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _bscDelegateMsg = require("./bscDelegateMsg");
-
-Object.keys(_bscDelegateMsg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _bscDelegateMsg[key];
-    }
-  });
-});
-
-var _bscUndelegateMsg = require("./bscUndelegateMsg");
-
-Object.keys(_bscUndelegateMsg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _bscUndelegateMsg[key];
-    }
-  });
-});
-
-var _bscRedelegateMsg = require("./bscRedelegateMsg");
-
-Object.keys(_bscRedelegateMsg).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _bscRedelegateMsg[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/burnToken.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/burnToken.d.ts
deleted file mode 100644
index f65aa5b..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/burnToken.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedBurnToken extends SignMsg {
-    from: string;
-    symbol: string;
-    amount: number;
-}
-export interface BurnTokenData extends Msg {
-    from: Buffer;
-    symbol: string;
-    amount: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class BurnTokenMsg extends BaseMsg {
-    private from;
-    private symbol;
-    private amount;
-    constructor({ address, sybmol, amount, }: {
-        address: string;
-        sybmol: string;
-        amount: number;
-    });
-    getSignMsg(): SignedBurnToken;
-    getMsg(): BurnTokenData;
-    static defaultMsg(): {
-        from: Buffer;
-        symbol: string;
-        amount: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/burnToken.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/burnToken.js
deleted file mode 100644
index c53e345..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/burnToken.js
+++ /dev/null
@@ -1,93 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.BurnTokenMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var BurnTokenMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(BurnTokenMsg, _BaseMsg);
-
-  var _super = _createSuper(BurnTokenMsg);
-
-  function BurnTokenMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        sybmol = _ref.sybmol,
-        amount = _ref.amount;
-    (0, _classCallCheck2["default"])(this, BurnTokenMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    _this.from = address;
-    _this.symbol = sybmol;
-    _this.amount = amount;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(BurnTokenMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        symbol: this.symbol,
-        amount: this.amount
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        symbol: this.symbol,
-        amount: this.amount,
-        aminoPrefix: _tx.AminoPrefix.BurnMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        symbol: "",
-        amount: 0,
-        aminoPrefix: _tx.AminoPrefix.BurnMsg
-      };
-    }
-  }]);
-  return BurnTokenMsg;
-}(_.BaseMsg);
-
-exports.BurnTokenMsg = BurnTokenMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/freezeToken.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/freezeToken.d.ts
deleted file mode 100644
index 3393e3c..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/freezeToken.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedFreezeToken extends SignMsg {
-    from: string;
-    symbol: string;
-    amount: number;
-}
-export interface FreezeTokenData extends Msg {
-    from: Buffer;
-    symbol: string;
-    amount: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class FreezeTokenMsg extends BaseMsg {
-    private from;
-    private symbol;
-    private amount;
-    constructor({ address, sybmol, amount, }: {
-        address: string;
-        sybmol: string;
-        amount: number;
-    });
-    getSignMsg(): SignedFreezeToken;
-    getMsg(): FreezeTokenData;
-    static defaultMsg(): {
-        from: Buffer;
-        symbol: string;
-        amount: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/freezeToken.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/freezeToken.js
deleted file mode 100644
index 75c0d45..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/freezeToken.js
+++ /dev/null
@@ -1,93 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.FreezeTokenMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var FreezeTokenMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(FreezeTokenMsg, _BaseMsg);
-
-  var _super = _createSuper(FreezeTokenMsg);
-
-  function FreezeTokenMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        sybmol = _ref.sybmol,
-        amount = _ref.amount;
-    (0, _classCallCheck2["default"])(this, FreezeTokenMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    _this.from = address;
-    _this.symbol = sybmol;
-    _this.amount = amount;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(FreezeTokenMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        symbol: this.symbol,
-        amount: this.amount
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        symbol: this.symbol,
-        amount: this.amount,
-        aminoPrefix: _tx.AminoPrefix.FreezeMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        symbol: "",
-        amount: 0,
-        aminoPrefix: _tx.AminoPrefix.FreezeMsg
-      };
-    }
-  }]);
-  return FreezeTokenMsg;
-}(_.BaseMsg);
-
-exports.FreezeTokenMsg = FreezeTokenMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/index.d.ts
deleted file mode 100644
index e1770cd..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/index.d.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-export * from "./burnToken";
-export * from "./freezeToken";
-export * from "./unFreezeToken";
-export * from "./issueToken";
-export * from "./mintToken";
-export * from "./timelock";
-export * from "./timeRelock";
-export * from "./timeUnlock";
-export * from "./issueMiniToken";
-export * from "./issueTinyToken";
-export * from "./setTokenUri";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/index.js
deleted file mode 100644
index a0ae2f7..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/index.js
+++ /dev/null
@@ -1,137 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _burnToken = require("./burnToken");
-
-Object.keys(_burnToken).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _burnToken[key];
-    }
-  });
-});
-
-var _freezeToken = require("./freezeToken");
-
-Object.keys(_freezeToken).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _freezeToken[key];
-    }
-  });
-});
-
-var _unFreezeToken = require("./unFreezeToken");
-
-Object.keys(_unFreezeToken).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _unFreezeToken[key];
-    }
-  });
-});
-
-var _issueToken = require("./issueToken");
-
-Object.keys(_issueToken).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _issueToken[key];
-    }
-  });
-});
-
-var _mintToken = require("./mintToken");
-
-Object.keys(_mintToken).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _mintToken[key];
-    }
-  });
-});
-
-var _timelock = require("./timelock");
-
-Object.keys(_timelock).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _timelock[key];
-    }
-  });
-});
-
-var _timeRelock = require("./timeRelock");
-
-Object.keys(_timeRelock).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _timeRelock[key];
-    }
-  });
-});
-
-var _timeUnlock = require("./timeUnlock");
-
-Object.keys(_timeUnlock).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _timeUnlock[key];
-    }
-  });
-});
-
-var _issueMiniToken = require("./issueMiniToken");
-
-Object.keys(_issueMiniToken).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _issueMiniToken[key];
-    }
-  });
-});
-
-var _issueTinyToken = require("./issueTinyToken");
-
-Object.keys(_issueTinyToken).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _issueTinyToken[key];
-    }
-  });
-});
-
-var _setTokenUri = require("./setTokenUri");
-
-Object.keys(_setTokenUri).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _setTokenUri[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueMiniToken.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueMiniToken.d.ts
deleted file mode 100644
index 98fc192..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueMiniToken.d.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedIssueMiniTokenMsg extends SignMsg {
-    name: string;
-    symbol: string;
-    total_supply: number;
-    mintable: boolean;
-    from: string;
-    token_uri: string | undefined;
-}
-export interface IssueMiniTokenData extends Msg {
-    name: string;
-    symbol: string;
-    total_supply: number;
-    mintable: boolean;
-    from: Buffer;
-    token_uri: string | undefined;
-    aminoPrefix: AminoPrefix;
-}
-export declare class IssueMiniTokenMsg extends BaseMsg {
-    private params;
-    constructor(params: SignedIssueMiniTokenMsg);
-    getSignMsg(): SignedIssueMiniTokenMsg;
-    getMsg(): IssueMiniTokenData;
-    static defaultMsg(): {
-        from: typeof Buffer.from;
-        name: string;
-        symbol: string;
-        total_supply: number;
-        mintable: boolean;
-        token_uri: string;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueMiniToken.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueMiniToken.js
deleted file mode 100644
index 82bb630..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueMiniToken.js
+++ /dev/null
@@ -1,93 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.IssueMiniTokenMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var IssueMiniTokenMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(IssueMiniTokenMsg, _BaseMsg);
-
-  var _super = _createSuper(IssueMiniTokenMsg);
-
-  function IssueMiniTokenMsg(params) {
-    var _this;
-
-    (0, _classCallCheck2["default"])(this, IssueMiniTokenMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "params", void 0);
-    _this.params = params;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(IssueMiniTokenMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = _objectSpread({}, this.params);
-
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.params.from),
-        name: this.params.name,
-        symbol: this.params.symbol,
-        total_supply: this.params.total_supply,
-        mintable: this.params.mintable,
-        token_uri: this.params.token_uri,
-        aminoPrefix: _tx.AminoPrefix.IssueMiniMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from,
-        name: "",
-        symbol: "",
-        total_supply: 0,
-        mintable: false,
-        token_uri: "",
-        aminoPrefix: _tx.AminoPrefix.IssueMiniMsg
-      };
-    }
-  }]);
-  return IssueMiniTokenMsg;
-}(_.BaseMsg);
-
-exports.IssueMiniTokenMsg = IssueMiniTokenMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueTinyToken.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueTinyToken.d.ts
deleted file mode 100644
index 1d1d640..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueTinyToken.d.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedIssueTinyTokenMsg extends SignMsg {
-    name: string;
-    symbol: string;
-    total_supply: number;
-    mintable: boolean;
-    from: string;
-    token_uri: string | undefined;
-}
-export interface IssueTinyTokenData extends Msg {
-    name: string;
-    symbol: string;
-    total_supply: number;
-    mintable: boolean;
-    from: Buffer;
-    token_uri: string | undefined;
-    aminoPrefix: AminoPrefix;
-}
-export declare class IssueTinyTokenMsg extends BaseMsg {
-    private params;
-    constructor(params: SignedIssueTinyTokenMsg);
-    getSignMsg(): SignedIssueTinyTokenMsg;
-    getMsg(): IssueTinyTokenData;
-    static defaultMsg(): {
-        from: typeof Buffer.from;
-        name: string;
-        symbol: string;
-        total_supply: number;
-        mintable: boolean;
-        token_uri: string;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueTinyToken.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueTinyToken.js
deleted file mode 100644
index aadf6d4..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueTinyToken.js
+++ /dev/null
@@ -1,93 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.IssueTinyTokenMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var IssueTinyTokenMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(IssueTinyTokenMsg, _BaseMsg);
-
-  var _super = _createSuper(IssueTinyTokenMsg);
-
-  function IssueTinyTokenMsg(params) {
-    var _this;
-
-    (0, _classCallCheck2["default"])(this, IssueTinyTokenMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "params", void 0);
-    _this.params = params;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(IssueTinyTokenMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = _objectSpread({}, this.params);
-
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.params.from),
-        name: this.params.name,
-        symbol: this.params.symbol,
-        total_supply: this.params.total_supply,
-        mintable: this.params.mintable,
-        token_uri: this.params.token_uri,
-        aminoPrefix: _tx.AminoPrefix.IssueTinyMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from,
-        name: "",
-        symbol: "",
-        total_supply: 0,
-        mintable: false,
-        token_uri: "",
-        aminoPrefix: _tx.AminoPrefix.IssueTinyMsg
-      };
-    }
-  }]);
-  return IssueTinyTokenMsg;
-}(_.BaseMsg);
-
-exports.IssueTinyTokenMsg = IssueTinyTokenMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueToken.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueToken.d.ts
deleted file mode 100644
index 573290d..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueToken.d.ts
+++ /dev/null
@@ -1,31 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface IssueParams {
-    name: string;
-    symbol: string;
-    total_supply: number;
-    mintable: boolean;
-}
-export interface SignedIssueTokenMsg extends SignMsg, IssueParams {
-    from: string;
-}
-export interface IssueTokenData extends Msg, IssueParams {
-    from: Buffer;
-    aminoPrefix: AminoPrefix;
-}
-export declare class IssueTokenMsg extends BaseMsg {
-    private from;
-    private params;
-    constructor(params: IssueParams, address: string);
-    getSignMsg(): SignedIssueTokenMsg;
-    getMsg(): IssueTokenData;
-    static defaultMsg(): {
-        from: typeof Buffer.from;
-        name: string;
-        symbol: string;
-        total_supply: number;
-        mintable: boolean;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueToken.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueToken.js
deleted file mode 100644
index b4dca8d..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/issueToken.js
+++ /dev/null
@@ -1,95 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.IssueTokenMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var IssueTokenMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(IssueTokenMsg, _BaseMsg);
-
-  var _super = _createSuper(IssueTokenMsg);
-
-  function IssueTokenMsg(params, address) {
-    var _this;
-
-    (0, _classCallCheck2["default"])(this, IssueTokenMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "params", void 0);
-    _this.from = address;
-    _this.params = params;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(IssueTokenMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = _objectSpread({
-        from: this.from
-      }, this.params);
-
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        name: this.params.name,
-        symbol: this.params.symbol,
-        total_supply: this.params.total_supply,
-        mintable: this.params.mintable,
-        aminoPrefix: _tx.AminoPrefix.IssueMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from,
-        name: "",
-        symbol: "",
-        total_supply: 0,
-        mintable: false,
-        aminoPrefix: _tx.AminoPrefix.IssueMsg
-      };
-    }
-  }]);
-  return IssueTokenMsg;
-}(_.BaseMsg);
-
-exports.IssueTokenMsg = IssueTokenMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/mintToken.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/mintToken.d.ts
deleted file mode 100644
index 8bbb0a1..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/mintToken.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedMintTokenMsg extends SignMsg {
-    from: string;
-    symbol: string;
-    amount: number;
-}
-export interface MintTokenData extends Msg {
-    from: Buffer;
-    symbol: string;
-    amount: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class MintTokenMsg extends BaseMsg {
-    private from;
-    private symbol;
-    private amount;
-    constructor({ address, sybmol, amount, }: {
-        address: string;
-        sybmol: string;
-        amount: number;
-    });
-    getSignMsg(): SignedMintTokenMsg;
-    getMsg(): MintTokenData;
-    static defaultMsg(): {
-        from: Buffer;
-        symbol: string;
-        amount: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/mintToken.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/mintToken.js
deleted file mode 100644
index 203e5e8..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/mintToken.js
+++ /dev/null
@@ -1,95 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.MintTokenMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var MintTokenMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(MintTokenMsg, _BaseMsg);
-
-  var _super = _createSuper(MintTokenMsg);
-
-  function MintTokenMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        sybmol = _ref.sybmol,
-        amount = _ref.amount;
-    (0, _classCallCheck2["default"])(this, MintTokenMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    _this.from = address;
-    _this.symbol = sybmol;
-    _this.amount = amount;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(MintTokenMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        amount: Number(new _big["default"](this.amount).mul(Math.pow(10, 8)).toString()),
-        symbol: this.symbol
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        symbol: this.symbol,
-        amount: Number(new _big["default"](this.amount).mul(Math.pow(10, 8)).toString()),
-        aminoPrefix: _tx.AminoPrefix.MintMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        symbol: "",
-        amount: 0,
-        aminoPrefix: _tx.AminoPrefix.MintMsg
-      };
-    }
-  }]);
-  return MintTokenMsg;
-}(_.BaseMsg);
-
-exports.MintTokenMsg = MintTokenMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/setTokenUri.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/setTokenUri.d.ts
deleted file mode 100644
index 5f1067a..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/setTokenUri.d.ts
+++ /dev/null
@@ -1,28 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedSetUri extends SignMsg {
-    from: string;
-    symbol: string;
-    token_uri: string;
-}
-export interface SetUriData extends Msg {
-    from: Buffer;
-    symbol: string;
-    token_uri: string;
-    aminoPrefix: AminoPrefix;
-}
-export declare class SetTokenUriMsg extends BaseMsg {
-    private from;
-    private symbol;
-    private token_uri;
-    constructor({ from, symbol, token_uri }: SignedSetUri);
-    getSignMsg(): SignedSetUri;
-    getMsg(): SetUriData;
-    static defaultMsg(): {
-        from: Buffer;
-        symbol: string;
-        token_uri: string;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/setTokenUri.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/setTokenUri.js
deleted file mode 100644
index f8c246b..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/setTokenUri.js
+++ /dev/null
@@ -1,93 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.SetTokenUriMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var SetTokenUriMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(SetTokenUriMsg, _BaseMsg);
-
-  var _super = _createSuper(SetTokenUriMsg);
-
-  function SetTokenUriMsg(_ref) {
-    var _this;
-
-    var from = _ref.from,
-        symbol = _ref.symbol,
-        token_uri = _ref.token_uri;
-    (0, _classCallCheck2["default"])(this, SetTokenUriMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "token_uri", void 0);
-    _this.from = from;
-    _this.symbol = symbol;
-    _this.token_uri = token_uri;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(SetTokenUriMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        symbol: this.symbol,
-        token_uri: this.token_uri
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        symbol: this.symbol,
-        token_uri: this.token_uri,
-        aminoPrefix: _tx.AminoPrefix.SetURIMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        symbol: "",
-        token_uri: "",
-        aminoPrefix: _tx.AminoPrefix.SetURIMsg
-      };
-    }
-  }]);
-  return SetTokenUriMsg;
-}(_.BaseMsg);
-
-exports.SetTokenUriMsg = SetTokenUriMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeRelock.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeRelock.d.ts
deleted file mode 100644
index d4cfff9..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeRelock.d.ts
+++ /dev/null
@@ -1,41 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg, Coin } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedTimeReLockMsg extends SignMsg {
-    from: string;
-    time_lock_id: number;
-    description: string;
-    amount: Coin[];
-    lock_time: number;
-}
-export interface TimeReLockData extends Msg {
-    from: Buffer;
-    time_lock_id: number;
-    description: string;
-    amount: Coin[];
-    lock_time: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class TimeReLockMsg extends BaseMsg {
-    private from;
-    private time_lock_id;
-    private description;
-    private lock_time;
-    private amount;
-    constructor({ address, time_lock_id, description, amount, lock_time, }: {
-        address: string;
-        time_lock_id: number;
-        description: string;
-        amount: Coin[];
-        lock_time: number;
-    });
-    getSignMsg(): SignedTimeReLockMsg;
-    getMsg(): TimeReLockData;
-    static defaultMsg(): {
-        from: Buffer;
-        description: string;
-        amount: number;
-        lock_time: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeRelock.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeRelock.js
deleted file mode 100644
index 7dda482..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeRelock.js
+++ /dev/null
@@ -1,104 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.TimeReLockMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var TimeReLockMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(TimeReLockMsg, _BaseMsg);
-
-  var _super = _createSuper(TimeReLockMsg);
-
-  function TimeReLockMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        time_lock_id = _ref.time_lock_id,
-        description = _ref.description,
-        amount = _ref.amount,
-        lock_time = _ref.lock_time;
-    (0, _classCallCheck2["default"])(this, TimeReLockMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "time_lock_id", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "description", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "lock_time", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    _this.from = address;
-    _this.description = description;
-    _this.amount = amount;
-    _this.lock_time = lock_time;
-    _this.time_lock_id = time_lock_id;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(TimeReLockMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        time_lock_id: this.time_lock_id,
-        amount: this.amount,
-        description: this.description,
-        lock_time: this.lock_time
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        time_lock_id: this.time_lock_id,
-        description: this.description,
-        amount: this.amount,
-        lock_time: this.lock_time,
-        aminoPrefix: _tx.AminoPrefix.TimeRelockMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        description: "",
-        amount: 0,
-        lock_time: 0,
-        aminoPrefix: _tx.AminoPrefix.TimeRelockMsg
-      };
-    }
-  }]);
-  return TimeReLockMsg;
-}(_.BaseMsg);
-
-exports.TimeReLockMsg = TimeReLockMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeUnlock.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeUnlock.d.ts
deleted file mode 100644
index 7438ff7..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeUnlock.d.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedTimeUnlockMsg extends SignMsg {
-    from: string;
-    time_lock_id: number;
-}
-export interface TimeUnlockData extends Msg {
-    from: Buffer;
-    time_lock_id: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class TimeUnlockMsg extends BaseMsg {
-    private from;
-    private time_lock_id;
-    constructor({ address, time_lock_id, }: {
-        address: string;
-        time_lock_id: number;
-    });
-    getSignMsg(): SignedTimeUnlockMsg;
-    getMsg(): TimeUnlockData;
-    static defaultMsg(): {
-        from: Buffer;
-        time_lock_id: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeUnlock.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeUnlock.js
deleted file mode 100644
index 264ad7d..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timeUnlock.js
+++ /dev/null
@@ -1,87 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.TimeUnlockMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var TimeUnlockMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(TimeUnlockMsg, _BaseMsg);
-
-  var _super = _createSuper(TimeUnlockMsg);
-
-  function TimeUnlockMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        time_lock_id = _ref.time_lock_id;
-    (0, _classCallCheck2["default"])(this, TimeUnlockMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "time_lock_id", void 0);
-    _this.from = address;
-    _this.time_lock_id = time_lock_id;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(TimeUnlockMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        time_lock_id: this.time_lock_id
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        time_lock_id: this.time_lock_id,
-        aminoPrefix: _tx.AminoPrefix.TimeUnlockMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        time_lock_id: 0,
-        aminoPrefix: _tx.AminoPrefix.TimeUnlockMsg
-      };
-    }
-  }]);
-  return TimeUnlockMsg;
-}(_.BaseMsg);
-
-exports.TimeUnlockMsg = TimeUnlockMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timelock.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timelock.d.ts
deleted file mode 100644
index 1918f30..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timelock.d.ts
+++ /dev/null
@@ -1,40 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg, Coin } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedTimeLockMsg extends SignMsg {
-    from: string;
-    description: string;
-    amount: Coin[];
-    lock_time: number;
-}
-export interface TimeLockData extends Msg {
-    from: Buffer;
-    description: string;
-    amount: Coin[];
-    lock_time: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class TimeLockMsg extends BaseMsg {
-    private from;
-    private description;
-    private lock_time;
-    private amount;
-    constructor({ address, description, amount, lock_time, }: {
-        address: string;
-        description: string;
-        amount: Coin[];
-        lock_time: number;
-    });
-    getSignMsg(): SignedTimeLockMsg;
-    getMsg(): TimeLockData;
-    static defaultMsg(): {
-        from: Buffer;
-        description: string;
-        amount: {
-            denom: string;
-            amount: number;
-        }[];
-        lock_time: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timelock.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timelock.js
deleted file mode 100644
index 47db4f0..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/timelock.js
+++ /dev/null
@@ -1,102 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.TimeLockMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var TimeLockMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(TimeLockMsg, _BaseMsg);
-
-  var _super = _createSuper(TimeLockMsg);
-
-  function TimeLockMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        description = _ref.description,
-        amount = _ref.amount,
-        lock_time = _ref.lock_time;
-    (0, _classCallCheck2["default"])(this, TimeLockMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "description", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "lock_time", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    _this.from = address;
-    _this.description = description;
-    _this.amount = amount;
-    _this.lock_time = lock_time;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(TimeLockMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        amount: this.amount,
-        description: this.description,
-        lock_time: this.lock_time
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        description: this.description,
-        amount: this.amount,
-        lock_time: this.lock_time,
-        aminoPrefix: _tx.AminoPrefix.TimeLockMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        description: "",
-        amount: [{
-          denom: "",
-          amount: 0
-        }],
-        lock_time: 0,
-        aminoPrefix: _tx.AminoPrefix.TimeLockMsg
-      };
-    }
-  }]);
-  return TimeLockMsg;
-}(_.BaseMsg);
-
-exports.TimeLockMsg = TimeLockMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/unFreezeToken.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/unFreezeToken.d.ts
deleted file mode 100644
index 339eb9a..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/unFreezeToken.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg, SignMsg } from "../";
-import { AminoPrefix } from "../../tx";
-export interface SignedUnFreezeToken extends SignMsg {
-    from: string;
-    symbol: string;
-    amount: number;
-}
-export interface UnFreezeTokenData extends Msg {
-    from: Buffer;
-    symbol: string;
-    amount: number;
-    aminoPrefix: AminoPrefix;
-}
-export declare class UnFreezeTokenMsg extends BaseMsg {
-    private from;
-    private symbol;
-    private amount;
-    constructor({ address, sybmol, amount, }: {
-        address: string;
-        sybmol: string;
-        amount: number;
-    });
-    getSignMsg(): SignedUnFreezeToken;
-    getMsg(): UnFreezeTokenData;
-    static defaultMsg(): {
-        from: Buffer;
-        symbol: string;
-        amount: number;
-        aminoPrefix: AminoPrefix;
-    };
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/unFreezeToken.js b/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/unFreezeToken.js
deleted file mode 100644
index efd259b..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/msg/token/unFreezeToken.js
+++ /dev/null
@@ -1,93 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.UnFreezeTokenMsg = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _ = require("../");
-
-var crypto = _interopRequireWildcard(require("../../../crypto"));
-
-var _tx = require("../../tx");
-
-function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
-
-function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
-
-var UnFreezeTokenMsg = /*#__PURE__*/function (_BaseMsg) {
-  (0, _inherits2["default"])(UnFreezeTokenMsg, _BaseMsg);
-
-  var _super = _createSuper(UnFreezeTokenMsg);
-
-  function UnFreezeTokenMsg(_ref) {
-    var _this;
-
-    var address = _ref.address,
-        sybmol = _ref.sybmol,
-        amount = _ref.amount;
-    (0, _classCallCheck2["default"])(this, UnFreezeTokenMsg);
-    _this = _super.call(this);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "from", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "symbol", void 0);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "amount", void 0);
-    _this.from = address;
-    _this.symbol = sybmol;
-    _this.amount = amount;
-    return _this;
-  }
-
-  (0, _createClass2["default"])(UnFreezeTokenMsg, [{
-    key: "getSignMsg",
-    value: function getSignMsg() {
-      var signMsg = {
-        from: this.from,
-        symbol: this.symbol,
-        amount: this.amount
-      };
-      return signMsg;
-    }
-  }, {
-    key: "getMsg",
-    value: function getMsg() {
-      var data = {
-        from: crypto.decodeAddress(this.from),
-        symbol: this.symbol,
-        amount: this.amount,
-        aminoPrefix: _tx.AminoPrefix.UnfreezeMsg
-      };
-      return data;
-    }
-  }], [{
-    key: "defaultMsg",
-    value: function defaultMsg() {
-      return {
-        from: Buffer.from(""),
-        symbol: "",
-        amount: 0,
-        aminoPrefix: _tx.AminoPrefix.UnfreezeMsg
-      };
-    }
-  }]);
-  return UnFreezeTokenMsg;
-}(_.BaseMsg);
-
-exports.UnFreezeTokenMsg = UnFreezeTokenMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/rpc/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/rpc/index.d.ts
deleted file mode 100644
index 6bacb81..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/rpc/index.d.ts
+++ /dev/null
@@ -1,148 +0,0 @@
-/// <reference types="node" />
-import { Coin } from "../msg";
-import { AminoPrefix } from "../tx";
-export declare class Token {
-    aminoPrefix: AminoPrefix;
-    name: string;
-    symbol: string;
-    original_symbol: string;
-    total_supply: number;
-    owner: Buffer;
-    mintable: boolean;
-    constructor(opts?: Partial<{
-        name: string;
-        symbol: string;
-        original_symbol: string;
-        total_supply: number;
-        owner: Buffer;
-        mintable: boolean;
-    }>);
-}
-export declare class TokenOfList {
-    name: string;
-    symbol: string;
-    original_symbol: string;
-    total_supply: number;
-    owner: Buffer;
-    mintable: boolean;
-    constructor(opts?: Partial<{
-        name: string;
-        symbol: string;
-        original_symbol: string;
-        total_supply: number;
-        owner: Buffer;
-        mintable: boolean;
-    }>);
-}
-export declare class BaseAccount {
-    address: Buffer;
-    coins: Coin[];
-    public_key: Buffer;
-    account_number: number;
-    sequence: number;
-    constructor(opts?: Partial<{
-        address: Buffer;
-        coins: Coin[];
-        public_key: Buffer;
-        account_number: number;
-        sequence: number;
-    }>);
-}
-export declare class AppAccount {
-    aminoPrefix: AminoPrefix;
-    base: BaseAccount;
-    name: string;
-    locked: Coin[];
-    frozen: Coin[];
-    constructor(opts?: Partial<{
-        base: BaseAccount;
-        name: string;
-        locked: Coin[];
-        frozen: Coin[];
-    }>);
-}
-export declare class TokenBalance {
-    symbol: string;
-    free: number;
-    locked: number;
-    frozen: number;
-    constructor(opts?: Partial<{
-        symbol: string;
-        free: number;
-        locked: number;
-        frozen: number;
-    }>);
-}
-export declare class OpenOrder {
-    id: string;
-    symbol: string;
-    price: number;
-    quantity: number;
-    cumQty: number;
-    createdHeight: number;
-    createdTimestamp: number;
-    lastUpdatedHeight: number;
-    lastUpdatedTimestamp: number;
-    constructor(opts?: Partial<{
-        id: string;
-        symbol: string;
-        price: number;
-        quantity: number;
-        cumQty: number;
-        createdHeight: number;
-        createdTimestamp: number;
-        lastUpdatedHeight: number;
-        lastUpdatedTimestamp: number;
-    }>);
-}
-export declare class TradingPair {
-    base_asset_symbol: string;
-    quote_asset_symbol: string;
-    list_price: number;
-    tick_size: number;
-    lot_size: number;
-    constructor(opts?: Partial<{
-        base_asset_symbol: string;
-        quote_asset_symbol: string;
-        list_price: number;
-        tick_size: number;
-        lot_size: number;
-    }>);
-}
-export declare class OrderBookLevel {
-    buyQty: number;
-    buyPrice: number;
-    sellQty: number;
-    sellPrice: number;
-    constructor(opts?: Partial<{
-        buyQty: number;
-        buyPrice: number;
-        sellQty: number;
-        sellPrice: number;
-    }>);
-}
-export declare class OrderBook {
-    height: number;
-    levels: OrderBookLevel[];
-    constructor(opts?: Partial<{
-        height: number;
-        levels: OrderBookLevel[];
-    }>);
-}
-export declare class SubmitProposalMsg {
-    aminoPrefix: AminoPrefix;
-    title: string;
-    description: string;
-    proposal_type: number;
-    proposer: Buffer;
-    initial_deposit: number[];
-    voting_period: number;
-    constructor(opts?: Partial<{
-        title: string;
-        description: string;
-        proposal_type: number;
-        proposer: Buffer;
-        initial_deposit: number[];
-        voting_period: number;
-    }>);
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/rpc/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/rpc/index.js
deleted file mode 100644
index 354a47c..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/rpc/index.js
+++ /dev/null
@@ -1,199 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.SubmitProposalMsg = exports.OrderBook = exports.OrderBookLevel = exports.TradingPair = exports.OpenOrder = exports.TokenBalance = exports.AppAccount = exports.BaseAccount = exports.TokenOfList = exports.Token = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _tx = require("../tx");
-
-var Token = function Token() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, Token);
-  (0, _defineProperty2["default"])(this, "aminoPrefix", _tx.AminoPrefix.BnbchainToken);
-  (0, _defineProperty2["default"])(this, "name", void 0);
-  (0, _defineProperty2["default"])(this, "symbol", void 0);
-  (0, _defineProperty2["default"])(this, "original_symbol", void 0);
-  (0, _defineProperty2["default"])(this, "total_supply", void 0);
-  (0, _defineProperty2["default"])(this, "owner", void 0);
-  (0, _defineProperty2["default"])(this, "mintable", void 0);
-  this.name = opts.name || "";
-  this.symbol = opts.symbol || "";
-  this.original_symbol = opts.original_symbol || "";
-  this.total_supply = opts.total_supply || 0;
-  this.owner = opts.owner || Buffer.alloc(0);
-  this.mintable = opts.mintable || false;
-};
-
-exports.Token = Token;
-
-var TokenOfList = function TokenOfList() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, TokenOfList);
-  (0, _defineProperty2["default"])(this, "name", void 0);
-  (0, _defineProperty2["default"])(this, "symbol", void 0);
-  (0, _defineProperty2["default"])(this, "original_symbol", void 0);
-  (0, _defineProperty2["default"])(this, "total_supply", void 0);
-  (0, _defineProperty2["default"])(this, "owner", void 0);
-  (0, _defineProperty2["default"])(this, "mintable", void 0);
-  this.name = opts.name || "";
-  this.symbol = opts.symbol || "";
-  this.original_symbol = opts.original_symbol || "";
-  this.total_supply = opts.total_supply || 0;
-  this.owner = opts.owner || Buffer.alloc(0);
-  this.mintable = opts.mintable || false;
-};
-
-exports.TokenOfList = TokenOfList;
-
-var BaseAccount = function BaseAccount() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, BaseAccount);
-  (0, _defineProperty2["default"])(this, "address", void 0);
-  (0, _defineProperty2["default"])(this, "coins", void 0);
-  (0, _defineProperty2["default"])(this, "public_key", void 0);
-  (0, _defineProperty2["default"])(this, "account_number", void 0);
-  (0, _defineProperty2["default"])(this, "sequence", void 0);
-  this.address = opts.address || Buffer.alloc(0);
-  this.coins = opts.coins || [{
-    denom: "",
-    amount: 0
-  }];
-  this.public_key = opts.public_key || Buffer.alloc(0);
-  this.account_number = opts.account_number || 0;
-  this.sequence = opts.sequence || 0;
-};
-
-exports.BaseAccount = BaseAccount;
-
-var AppAccount = function AppAccount() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, AppAccount);
-  (0, _defineProperty2["default"])(this, "aminoPrefix", _tx.AminoPrefix.BnbchainAccount);
-  (0, _defineProperty2["default"])(this, "base", void 0);
-  (0, _defineProperty2["default"])(this, "name", void 0);
-  (0, _defineProperty2["default"])(this, "locked", void 0);
-  (0, _defineProperty2["default"])(this, "frozen", void 0);
-  this.base = opts.base || new BaseAccount();
-  this.name = opts.name || "";
-  this.locked = opts.locked || [{
-    denom: "",
-    amount: 0
-  }];
-  this.frozen = opts.frozen || [{
-    denom: "",
-    amount: 0
-  }];
-};
-
-exports.AppAccount = AppAccount;
-
-var TokenBalance = function TokenBalance() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, TokenBalance);
-  (0, _defineProperty2["default"])(this, "symbol", void 0);
-  (0, _defineProperty2["default"])(this, "free", void 0);
-  (0, _defineProperty2["default"])(this, "locked", void 0);
-  (0, _defineProperty2["default"])(this, "frozen", void 0);
-  this.symbol = opts.symbol || "";
-  this.free = opts.free || 0;
-  this.locked = opts.locked || 0;
-  this.frozen = opts.frozen || 0;
-};
-
-exports.TokenBalance = TokenBalance;
-
-var OpenOrder = function OpenOrder() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, OpenOrder);
-  (0, _defineProperty2["default"])(this, "id", void 0);
-  (0, _defineProperty2["default"])(this, "symbol", void 0);
-  (0, _defineProperty2["default"])(this, "price", void 0);
-  (0, _defineProperty2["default"])(this, "quantity", void 0);
-  (0, _defineProperty2["default"])(this, "cumQty", void 0);
-  (0, _defineProperty2["default"])(this, "createdHeight", void 0);
-  (0, _defineProperty2["default"])(this, "createdTimestamp", void 0);
-  (0, _defineProperty2["default"])(this, "lastUpdatedHeight", void 0);
-  (0, _defineProperty2["default"])(this, "lastUpdatedTimestamp", void 0);
-  this.id = opts.id || "";
-  this.symbol = opts.symbol || "";
-  this.price = opts.price || 0;
-  this.quantity = opts.quantity || 0;
-  this.cumQty = opts.cumQty || 0;
-  this.createdHeight = opts.createdHeight || 0;
-  this.createdTimestamp = opts.createdTimestamp || 0;
-  this.lastUpdatedHeight = opts.lastUpdatedHeight || 0;
-  this.lastUpdatedTimestamp = opts.lastUpdatedTimestamp || 0;
-};
-
-exports.OpenOrder = OpenOrder;
-
-var TradingPair = function TradingPair() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, TradingPair);
-  (0, _defineProperty2["default"])(this, "base_asset_symbol", void 0);
-  (0, _defineProperty2["default"])(this, "quote_asset_symbol", void 0);
-  (0, _defineProperty2["default"])(this, "list_price", void 0);
-  (0, _defineProperty2["default"])(this, "tick_size", void 0);
-  (0, _defineProperty2["default"])(this, "lot_size", void 0);
-  this.base_asset_symbol = opts.base_asset_symbol || "";
-  this.quote_asset_symbol = opts.quote_asset_symbol || "";
-  this.list_price = opts.list_price || 0;
-  this.tick_size = opts.tick_size || 0;
-  this.lot_size = opts.lot_size || 0;
-};
-
-exports.TradingPair = TradingPair;
-
-var OrderBookLevel = function OrderBookLevel() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, OrderBookLevel);
-  (0, _defineProperty2["default"])(this, "buyQty", void 0);
-  (0, _defineProperty2["default"])(this, "buyPrice", void 0);
-  (0, _defineProperty2["default"])(this, "sellQty", void 0);
-  (0, _defineProperty2["default"])(this, "sellPrice", void 0);
-  this.buyQty = opts.buyQty || 0;
-  this.buyPrice = opts.buyPrice || 0;
-  this.sellQty = opts.sellQty || 0;
-  this.sellPrice = opts.sellPrice || 0;
-};
-
-exports.OrderBookLevel = OrderBookLevel;
-
-var OrderBook = function OrderBook() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, OrderBook);
-  (0, _defineProperty2["default"])(this, "height", void 0);
-  (0, _defineProperty2["default"])(this, "levels", void 0);
-  this.height = opts.height || 0;
-  this.levels = opts.levels || [new OrderBookLevel()];
-};
-
-exports.OrderBook = OrderBook;
-
-var SubmitProposalMsg = function SubmitProposalMsg() {
-  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  (0, _classCallCheck2["default"])(this, SubmitProposalMsg);
-  (0, _defineProperty2["default"])(this, "aminoPrefix", _tx.AminoPrefix.MsgSubmitProposal);
-  (0, _defineProperty2["default"])(this, "title", void 0);
-  (0, _defineProperty2["default"])(this, "description", void 0);
-  (0, _defineProperty2["default"])(this, "proposal_type", void 0);
-  (0, _defineProperty2["default"])(this, "proposer", void 0);
-  (0, _defineProperty2["default"])(this, "initial_deposit", void 0);
-  (0, _defineProperty2["default"])(this, "voting_period", void 0);
-  opts = opts || {};
-  this.title = opts.title || "";
-  this.description = opts.description || "";
-  this.proposal_type = opts.proposal_type || 0;
-  this.proposer = opts.proposer || Buffer.alloc(0);
-  this.initial_deposit = opts.initial_deposit || [];
-  this.voting_period = opts.voting_period || 0;
-};
-
-exports.SubmitProposalMsg = SubmitProposalMsg;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/abciResponse.js b/node_modules/@binance-chain/javascript-sdk/lib/types/tx/abciResponse.js
deleted file mode 100644
index 9a390c3..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/abciResponse.js
+++ /dev/null
@@ -1 +0,0 @@
-"use strict";
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/tx/index.d.ts
deleted file mode 100644
index 8b1ac05..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/index.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-export * from "./abciResponse";
-export * from "./stdTx";
-export * from "./txResult";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/index.js b/node_modules/@binance-chain/javascript-sdk/lib/types/tx/index.js
deleted file mode 100644
index ae17dac..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/index.js
+++ /dev/null
@@ -1,41 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _abciResponse = require("./abciResponse");
-
-Object.keys(_abciResponse).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _abciResponse[key];
-    }
-  });
-});
-
-var _stdTx = require("./stdTx");
-
-Object.keys(_stdTx).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _stdTx[key];
-    }
-  });
-});
-
-var _txResult = require("./txResult");
-
-Object.keys(_txResult).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _txResult[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/stdTx.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/tx/stdTx.d.ts
deleted file mode 100644
index 519ba4a..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/stdTx.d.ts
+++ /dev/null
@@ -1,74 +0,0 @@
-/// <reference types="node" />
-import { BaseMsg, Msg } from "../msg";
-export interface StdSignMsg {
-    chainId: string;
-    accountNumber: number;
-    sequence: number;
-    baseMsg?: BaseMsg;
-    msg?: Msg;
-    memo: string;
-    source: number;
-    data?: Buffer | null | string;
-}
-export interface StdSignature {
-    pub_key?: Buffer;
-    signature: Buffer;
-    account_number: number;
-    sequence: number;
-}
-export interface StdTx {
-    msg: Array<Msg>;
-    signatures: Array<StdSignature>;
-    memo: string;
-    source: number;
-    data?: Buffer | null | string;
-    aminoPrefix: AminoPrefix;
-}
-export declare enum AminoPrefix {
-    MsgSend = "2A2C87FA",
-    NewOrderMsg = "CE6DC043",
-    CancelOrderMsg = "166E681B",
-    IssueMsg = "17EFAB80",
-    BurnMsg = "7ED2D2A0",
-    FreezeMsg = "E774B32D",
-    UnfreezeMsg = "6515FF0D",
-    MintMsg = "467E0829",
-    ListMsg = "B41DE13F",
-    StdTx = "F0625DEE",
-    PubKeySecp256k1 = "EB5AE987",
-    SignatureSecp256k1 = "7FC4A495",
-    MsgSubmitProposal = "B42D614E",
-    MsgDeposit = "A18A56E5",
-    MsgVote = "A1CADD36",
-    TimeLockMsg = "07921531",
-    TimeUnlockMsg = "C4050C6C",
-    TimeRelockMsg = "504711DA",
-    HTLTMsg = "B33F9A24",
-    DepositHTLTMsg = "63986496",
-    ClaimHTLTMsg = "C1665300",
-    RefundHTLTMsg = "3454A27C",
-    SetAccountFlagsMsg = "BEA6E301",
-    BnbchainAccount = "4BDC4C27",
-    BnbchainToken = "140364E6",
-    MsgCreateValidator = "EB361D01",
-    MsgRemoveValidator = "C1AFE85F",
-    MsgCreateValidatorProposal = "DB6A19FD",
-    MsgEditValidator = "C2E8BCCD",
-    MsgDelegate = "921D2E4E",
-    MsgBeginUnbonding = "A3823C9A",
-    MsgBeginRedelegate = "267996D2",
-    MsgCreateSideChainValidator = "D17201E5",
-    MsgEditSideChainValidator = "264CC57B",
-    MsgSideChainDelegate = "E3A07FD2",
-    MsgSideChainRedelegate = "E3CED364",
-    MsgSideChainUndelegate = "514F7E0E",
-    Claim = "4E781C11",
-    ClaimMsg = "175A0521",
-    BindMsg = "B9AE640C",
-    TransferOutMsg = "800819C0",
-    IssueMiniMsg = "A3F16C41",
-    IssueTinyMsg = "ED2832D4",
-    SetURIMsg = "7B1D34E7",
-    ListMiniMsg = "4C264019",
-    MiniToken = "E0051C20"
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/stdTx.js b/node_modules/@binance-chain/javascript-sdk/lib/types/tx/stdTx.js
deleted file mode 100644
index 57fe9c8..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/stdTx.js
+++ /dev/null
@@ -1,57 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.AminoPrefix = void 0;
-var AminoPrefix;
-exports.AminoPrefix = AminoPrefix;
-
-(function (AminoPrefix) {
-  AminoPrefix["MsgSend"] = "2A2C87FA";
-  AminoPrefix["NewOrderMsg"] = "CE6DC043";
-  AminoPrefix["CancelOrderMsg"] = "166E681B";
-  AminoPrefix["IssueMsg"] = "17EFAB80";
-  AminoPrefix["BurnMsg"] = "7ED2D2A0";
-  AminoPrefix["FreezeMsg"] = "E774B32D";
-  AminoPrefix["UnfreezeMsg"] = "6515FF0D";
-  AminoPrefix["MintMsg"] = "467E0829";
-  AminoPrefix["ListMsg"] = "B41DE13F";
-  AminoPrefix["StdTx"] = "F0625DEE";
-  AminoPrefix["PubKeySecp256k1"] = "EB5AE987";
-  AminoPrefix["SignatureSecp256k1"] = "7FC4A495";
-  AminoPrefix["MsgSubmitProposal"] = "B42D614E";
-  AminoPrefix["MsgDeposit"] = "A18A56E5";
-  AminoPrefix["MsgVote"] = "A1CADD36";
-  AminoPrefix["TimeLockMsg"] = "07921531";
-  AminoPrefix["TimeUnlockMsg"] = "C4050C6C";
-  AminoPrefix["TimeRelockMsg"] = "504711DA";
-  AminoPrefix["HTLTMsg"] = "B33F9A24";
-  AminoPrefix["DepositHTLTMsg"] = "63986496";
-  AminoPrefix["ClaimHTLTMsg"] = "C1665300";
-  AminoPrefix["RefundHTLTMsg"] = "3454A27C";
-  AminoPrefix["SetAccountFlagsMsg"] = "BEA6E301";
-  AminoPrefix["BnbchainAccount"] = "4BDC4C27";
-  AminoPrefix["BnbchainToken"] = "140364E6";
-  AminoPrefix["MsgCreateValidator"] = "EB361D01";
-  AminoPrefix["MsgRemoveValidator"] = "C1AFE85F";
-  AminoPrefix["MsgCreateValidatorProposal"] = "DB6A19FD";
-  AminoPrefix["MsgEditValidator"] = "C2E8BCCD";
-  AminoPrefix["MsgDelegate"] = "921D2E4E";
-  AminoPrefix["MsgBeginUnbonding"] = "A3823C9A";
-  AminoPrefix["MsgBeginRedelegate"] = "267996D2";
-  AminoPrefix["MsgCreateSideChainValidator"] = "D17201E5";
-  AminoPrefix["MsgEditSideChainValidator"] = "264CC57B";
-  AminoPrefix["MsgSideChainDelegate"] = "E3A07FD2";
-  AminoPrefix["MsgSideChainRedelegate"] = "E3CED364";
-  AminoPrefix["MsgSideChainUndelegate"] = "514F7E0E";
-  AminoPrefix["Claim"] = "4E781C11";
-  AminoPrefix["ClaimMsg"] = "175A0521";
-  AminoPrefix["BindMsg"] = "B9AE640C";
-  AminoPrefix["TransferOutMsg"] = "800819C0";
-  AminoPrefix["IssueMiniMsg"] = "A3F16C41";
-  AminoPrefix["IssueTinyMsg"] = "ED2832D4";
-  AminoPrefix["SetURIMsg"] = "7B1D34E7";
-  AminoPrefix["ListMiniMsg"] = "4C264019";
-  AminoPrefix["MiniToken"] = "E0051C20";
-})(AminoPrefix || (exports.AminoPrefix = AminoPrefix = {}));
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/txResult.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/types/tx/txResult.d.ts
deleted file mode 100644
index 0067ca4..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/txResult.d.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-/// <reference types="node" />
-import { StdTx } from "./stdTx";
-export interface ResultTx {
-    hash: Buffer | string;
-    height: number;
-    index: number;
-    tx_result: ResponseDeliverTx;
-    tx: Buffer | StdTx;
-    proof?: TxProof;
-}
-export interface ResponseDeliverTx {
-    code?: number;
-    data?: string;
-    log?: string;
-    info?: string;
-    gas_wanted?: number;
-    gas_used?: number;
-    events?: Event[];
-    tags?: KVPair[];
-    codespace?: string;
-}
-export interface TxProof {
-    rootHash: Buffer;
-    data: Buffer;
-    proof: {
-        total: number;
-        index: number;
-        leaf_hash: Buffer;
-        aunts: Buffer[];
-    };
-}
-export interface Event {
-    type?: string;
-    attributes?: KVPair[];
-}
-export interface KVPair {
-    key: string;
-    value: string;
-}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/txResult.js b/node_modules/@binance-chain/javascript-sdk/lib/types/tx/txResult.js
deleted file mode 100644
index 9a390c3..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/txResult.js
+++ /dev/null
@@ -1 +0,0 @@
-"use strict";
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/cryptoHelper.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/utils/cryptoHelper.d.ts
deleted file mode 100644
index 3354e3d..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/cryptoHelper.d.ts
+++ /dev/null
@@ -1,119 +0,0 @@
-/**
- * @param {arrayBuffer} buf
- * @returns {string} ASCII string
- */
-export declare const ab2str: (buf: Uint8Array) => void;
-/**
- * @param {string} str - ASCII string
- * @returns {arrayBuffer}
- */
-export declare const str2ab: (str: string) => Uint8Array;
-/**
- * @param {string} str - HEX string
- * @returns {number[]}
- */
-export declare const hexstring2ab: (str: string) => Uint8Array;
-/**
- * @param {arrayBuffer} arr
- * @returns {string} HEX string
- */
-export declare const ab2hexstring: (arr: any) => string;
-/**
- * @param {string} str - ASCII string
- * @returns {string} HEX string
- */
-export declare const str2hexstring: (str: string) => string;
-/**
- * @param {string} hexstring - HEX string
- * @returns {string} ASCII string
- */
-export declare const hexstring2str: (hexstring: string) => void;
-/**
- * convert an integer to big endian hex and add leading zeros
- * @param {Number} num
- * @returns {string}
- */
-export declare const int2hex: (num: number) => string;
-/**
- * Converts a number to a big endian hexstring of a suitable size, optionally little endian
- * @param {Number} num
- * @param {Number} size - The required size in bytes, eg 1 for Uint8, 2 for Uint16. Defaults to 1.
- * @param {Boolean} littleEndian - Encode the hex in little endian form
- * @return {string}
- */
-export declare const num2hexstring: (num: number, size?: number, littleEndian?: boolean) => string;
-/**
- * Converts a number to a variable length Int. Used for array length header
- * @param {Number} num - The number
- * @returns {string} hexstring of the variable Int.
- */
-export declare const num2VarInt: (num: number) => string;
-/**
- * XORs two hexstrings
- * @param {string} str1 - HEX string
- * @param {string} str2 - HEX string
- * @returns {string} XOR output as a HEX string
- */
-export declare const hexXor: (str1: string, str2: string) => string;
-/**
- * Reverses an array. Accepts arrayBuffer.
- * @param {Array} arr
- * @returns {Uint8Array}
- */
-export declare const reverseArray: (arr: any[]) => Uint8Array;
-/**
- * Reverses a HEX string, treating 2 chars as a byte.
- * @example
- * reverseHex('abcdef') = 'efcdab'
- * @param {string} hex - HEX string
- * @return {string} HEX string reversed in 2s.
- */
-export declare const reverseHex: (hex: string) => string;
-/**
- * Checks if input is a hexstring. Empty string is considered a hexstring.
- * @example
- * isHex('0101') = true
- * isHex('') = true
- * isHex('0x01') = false
- * @param {string} str
- * @return {boolean}
- */
-export declare const isHex: (str: string) => boolean;
-/**
- * Throws an error if input is not hexstring.
- * @param {string} str
- */
-export declare const ensureHex: (str: string) => void;
-/**
- * Computes a SHA256 followed by a RIPEMD160.
- * @param {string} hex message to hash
- * @returns {string} hash output
- */
-export declare const sha256ripemd160: (hex: string) => string;
-/**
- * Computes a single SHA256 digest.
- * @param {string} hex message to hash
- * @returns {string} hash output
- */
-export declare const sha256: (hex: string) => string;
-/**
- * Computes a single SHA3 (Keccak) digest.
- * @param {string} hex message to hash
- * @returns {string} hash output
- */
-export declare const sha3: (hex: string) => string;
-/**
- * Computes sha256 of random number and timestamp
- * @param {String} randomNumber
- * @param {Number} timestamp
- * @returns {string} sha256 result
- */
-export declare const calculateRandomNumberHash: (randomNumber: string, timestamp: number) => string;
-/**
- * Computes swapID
- * @param {String} randomNumberHash
- * @param {String} sender
- * @param {String} senderOtherChain
- * @returns {string} sha256 result
- */
-export declare const calculateSwapID: (randomNumberHash: string, sender: string, senderOtherChain: string) => string;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/cryptoHelper.js b/node_modules/@binance-chain/javascript-sdk/lib/utils/cryptoHelper.js
deleted file mode 100644
index 60490ec..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/cryptoHelper.js
+++ /dev/null
@@ -1,374 +0,0 @@
-"use strict";
-
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.calculateSwapID = exports.calculateRandomNumberHash = exports.sha3 = exports.sha256 = exports.sha256ripemd160 = exports.ensureHex = exports.isHex = exports.reverseHex = exports.reverseArray = exports.hexXor = exports.num2VarInt = exports.num2hexstring = exports.int2hex = exports.hexstring2str = exports.str2hexstring = exports.ab2hexstring = exports.hexstring2ab = exports.str2ab = exports.ab2str = void 0;
-
-var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
-
-var _encHex = _interopRequireDefault(require("crypto-js/enc-hex"));
-
-var _ripemd = _interopRequireDefault(require("crypto-js/ripemd160"));
-
-var _sha = _interopRequireDefault(require("crypto-js/sha256"));
-
-var _sha2 = _interopRequireDefault(require("crypto-js/sha3"));
-
-var crypto = _interopRequireWildcard(require("../crypto"));
-
-/**
- * @param {arrayBuffer} buf
- * @returns {string} ASCII string
- */
-var ab2str = function ab2str(buf) {
-  var numArr = [];
-
-  for (var i = 0, len = buf.length; i < len; i++) {
-    numArr.push(buf[i]);
-  }
-
-  String.fromCharCode.apply(null, numArr);
-};
-/**
- * @param {string} str - ASCII string
- * @returns {arrayBuffer}
- */
-
-
-exports.ab2str = ab2str;
-
-var str2ab = function str2ab(str) {
-  if (typeof str !== "string") {
-    throw new Error("str2ab expects a string");
-  }
-
-  var result = new Uint8Array(str.length);
-
-  for (var i = 0, strLen = str.length; i < strLen; i++) {
-    result[i] = str.charCodeAt(i);
-  }
-
-  return result;
-};
-/**
- * @param {string} str - HEX string
- * @returns {number[]}
- */
-
-
-exports.str2ab = str2ab;
-
-var hexstring2ab = function hexstring2ab(str) {
-  ensureHex(str);
-  if (!str.length) return new Uint8Array();
-  var iters = str.length / 2;
-  var result = new Uint8Array(iters);
-
-  for (var i = 0; i < iters; i++) {
-    result[i] = parseInt(str.substring(0, 2), 16);
-    str = str.substring(2);
-  }
-
-  return result;
-};
-/**
- * @param {arrayBuffer} arr
- * @returns {string} HEX string
- */
-
-
-exports.hexstring2ab = hexstring2ab;
-
-var ab2hexstring = function ab2hexstring(arr) {
-  if ((0, _typeof2["default"])(arr) !== "object") {
-    throw new Error("ab2hexstring expects an array");
-  }
-
-  var result = "";
-
-  for (var i = 0; i < arr.length; i++) {
-    var str = arr[i].toString(16);
-    str = str.length === 0 ? "00" : str.length === 1 ? "0" + str : str;
-    result += str;
-  }
-
-  return result;
-};
-/**
- * @param {string} str - ASCII string
- * @returns {string} HEX string
- */
-
-
-exports.ab2hexstring = ab2hexstring;
-
-var str2hexstring = function str2hexstring(str) {
-  return ab2hexstring(str2ab(str));
-};
-/**
- * @param {string} hexstring - HEX string
- * @returns {string} ASCII string
- */
-
-
-exports.str2hexstring = str2hexstring;
-
-var hexstring2str = function hexstring2str(hexstring) {
-  return ab2str(hexstring2ab(hexstring));
-};
-/**
- * convert an integer to big endian hex and add leading zeros
- * @param {Number} num
- * @returns {string}
- */
-
-
-exports.hexstring2str = hexstring2str;
-
-var int2hex = function int2hex(num) {
-  if (typeof num !== "number") {
-    throw new Error("int2hex expects a number");
-  }
-
-  var h = num.toString(16);
-  return h.length % 2 ? "0" + h : h;
-};
-/**
- * Converts a number to a big endian hexstring of a suitable size, optionally little endian
- * @param {Number} num
- * @param {Number} size - The required size in bytes, eg 1 for Uint8, 2 for Uint16. Defaults to 1.
- * @param {Boolean} littleEndian - Encode the hex in little endian form
- * @return {string}
- */
-
-
-exports.int2hex = int2hex;
-
-var num2hexstring = function num2hexstring(num) {
-  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
-  var littleEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
-  if (typeof num !== "number") throw new Error("num must be numeric");
-  if (num < 0) throw new RangeError("num is unsigned (>= 0)");
-  if (size % 1 !== 0) throw new Error("size must be a whole integer");
-  if (!Number.isSafeInteger(num)) throw new RangeError("num (".concat(num, ") must be a safe integer"));
-  size = size * 2;
-  var hexstring = num.toString(16);
-  hexstring = hexstring.length % size === 0 ? hexstring : ("0".repeat(size) + hexstring).substring(hexstring.length);
-  if (littleEndian) hexstring = reverseHex(hexstring);
-  return hexstring;
-};
-/**
- * Converts a number to a variable length Int. Used for array length header
- * @param {Number} num - The number
- * @returns {string} hexstring of the variable Int.
- */
-
-
-exports.num2hexstring = num2hexstring;
-
-var num2VarInt = function num2VarInt(num) {
-  if (num < 0xfd) {
-    return num2hexstring(num);
-  } else if (num <= 0xffff) {
-    // uint16
-    return "fd" + num2hexstring(num, 2, true);
-  } else if (num <= 0xffffffff) {
-    // uint32
-    return "fe" + num2hexstring(num, 4, true);
-  } else {
-    // uint64
-    return "ff" + num2hexstring(num, 8, true);
-  }
-};
-/**
- * XORs two hexstrings
- * @param {string} str1 - HEX string
- * @param {string} str2 - HEX string
- * @returns {string} XOR output as a HEX string
- */
-
-
-exports.num2VarInt = num2VarInt;
-
-var hexXor = function hexXor(str1, str2) {
-  ensureHex(str1);
-  ensureHex(str2);
-  if (str1.length !== str2.length) throw new Error("strings are disparate lengths");
-  var result = [];
-
-  for (var i = 0; i < str1.length; i += 2) {
-    result.push(parseInt(str1.substr(i, 2), 16) ^ parseInt(str2.substr(i, 2), 16));
-  }
-
-  return ab2hexstring(result);
-};
-/**
- * Reverses an array. Accepts arrayBuffer.
- * @param {Array} arr
- * @returns {Uint8Array}
- */
-
-
-exports.hexXor = hexXor;
-
-var reverseArray = function reverseArray(arr) {
-  if ((0, _typeof2["default"])(arr) !== "object" || !arr.length) throw new Error("reverseArray expects an array");
-  var result = new Uint8Array(arr.length);
-
-  for (var i = 0; i < arr.length; i++) {
-    result[i] = arr[arr.length - 1 - i];
-  }
-
-  return result;
-};
-/**
- * Reverses a HEX string, treating 2 chars as a byte.
- * @example
- * reverseHex('abcdef') = 'efcdab'
- * @param {string} hex - HEX string
- * @return {string} HEX string reversed in 2s.
- */
-
-
-exports.reverseArray = reverseArray;
-
-var reverseHex = function reverseHex(hex) {
-  ensureHex(hex);
-  var out = "";
-
-  for (var i = hex.length - 2; i >= 0; i -= 2) {
-    out += hex.substr(i, 2);
-  }
-
-  return out;
-};
-
-exports.reverseHex = reverseHex;
-var hexRegex = /^([0-9A-Fa-f]{2})*$/;
-/**
- * Checks if input is a hexstring. Empty string is considered a hexstring.
- * @example
- * isHex('0101') = true
- * isHex('') = true
- * isHex('0x01') = false
- * @param {string} str
- * @return {boolean}
- */
-
-var isHex = function isHex(str) {
-  try {
-    return hexRegex.test(str);
-  } catch (err) {
-    return false;
-  }
-};
-/**
- * Throws an error if input is not hexstring.
- * @param {string} str
- */
-
-
-exports.isHex = isHex;
-
-var ensureHex = function ensureHex(str) {
-  if (!isHex(str)) throw new Error("Expected a hexstring but got ".concat(str));
-};
-/**
- * Computes a SHA256 followed by a RIPEMD160.
- * @param {string} hex message to hash
- * @returns {string} hash output
- */
-
-
-exports.ensureHex = ensureHex;
-
-var sha256ripemd160 = function sha256ripemd160(hex) {
-  if (typeof hex !== "string") throw new Error("sha256ripemd160 expects a string");
-  if (hex.length % 2 !== 0) throw new Error("invalid hex string length: ".concat(hex));
-
-  var hexEncoded = _encHex["default"].parse(hex);
-
-  var ProgramSha256 = (0, _sha["default"])(hexEncoded);
-  return (0, _ripemd["default"])(ProgramSha256).toString();
-};
-/**
- * Computes a single SHA256 digest.
- * @param {string} hex message to hash
- * @returns {string} hash output
- */
-
-
-exports.sha256ripemd160 = sha256ripemd160;
-
-var sha256 = function sha256(hex) {
-  if (typeof hex !== "string") throw new Error("sha256 expects a hex string");
-  if (hex.length % 2 !== 0) throw new Error("invalid hex string length: ".concat(hex));
-
-  var hexEncoded = _encHex["default"].parse(hex);
-
-  return (0, _sha["default"])(hexEncoded).toString();
-};
-/**
- * Computes a single SHA3 (Keccak) digest.
- * @param {string} hex message to hash
- * @returns {string} hash output
- */
-
-
-exports.sha256 = sha256;
-
-var sha3 = function sha3(hex) {
-  if (typeof hex !== "string") throw new Error("sha3 expects a hex string");
-  if (hex.length % 2 !== 0) throw new Error("invalid hex string length: ".concat(hex));
-
-  var hexEncoded = _encHex["default"].parse(hex);
-
-  return (0, _sha2["default"])(hexEncoded).toString();
-};
-/**
- * Computes sha256 of random number and timestamp
- * @param {String} randomNumber
- * @param {Number} timestamp
- * @returns {string} sha256 result
- */
-
-
-exports.sha3 = sha3;
-
-var calculateRandomNumberHash = function calculateRandomNumberHash(randomNumber, timestamp) {
-  var timestampHexStr = timestamp.toString(16);
-  var timestampHexStrFormat = timestampHexStr;
-
-  for (var i = 0; i < 16 - timestampHexStr.length; i++) {
-    timestampHexStrFormat = "0" + timestampHexStrFormat;
-  }
-
-  var timestampBytes = Buffer.from(timestampHexStrFormat, "hex");
-  var newBuffer = Buffer.concat([Buffer.from(randomNumber, "hex"), timestampBytes]);
-  return sha256(newBuffer.toString("hex"));
-};
-/**
- * Computes swapID
- * @param {String} randomNumberHash
- * @param {String} sender
- * @param {String} senderOtherChain
- * @returns {string} sha256 result
- */
-
-
-exports.calculateRandomNumberHash = calculateRandomNumberHash;
-
-var calculateSwapID = function calculateSwapID(randomNumberHash, sender, senderOtherChain) {
-  var randomNumberHashBytes = Buffer.from(randomNumberHash, "hex");
-  var senderBytes = crypto.decodeAddress(sender);
-  var sendOtherChainBytes = Buffer.from(senderOtherChain.toLowerCase(), "utf8");
-  var newBuffer = Buffer.concat([randomNumberHashBytes, senderBytes, sendOtherChainBytes]);
-  return sha256(newBuffer.toString("hex"));
-};
-
-exports.calculateSwapID = calculateSwapID;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/encoderHelper.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/utils/encoderHelper.d.ts
deleted file mode 100644
index c088b86..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/encoderHelper.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-declare const _default: (type: any) => 0 | 1 | 2;
-export default _default;
-export declare const size: <T>(items: T[], iter: (it: T, index: number, acc: number) => number, acc: number) => number;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/encoderHelper.js b/node_modules/@binance-chain/javascript-sdk/lib/utils/encoderHelper.js
deleted file mode 100644
index d43124f..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/encoderHelper.js
+++ /dev/null
@@ -1,46 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.size = exports["default"] = void 0;
-
-var _is_js = _interopRequireDefault(require("is_js"));
-
-// typeToTyp3
-//amino type convert
-var _default = function _default(type) {
-  if (_is_js["default"]["boolean"](type)) {
-    return 0;
-  }
-
-  if (_is_js["default"].number(type)) {
-    if (_is_js["default"].integer(type)) {
-      return 0;
-    } else {
-      return 1;
-    }
-  }
-
-  if (_is_js["default"].string(type) || _is_js["default"].array(type) || _is_js["default"].object(type)) {
-    return 2;
-  }
-
-  throw new Error("Invalid type \"".concat(type, "\"")); // Is this what's expected?
-};
-
-exports["default"] = _default;
-
-var size = function size(items, iter, acc) {
-  if (acc === undefined) acc = 0;
-
-  for (var i = 0; i < items.length; ++i) {
-    acc += iter(items[i], i, acc);
-  }
-
-  return acc;
-};
-
-exports.size = size;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/index.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/utils/index.d.ts
deleted file mode 100644
index 9d55823..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/index.d.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-export * from "./cryptoHelper";
-export * from "./encoderHelper";
-export * from "./validateHelper";
-export * from "./rpcHelper";
-export * from "./request";
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/index.js b/node_modules/@binance-chain/javascript-sdk/lib/utils/index.js
deleted file mode 100644
index b7bc4ad..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/index.js
+++ /dev/null
@@ -1,65 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-
-var _cryptoHelper = require("./cryptoHelper");
-
-Object.keys(_cryptoHelper).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _cryptoHelper[key];
-    }
-  });
-});
-
-var _encoderHelper = require("./encoderHelper");
-
-Object.keys(_encoderHelper).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _encoderHelper[key];
-    }
-  });
-});
-
-var _validateHelper = require("./validateHelper");
-
-Object.keys(_validateHelper).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _validateHelper[key];
-    }
-  });
-});
-
-var _rpcHelper = require("./rpcHelper");
-
-Object.keys(_rpcHelper).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _rpcHelper[key];
-    }
-  });
-});
-
-var _request = require("./request");
-
-Object.keys(_request).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function get() {
-      return _request[key];
-    }
-  });
-});
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/request.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/utils/request.d.ts
deleted file mode 100644
index 7924394..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/request.d.ts
+++ /dev/null
@@ -1,18 +0,0 @@
-import { Method, AxiosRequestConfig } from "axios";
-export declare class HttpRequest {
-    private httpClient;
-    constructor(baseURL: string);
-    get(path: string, params?: any, opts?: AxiosRequestConfig): Promise<{
-        result: any;
-        status: number;
-    }>;
-    post(path: string, body?: any, opts?: AxiosRequestConfig): Promise<{
-        result: any;
-        status: number;
-    }>;
-    request(method: Method, path: string, params?: any, opts?: AxiosRequestConfig): Promise<{
-        result: any;
-        status: number;
-    }>;
-}
-export default HttpRequest;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/request.js b/node_modules/@binance-chain/javascript-sdk/lib/utils/request.js
deleted file mode 100644
index 330db22..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/request.js
+++ /dev/null
@@ -1,84 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = exports.HttpRequest = void 0;
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _axios = _interopRequireDefault(require("axios"));
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
-var HttpRequest = /*#__PURE__*/function () {
-  function HttpRequest(baseURL) {
-    (0, _classCallCheck2["default"])(this, HttpRequest);
-    (0, _defineProperty2["default"])(this, "httpClient", void 0);
-    this.httpClient = _axios["default"].create({
-      baseURL: baseURL
-    });
-  }
-
-  (0, _createClass2["default"])(HttpRequest, [{
-    key: "get",
-    value: function get(path, params, opts) {
-      return this.request("get", path, params, opts);
-    }
-  }, {
-    key: "post",
-    value: function post(path, body, opts) {
-      return this.request("post", path, body, opts);
-    }
-  }, {
-    key: "request",
-    value: function request(method, path, params) {
-      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
-
-      var options = _objectSpread({
-        method: method,
-        url: path
-      }, opts);
-
-      if (params) {
-        if (method === "get") {
-          options.params = params;
-        } else {
-          options.data = params;
-        }
-      }
-
-      return this.httpClient.request(options).then(function (response) {
-        return {
-          result: response.data,
-          status: response.status
-        };
-      })["catch"](function (err) {
-        var error = err;
-
-        try {
-          var msgObj = err.response && err.response.data;
-          error = new Error(msgObj.message);
-          error.code = msgObj.code;
-        } catch (err) {
-          throw error;
-        }
-
-        throw error;
-      });
-    }
-  }]);
-  return HttpRequest;
-}();
-
-exports.HttpRequest = HttpRequest;
-var _default = HttpRequest;
-exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/rpcHelper.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/utils/rpcHelper.d.ts
deleted file mode 100644
index 61bb24b..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/rpcHelper.d.ts
+++ /dev/null
@@ -1,8 +0,0 @@
-import { BigSource } from "big.js";
-import { NewOrderMsg, CancelOrderMsg, SendMsg, BaseMsg, BurnTokenMsg, IssueTokenMsg, FreezeTokenMsg, UnFreezeTokenMsg, TimeLockMsg, TimeUnlockMsg, MintTokenMsg, TimeReLockMsg } from "../types";
-export declare const BASENUMBER: number;
-export declare const divide: (num: BigSource) => number;
-export declare const convertObjectArrayNum: <T extends {
-    [k: string]: BigSource;
-}>(objArr: T[], keys: (keyof T)[]) => void;
-export declare const getMsgByAminoPrefix: (aminoPrefix: string) => typeof BaseMsg | typeof CancelOrderMsg | typeof NewOrderMsg | typeof BurnTokenMsg | typeof FreezeTokenMsg | typeof UnFreezeTokenMsg | typeof IssueTokenMsg | typeof MintTokenMsg | typeof TimeLockMsg | typeof TimeReLockMsg | typeof TimeUnlockMsg | typeof SendMsg;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/rpcHelper.js b/node_modules/@binance-chain/javascript-sdk/lib/utils/rpcHelper.js
deleted file mode 100644
index a3a59ea..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/rpcHelper.js
+++ /dev/null
@@ -1,74 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.getMsgByAminoPrefix = exports.convertObjectArrayNum = exports.divide = exports.BASENUMBER = void 0;
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var _types = require("../types");
-
-var BASENUMBER = Math.pow(10, 8);
-exports.BASENUMBER = BASENUMBER;
-
-var divide = function divide(num) {
-  return +new _big["default"](num).div(BASENUMBER).toString();
-};
-
-exports.divide = divide;
-
-var convertObjectArrayNum = function convertObjectArrayNum(objArr, keys) {
-  objArr.forEach(function (item) {
-    keys.forEach(function (key) {
-      item[key] = divide(item[key]);
-    });
-  });
-}; //TODO add gov and swap
-
-
-exports.convertObjectArrayNum = convertObjectArrayNum;
-
-var getMsgByAminoPrefix = function getMsgByAminoPrefix(aminoPrefix) {
-  switch (aminoPrefix.toUpperCase()) {
-    case _types.AminoPrefix.NewOrderMsg:
-      return _types.NewOrderMsg;
-
-    case _types.AminoPrefix.CancelOrderMsg:
-      return _types.CancelOrderMsg;
-
-    case _types.AminoPrefix.MsgSend:
-      return _types.SendMsg;
-
-    case _types.AminoPrefix.IssueMsg:
-      return _types.IssueTokenMsg;
-
-    case _types.AminoPrefix.FreezeMsg:
-      return _types.FreezeTokenMsg;
-
-    case _types.AminoPrefix.UnfreezeMsg:
-      return _types.UnFreezeTokenMsg;
-
-    case _types.AminoPrefix.BurnMsg:
-      return _types.BurnTokenMsg;
-
-    case _types.AminoPrefix.MintMsg:
-      return _types.MintTokenMsg;
-
-    case _types.AminoPrefix.TimeLockMsg:
-      return _types.TimeLockMsg;
-
-    case _types.AminoPrefix.TimeRelockMsg:
-      return _types.TimeReLockMsg;
-
-    case _types.AminoPrefix.TimeUnlockMsg:
-      return _types.TimeUnlockMsg;
-
-    default:
-      return _types.BaseMsg;
-  }
-};
-
-exports.getMsgByAminoPrefix = getMsgByAminoPrefix;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/validateHelper.d.ts b/node_modules/@binance-chain/javascript-sdk/lib/utils/validateHelper.d.ts
deleted file mode 100644
index 1e364ac..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/validateHelper.d.ts
+++ /dev/null
@@ -1,15 +0,0 @@
-import { BigSource } from "big.js";
-import { Coin } from "../types";
-/**
- * validate the input number.
- * @param {Number} value
- */
-export declare const checkNumber: (value: BigSource, name?: string) => void;
-/**
- * basic validation of coins
- * @param {Array} coins
- */
-export declare const checkCoins: (coins: Coin[]) => void;
-export declare const validateSymbol: (symbol: string) => void;
-export declare const validateTradingPair: (pair: string) => void;
-export declare const validateOffsetLimit: (offset: number, limit: number) => void;
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/utils/validateHelper.js b/node_modules/@binance-chain/javascript-sdk/lib/utils/validateHelper.js
deleted file mode 100644
index 53185ea..0000000
--- a/node_modules/@binance-chain/javascript-sdk/lib/utils/validateHelper.js
+++ /dev/null
@@ -1,87 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.validateOffsetLimit = exports.validateTradingPair = exports.validateSymbol = exports.checkCoins = exports.checkNumber = void 0;
-
-var _big = _interopRequireDefault(require("big.js"));
-
-var MAX_INT64 = Math.pow(2, 63);
-/**
- * validate the input number.
- * @param {Number} value
- */
-
-var checkNumber = function checkNumber(value) {
-  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "input number";
-
-  if (new _big["default"](value).lte(0)) {
-    throw new Error("".concat(name, " should be a positive number"));
-  }
-
-  if (new _big["default"](value).gte(MAX_INT64)) {
-    throw new Error("".concat(name, " should be less than 2^63"));
-  }
-};
-/**
- * basic validation of coins
- * @param {Array} coins
- */
-
-
-exports.checkNumber = checkNumber;
-
-var checkCoins = function checkCoins(coins) {
-  coins = coins || [];
-  coins.forEach(function (coin) {
-    checkNumber(coin.amount);
-
-    if (!coin.denom) {
-      throw new Error("invalid denmon");
-    }
-  });
-};
-
-exports.checkCoins = checkCoins;
-
-var validateSymbol = function validateSymbol(symbol) {
-  if (!symbol) {
-    throw new Error("suffixed token symbol cannot be empty");
-  }
-
-  var splitSymbols = symbol.split("-"); //check length with .B suffix
-
-  if (!/^[a-zA-z\d/.]{3,10}$/.test(splitSymbols[0])) {
-    throw new Error("symbol length is limited to 3~10");
-  }
-};
-
-exports.validateSymbol = validateSymbol;
-
-var validateTradingPair = function validateTradingPair(pair) {
-  var symbols = pair.split("_");
-
-  if (symbols.length !== 2) {
-    throw new Error('the pair should in format "symbol1_symbol2"');
-  }
-
-  validateSymbol(symbols[0]);
-  validateSymbol(symbols[1]);
-};
-
-exports.validateTradingPair = validateTradingPair;
-
-var validateOffsetLimit = function validateOffsetLimit(offset, limit) {
-  if (offset < 0) {
-    throw new Error("offset can't be less than 0");
-  }
-
-  if (limit < 0) {
-    throw new Error("limit can't be less than 0");
-  }
-};
-
-exports.validateOffsetLimit = validateOffsetLimit;
\ No newline at end of file
diff --git a/node_modules/@binance-chain/javascript-sdk/src/amino/decoder/index.ts b/node_modules/@binance-chain/javascript-sdk/src/amino/decoder/index.ts
new file mode 100644
index 0000000..a7e0ac1
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/amino/decoder/index.ts
@@ -0,0 +1,222 @@
+import is from "is_js"
+import {
+  string as varString,
+  bool as varBool,
+  bytes as varBytes,
+  varint,
+} from "protocol-buffers-encodings"
+
+import typeToTyp3 from "../../utils/encoderHelper"
+
+const decoder = (bytes: Buffer, varType: any) => {
+  const val = varType.decode(bytes, 0)
+  const offset = varType.encodingLength(val)
+  return { val, offset }
+}
+
+/**
+ * @category amino
+ * js amino UnmarshalBinaryLengthPrefixed
+ * @param {Buffer} bytes
+ * @param {Object} type
+ * @returns {Object}
+ *  */
+export const unMarshalBinaryLengthPrefixed = (
+  bytes: Buffer,
+  type: any
+): any => {
+  if (bytes.length === 0) throw new TypeError("Cannot decode empty bytes")
+
+  // read byte-length prefix
+  const { offset: len } = decoder(bytes, varint)
+
+  if (len < 0)
+    throw new Error(`Error reading msg byte-length prefix: got code ${len}`)
+
+  bytes = bytes.slice(len)
+
+  return unMarshalBinaryBare(bytes, type)
+}
+
+/**
+ * @category amino
+ * js amino UnmarshalBinaryBare
+ * @param {Buffer} bytes
+ * @param {Object} type
+ * @returns {Object}
+ *  */
+export const unMarshalBinaryBare = (bytes: Buffer, type: any): any => {
+  if (!is.object(type)) throw new TypeError("type should be object")
+
+  if (!Buffer.isBuffer(bytes)) throw new TypeError("bytes must be buffer")
+
+  if (is.array(type)) {
+    if (!is.object(type[0])) throw new TypeError("type should be object")
+
+    return decodeArrayBinary(bytes, type[0])
+  }
+
+  return decodeBinary(bytes, type)
+}
+
+const decodeBinary = (
+  bytes: Buffer,
+  type: any,
+  isLengthPrefixed?: boolean
+): any => {
+  if (Buffer.isBuffer(type)) {
+    return decoder(bytes, varBytes)
+  }
+
+  if (is.array(type)) {
+    return decodeArrayBinary(bytes, type)
+  }
+
+  if (is.number(type)) {
+    return decoder(bytes, varint)
+  }
+
+  if (is.boolean(type)) {
+    return decoder(bytes, varBool)
+  }
+
+  if (is.string(type)) {
+    return decoder(bytes, varString)
+  }
+
+  if (is.object(type)) {
+    return decodeObjectBinary(bytes, type, isLengthPrefixed)
+  }
+
+  return
+}
+
+const setDefaultValue = (type: any, key: string) => {
+  if (is.object(type[key])) type[key] = null
+
+  if (is.number(type[key])) type[key] = 0
+
+  if (is.boolean(type[key])) type[key] = false
+
+  if (is.string(type[key])) type[key] = ""
+}
+
+const decodeObjectBinary = (
+  bytes: Buffer,
+  type: any,
+  isLengthPrefixed?: boolean
+) => {
+  let objectOffset = 0
+
+  // read byte-length prefix
+  if (isLengthPrefixed) {
+    const { offset: len } = decoder(bytes, varint)
+    bytes = bytes.slice(len)
+    objectOffset += len
+  }
+
+  // If registered concrete, consume and verify prefix bytes.
+  if (type.aminoPrefix) {
+    bytes = bytes.slice(4)
+    objectOffset += 4
+  }
+
+  let lastFieldNum = 0
+
+  const keys = Object.keys(type).filter((key) => key !== "aminoPrefix")
+
+  keys.forEach((key, index) => {
+    if (is.array(type[key])) {
+      const { offset, val } = decodeArrayBinary(bytes, type[key][0])
+      objectOffset += offset
+      type[key] = val
+      bytes = bytes.slice(offset)
+    } else {
+      const { fieldNum, typ } = decodeFieldNumberAndTyp3(bytes)
+
+      //if this field is default value, continue
+      if (index + 1 !== fieldNum || fieldNum < 0) {
+        setDefaultValue(type, key)
+        return
+      }
+
+      if (fieldNum <= lastFieldNum) {
+        throw new Error(
+          `encountered fieldNum: ${fieldNum}, but we have already seen fnum: ${lastFieldNum}`
+        )
+      }
+
+      lastFieldNum = fieldNum
+
+      if (index + 1 !== fieldNum) {
+        throw new Error("field number is not expected")
+      }
+
+      const typeWanted = typeToTyp3(type[key])
+
+      if (typ !== typeWanted) {
+        throw new Error("field type is not expected")
+      }
+
+      //remove 1 byte of type
+      bytes = bytes.slice(1)
+
+      const { val, offset } = decodeBinary(bytes, type[key], true)
+      type[key] = val
+
+      //remove decoded bytes
+      bytes = bytes.slice(offset)
+      objectOffset += offset + 1
+    }
+  })
+
+  return { val: type, offset: objectOffset }
+}
+
+const decodeArrayBinary = (bytes: Buffer, type: any) => {
+  const arr = []
+  let arrayOffset = 0
+  let { fieldNum: fieldNumber } = decodeFieldNumberAndTyp3(bytes)
+
+  while (true) {
+    const { fieldNum } = decodeFieldNumberAndTyp3(bytes)
+
+    if (fieldNum !== fieldNumber || fieldNum < 0) break
+
+    //remove 1 byte of encoded field number and type
+    bytes = bytes.slice(1)
+
+    //is default value, skip and continue read bytes
+    // if (bytes.length > 0 && bytes[0] === 0x00) continue
+    if (bytes.length > 0 && bytes.readUInt8(0) === 0x00) continue
+
+    const { offset, val } = decodeBinary(bytes, type, true)
+
+    arr.push({ ...val })
+    bytes = bytes.slice(offset + 1)
+
+    //add 1 byte of type
+    arrayOffset += offset + 1
+    fieldNumber = fieldNum
+  }
+
+  // console.log(arr)
+  return { val: arr, offset: arrayOffset }
+}
+
+export const decodeFieldNumberAndTyp3 = (bytes: Buffer): any => {
+  if (bytes.length < 2) {
+    //default value
+    return { fieldNum: -1 }
+  }
+
+  const { val } = decoder(bytes, varint)
+
+  const typ = val & 7
+  const fieldNum = val >> 3
+  if (fieldNum > 1 << (29 - 1)) {
+    throw new Error(`invalid field num ${fieldNum}`)
+  }
+
+  return { fieldNum, typ }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/amino/encoder/index.ts b/node_modules/@binance-chain/javascript-sdk/src/amino/encoder/index.ts
new file mode 100644
index 0000000..2055069
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/amino/encoder/index.ts
@@ -0,0 +1,245 @@
+import is from "is_js"
+import { string as VarString } from "protocol-buffers-encodings"
+
+import typeToTyp3 from "../../utils/encoderHelper"
+
+import { UVarInt } from "./varint"
+
+const sortObject = (obj: any): any => {
+  if (obj === null) return null
+  if (typeof obj !== "object") return obj
+  // arrays have typeof "object" in js!
+  if (Array.isArray(obj)) return obj.map(sortObject)
+  const sortedKeys = Object.keys(obj).sort()
+  const result: any = {}
+  sortedKeys.forEach((key) => {
+    result[key] = sortObject(obj[key])
+  })
+  return result
+}
+
+/**
+ * encode number
+ * @category amino
+ * @param num
+ */
+export const encodeNumber = (num: number) => UVarInt.encode(num)
+
+/**
+ * encode bool
+ * @category amino
+ * @param b
+ */
+export const encodeBool = (b: boolean) =>
+  b ? UVarInt.encode(1) : UVarInt.encode(0)
+
+/**
+ * encode string
+ * @category amino
+ * @param str
+ */
+export const encodeString = (str: string) => {
+  const buf = Buffer.alloc(VarString.encodingLength(str))
+  return VarString.encode(str, buf, 0)
+}
+
+/**
+ * encode time
+ * @category amino
+ * @param value
+ */
+export const encodeTime = (value: string | Date) => {
+  const millis = new Date(value).getTime()
+  const seconds = Math.floor(millis / 1000)
+  const nanos = Number(seconds.toString().padEnd(9, "0"))
+
+  const buffer = Buffer.alloc(14)
+
+  // buffer[0] = (1 << 3) | 1 // field 1, typ3 1
+  buffer.writeInt32LE((1 << 3) | 1, 0)
+  buffer.writeUInt32LE(seconds, 1)
+
+  // buffer[9] = (2 << 3) | 5 // field 2, typ3 5
+  buffer.writeInt32LE((2 << 3) | 5, 9)
+  buffer.writeUInt32LE(nanos, 10)
+
+  return buffer
+}
+
+/**
+ * @category amino
+ * @param obj -- {object}
+ * @return bytes {Buffer}
+ */
+export const convertObjectToSignBytes = (obj: any) =>
+  Buffer.from(JSON.stringify(sortObject(obj)))
+
+/**
+ * js amino MarshalBinary
+ * @category amino
+ * @param {Object} obj
+ *  */
+export const marshalBinary = (obj: any) => {
+  if (!is.object(obj)) throw new TypeError("data must be an object")
+
+  return encodeBinary(obj, -1, true).toString("hex")
+}
+
+/**
+ * js amino MarshalBinaryBare
+ * @category amino
+ * @param {Object} obj
+ *  */
+export const marshalBinaryBare = (obj: any) => {
+  if (!is.object(obj)) throw new TypeError("data must be an object")
+
+  return encodeBinary(obj).toString("hex")
+}
+
+/**
+ * This is the main entrypoint for encoding all types in binary form.
+ * @category amino
+ * @param {*} js data type (not null, not undefined)
+ * @param {Number} field index of object
+ * @param {Boolean} isByteLenPrefix
+ * @return {Buffer} binary of object.
+ */
+export const encodeBinary = (
+  val: any,
+  fieldNum?: number,
+  isByteLenPrefix?: boolean
+) => {
+  if (val === null || val === undefined) throw new TypeError("unsupported type")
+
+  if (Buffer.isBuffer(val)) {
+    if (isByteLenPrefix) {
+      return Buffer.concat([UVarInt.encode(val.length), val])
+    }
+    return val
+  }
+
+  if (is.array(val)) {
+    return encodeArrayBinary(fieldNum, val, isByteLenPrefix)
+  }
+
+  if (is.number(val)) {
+    return encodeNumber(val)
+  }
+
+  if (is.boolean(val)) {
+    return encodeBool(val)
+  }
+
+  if (is.string(val)) {
+    return encodeString(val)
+  }
+
+  if (is.object(val)) {
+    return encodeObjectBinary(val, isByteLenPrefix)
+  }
+
+  return
+}
+
+/**
+ * prefixed with bytes length
+ * @category amino
+ * @param {Buffer} bytes
+ * @return {Buffer} with bytes length prefixed
+ */
+export const encodeBinaryByteArray = (bytes: Buffer) => {
+  const lenPrefix = bytes.length
+  return Buffer.concat([UVarInt.encode(lenPrefix), bytes])
+}
+
+/**
+ * @category amino
+ * @param {Object} obj
+ * @return {Buffer} with bytes length prefixed
+ */
+export const encodeObjectBinary = (obj: any, isByteLenPrefix?: boolean) => {
+  const bufferArr: any[] = []
+
+  Object.keys(obj).forEach((key, index) => {
+    if (key === "aminoPrefix" || key === "version") return
+
+    if (isDefaultValue(obj[key])) return
+
+    if (is.array(obj[key]) && obj[key].length > 0) {
+      bufferArr.push(encodeArrayBinary(index, obj[key]))
+    } else {
+      bufferArr.push(encodeTypeAndField(index, obj[key]))
+      bufferArr.push(encodeBinary(obj[key], index, true))
+    }
+  })
+
+  let bytes = Buffer.concat(bufferArr)
+
+  // add prefix
+  if (obj.aminoPrefix) {
+    const prefix = Buffer.from(obj.aminoPrefix, "hex")
+    bytes = Buffer.concat([prefix, bytes])
+  }
+
+  // Write byte-length prefixed.
+  if (isByteLenPrefix) {
+    const lenBytes = UVarInt.encode(bytes.length)
+    bytes = Buffer.concat([lenBytes, bytes])
+  }
+
+  return bytes
+}
+
+/**
+ * @category amino
+ * @param {Number} fieldNum object field index
+ * @param {Array} arr
+ * @param {Boolean} isByteLenPrefix
+ * @return {Buffer} bytes of array
+ */
+export const encodeArrayBinary = (
+  fieldNum: number | undefined,
+  arr: any[],
+  isByteLenPrefix?: boolean
+) => {
+  const result: any[] = []
+
+  arr.forEach((item) => {
+    result.push(encodeTypeAndField(fieldNum, item))
+
+    if (isDefaultValue(item)) {
+      result.push(Buffer.from("00", "hex"))
+      return
+    }
+
+    result.push(encodeBinary(item, fieldNum, true))
+  })
+
+  //encode length
+  if (isByteLenPrefix) {
+    const length = result.reduce((prev, item) => prev + item.length, 0)
+    result.unshift(UVarInt.encode(length))
+  }
+
+  return Buffer.concat(result)
+}
+
+// Write field key.
+const encodeTypeAndField = (index: number | undefined, field: any) => {
+  index = Number(index)
+  const value = ((index + 1) << 3) | typeToTyp3(field)
+  return UVarInt.encode(value)
+}
+
+const isDefaultValue = (obj: any) => {
+  if (obj === null) return false
+
+  return (
+    (is.number(obj) && obj === 0) ||
+    (is.string(obj) && obj === "") ||
+    (is.array(obj) && obj.length === 0) ||
+    (is.boolean(obj) && !obj)
+  )
+}
+
+export * from "./varint"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/amino/encoder/varint.ts b/node_modules/@binance-chain/javascript-sdk/src/amino/encoder/varint.ts
new file mode 100644
index 0000000..92d2b03
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/amino/encoder/varint.ts
@@ -0,0 +1,70 @@
+import BN from "bn.js"
+
+function VarIntFunc(signed: boolean) {
+  const encodingLength = (n: number) => {
+    if (signed) n *= 2
+    if (n < 0) {
+      throw Error("varint value is out of bounds")
+    }
+    const bits = Math.log2(n + 1)
+    return Math.ceil(bits / 7) || 1
+  }
+
+  const encode = (n: number, buffer?: Buffer | any, offset?: number) => {
+    if (n < 0) {
+      throw Error("varint value is out of bounds")
+    }
+
+    buffer = buffer || Buffer.alloc(encodingLength(n))
+    offset = offset || 0
+    const nStr = n.toString()
+    let bn = new BN(nStr, 10)
+    const num255 = new BN(0xff)
+    const num128 = new BN(0x80)
+
+    // amino signed varint is multiplied by 2
+    if (signed) {
+      bn = bn.muln(2)
+    }
+
+    let i = 0
+    while (bn.gten(0x80)) {
+      buffer[offset + i] = bn.and(num255).or(num128).toNumber()
+      bn = bn.shrn(7)
+      i++
+    }
+
+    buffer[offset + i] = bn.andln(0xff)
+
+    // TODO
+    // encode.bytes = i + 1
+
+    return buffer
+  }
+
+  /**
+   * https://github.com/golang/go/blob/master/src/encoding/binary/varint.go#L60
+   */
+  const decode = (bytes: Buffer | any) => {
+    let x = 0
+    let s = 0
+    for (let i = 0, len = bytes.length; i < len; i++) {
+      const b = bytes[i]
+      if (b < 0x80) {
+        if (i > 9 || (i === 9 && b > 1)) {
+          return 0
+        }
+        return x | (b << s)
+      }
+      x |= (b & 0x7f) << s
+      s += 7
+    }
+
+    return 0
+  }
+
+  return { encode, decode, encodingLength }
+}
+
+export const UVarInt = VarIntFunc(false)
+export const VarInt = VarIntFunc(true)
diff --git a/node_modules/@binance-chain/javascript-sdk/src/amino/index.ts b/node_modules/@binance-chain/javascript-sdk/src/amino/index.ts
new file mode 100644
index 0000000..106e15c
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/amino/index.ts
@@ -0,0 +1,8 @@
+import * as decoder from "./decoder"
+import * as encoder from "./encoder"
+
+//backward compatibility
+export { decoder, encoder }
+
+export * from "./decoder"
+export * from "./encoder"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/client/bridge/index.ts b/node_modules/@binance-chain/javascript-sdk/src/client/bridge/index.ts
new file mode 100644
index 0000000..ec77628
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/client/bridge/index.ts
@@ -0,0 +1,329 @@
+import { BncClient } from "../"
+import { checkAddress, decodeAddress } from "../../crypto"
+import {
+  TransferInClaim,
+  ClaimMsg,
+  ClaimTypes,
+  TransferOutRefundClaim,
+  BindMsg,
+  BaseMsg,
+  TransferOutMsg,
+  UpdateBindClaim,
+} from "../../types"
+
+/**
+ * Bridge
+ */
+export class Bridge {
+  private _bncClient!: BncClient
+
+  /**
+   * @param {BncClient} bncClient
+   */
+  constructor(bncClient: BncClient) {
+    this._bncClient = bncClient
+  }
+
+  /**
+   * transfer smart chain token to binance chain receiver
+   */
+  public async transferIn({
+    sequence,
+    contract_address,
+    refund_addresses,
+    receiver_addresses,
+    amounts,
+    relay_fee,
+    expire_time,
+    symbol,
+    fromAddress,
+  }: TransferInClaim & { sequence: number; fromAddress: string }) {
+    if (sequence < 0) {
+      throw new Error("sequence should not be less than 0")
+    }
+
+    if (!contract_address) {
+      throw new Error("contract address should not be empty")
+    }
+
+    if (!relay_fee) {
+      throw new Error("relay fee should not be empty")
+    }
+
+    if (!symbol) {
+      throw new Error("symbol should not be null")
+    }
+
+    if (!checkAddress(fromAddress, this._bncClient.addressPrefix)) {
+      throw new Error("fromAddress is not a valid Binance Chain address")
+    }
+
+    if (
+      refund_addresses.length != receiver_addresses.length ||
+      refund_addresses.length != amounts.length
+    ) {
+      throw new Error(
+        "the length of refund address array, recipient address array and transfer amount array must be the same"
+      )
+    }
+
+    const receiverAddresses = receiver_addresses.map((address) => {
+      const addressHrp = address.startsWith("tbnb") ? "tbnb" : "bnb"
+      if (!checkAddress(address, addressHrp)) {
+        throw new Error(
+          `${address} in receiver_addresses is not a valid Binance Chain address`
+        )
+      }
+
+      return decodeAddress(address)
+    })
+
+    const refundAddresses = refund_addresses.map((address) => {
+      if (!address.startsWith("0x")) {
+        throw new Error(`${address} is invalid`)
+      }
+
+      return Buffer.from(address.slice(2), "hex")
+    })
+
+    const claimHex = Buffer.from(
+      JSON.stringify({
+        contract_address,
+        refund_addresses: refundAddresses,
+        receiver_addresses: receiverAddresses,
+        amounts,
+        symbol,
+        relay_fee,
+        expire_time,
+      })
+    ).toString("hex")
+
+    return this.buildClaimAndBroadcast({
+      claimHex,
+      claim_type: ClaimTypes.ClaimTypeTransferIn,
+      fromAddress,
+      sequence,
+    })
+  }
+
+  /**
+   * refund tokens to sender if transfer to smart chain failed
+   */
+  public async transferOutRefund({
+    transfer_out_sequence,
+    refund_address,
+    refund_reason,
+    amount,
+    fromAddress,
+  }: TransferOutRefundClaim & {
+    fromAddress: string
+  }) {
+    if (transfer_out_sequence < 0) {
+      throw new Error("sequence should not be less than 0")
+    }
+
+    if (!amount) {
+      throw new Error("amount should not be empty")
+    }
+
+    if (!refund_reason) {
+      throw new Error("empty refund reason")
+    }
+
+    if (!checkAddress(fromAddress, this._bncClient.addressPrefix)) {
+      throw new Error("fromAddress is not a valid Binance Chain address")
+    }
+
+    const claimHex = Buffer.from(
+      JSON.stringify({
+        transfer_out_sequence,
+        refund_address,
+        amount,
+        refund_reason,
+      })
+    ).toString("hex")
+
+    return this.buildClaimAndBroadcast({
+      claimHex,
+      claim_type: ClaimTypes.ClaimTypeTransferOutRefund,
+      sequence: transfer_out_sequence,
+      fromAddress,
+    })
+  }
+
+  /**
+   * bind smart chain token to bep2 token
+   */
+  public async bind({
+    contractAddress,
+    contractDecimal,
+    amount,
+    symbol,
+    expireTime,
+    fromAddress,
+  }: {
+    contractAddress: string
+    contractDecimal: number
+    amount: number
+    symbol: string
+    expireTime: number
+    fromAddress: string
+  }) {
+    if (!checkAddress(fromAddress, this._bncClient.addressPrefix)) {
+      throw new Error("fromAddress is not a valid Binance Chain address")
+    }
+
+    if (!contractAddress.startsWith("0x")) {
+      throw new Error(`contractAddress "${contractAddress}" is invalid`)
+    }
+
+    const bindMsg = new BindMsg({
+      from: fromAddress,
+      amount: amount,
+      contract_address: contractAddress,
+      contract_decimals: contractDecimal,
+      expire_time: expireTime,
+      symbol: symbol,
+    })
+
+    return await this.broadcast(bindMsg, fromAddress)
+  }
+
+  /**
+   * transfer token from Binance Chain to Binance Smart Chain
+   */
+  public async transferFromBcToBsc({
+    toAddress,
+    amount,
+    symbol,
+    expireTime,
+    fromAddress,
+  }: {
+    toAddress: string
+    amount: number
+    symbol: string
+    expireTime: number
+    fromAddress: string
+  }) {
+    if (!checkAddress(fromAddress, this._bncClient.addressPrefix)) {
+      throw new Error("fromAddress is not a valid Binance Chain address")
+    }
+
+    if (!toAddress.startsWith("0x")) {
+      throw new Error(`toAddress "${toAddress}" is invalid`)
+    }
+
+    const transferOut = new TransferOutMsg({
+      from: fromAddress,
+      to: toAddress,
+      amount: { denom: symbol, amount },
+      expire_time: expireTime,
+    })
+
+    return this.broadcast(transferOut, fromAddress)
+  }
+
+  /**
+   * update bind request when events from smart chain received
+   */
+  public async upateBind({
+    sequence,
+    contract_address,
+    symbol,
+    status,
+    fromAddress,
+  }: UpdateBindClaim & {
+    sequence: number
+    fromAddress: string
+  }) {
+    if (!checkAddress(fromAddress, this._bncClient.addressPrefix)) {
+      throw new Error("fromAddress is not a valid Binance Chain address")
+    }
+
+    if (!contract_address.startsWith("0x")) {
+      throw new Error(`toAddress "${contract_address}" is invalid`)
+    }
+
+    const claimHex = Buffer.from(
+      JSON.stringify({
+        status,
+        symbol,
+        contract_address,
+      })
+    ).toString("hex")
+
+    return this.buildClaimAndBroadcast({
+      claimHex,
+      sequence,
+      fromAddress,
+      claim_type: ClaimTypes.ClaimTypeUpdateBind,
+    })
+  }
+
+  public async skipSequence({
+    sequence,
+    sequenceToSkip,
+    fromAddress,
+  }: {
+    sequence: number
+    sequenceToSkip: number
+    fromAddress: string
+  }) {
+    if (sequence < 0) {
+      throw new Error("sequence should not be less than 0")
+    }
+
+    if (!checkAddress(fromAddress, this._bncClient.addressPrefix)) {
+      throw new Error("fromAddress is not a valid Binance Chain address")
+    }
+
+    const claimHex = Buffer.from(
+      JSON.stringify({
+        claim_type: ClaimTypes.ClaimTypeUpdateBind,
+        sequence: sequenceToSkip,
+      })
+    ).toString("hex")
+
+    return this.buildClaimAndBroadcast({
+      claimHex,
+      sequence,
+      fromAddress,
+      claim_type: ClaimTypes.ClaimTypeSkipSequence,
+    })
+  }
+
+  private async buildClaimAndBroadcast({
+    claimHex,
+    claim_type,
+    sequence,
+    fromAddress,
+  }: {
+    claimHex: string
+    claim_type: ClaimTypes
+    sequence: number
+    fromAddress: string
+  }) {
+    const claimMsg = new ClaimMsg({
+      claim_type,
+      sequence,
+      claim: claimHex,
+      validator_address: fromAddress,
+    })
+
+    return await this.broadcast(claimMsg, fromAddress, sequence)
+  }
+
+  private async broadcast(
+    msg: BaseMsg,
+    fromAddress: string,
+    sequence?: number
+  ) {
+    const signedTx = await this._bncClient._prepareTransaction(
+      msg.getMsg(),
+      msg.getSignMsg(),
+      fromAddress,
+      sequence
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/client/gov/index.ts b/node_modules/@binance-chain/javascript-sdk/src/client/gov/index.ts
new file mode 100644
index 0000000..c899195
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/client/gov/index.ts
@@ -0,0 +1,257 @@
+import Big, { BigSource } from "big.js"
+
+import { BncClient } from ".." // This is a circular dependecy; should be changed to `import type` asap
+import * as crypto from "../../crypto"
+import { Coin, AminoPrefix } from "../../types"
+import { checkCoins } from "../../utils/validateHelper"
+
+import proposalType from "./proposalType"
+
+const BASENUMBER = Math.pow(10, 8)
+
+const proposalTypeMapping = {
+  0x04: "ListTradingPair",
+  0x00: "Nil",
+  0x01: "Text",
+  0x02: "ParameterChange",
+  0x03: "SoftwareUpgrade",
+  0x05: "FeeChange",
+  0x06: "CreateValidator",
+  0x07: "RemoveValidator",
+} as const
+
+/**
+ * VoteOption
+ * @ignore
+ * @example
+ * OptionEmpty - 0x00
+ * OptionYes - 0x01
+ * OptionAbstain - 0x02
+ * OptionNo - 0x03
+ * OptionNoWithVeto - 0x04
+ */
+export const voteOption = {
+  OptionEmpty: 0x00,
+  OptionYes: 0x01,
+  OptionAbstain: 0x02,
+  OptionNo: 0x03,
+  OptionNoWithVeto: 0x04,
+} as const
+
+const voteOptionMapping = {
+  0x00: "Empty",
+  0x01: "Yes",
+  0x02: "Abstain",
+  0x03: "No",
+  0x04: "NoWithVeto",
+}
+
+class Gov {
+  static instance: Gov
+  private _bncClient!: BncClient
+
+  /**
+   * @param {Object} bncClient
+   */
+  constructor(bncClient: BncClient) {
+    if (!Gov.instance) {
+      this._bncClient = bncClient
+      Gov.instance = this
+    }
+
+    return Gov.instance
+  }
+
+  /**
+   * Submit a list proposal along with an initial deposit
+   * @param {Object} listParams
+   * @example
+   * var listParams = {
+   *  title: 'New trading pair',
+   *  description: '',
+   *  baseAsset: 'BTC',
+   *  quoteAsset: 'BNB',
+   *  initPrice: 1,
+   *  address: '',
+   *  initialDeposit: 2000,
+   *  expireTime: 1570665600,
+   *  votingPeriod: 604800
+   * }
+   */
+  async submitListProposal(listParams: {
+    baseAsset: string
+    quoteAsset: string
+    initPrice: BigSource
+    description: string
+    expireTime: string
+    address: string
+    title: string
+    initialDeposit: BigSource
+    votingPeriod: BigSource
+  }) {
+    const listTradingPairObj = {
+      base_asset_symbol: listParams.baseAsset,
+      quote_asset_symbol: listParams.quoteAsset,
+      init_price: +new Big(listParams.initPrice).mul(BASENUMBER).toString(),
+      description: listParams.description,
+      expire_time: new Date(listParams.expireTime).toISOString(),
+    }
+
+    const description = JSON.stringify(listTradingPairObj)
+    const { address, title, initialDeposit, votingPeriod } = listParams
+    return await this.submitProposal(
+      address,
+      title,
+      description,
+      proposalType.ProposalTypeListTradingPair,
+      initialDeposit,
+      votingPeriod
+    )
+  }
+
+  /**
+   * Submit a proposal along with an initial deposit.
+   * Proposal title, description, type and deposit can
+   * be given directly or through a proposal JSON file.
+   * @param {String} address
+   * @param {String} title
+   * @param {String} description
+   * @param {Number} proposalType
+   * @param {Number} initialDeposit
+   * @param {String} votingPeriod
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async submitProposal(
+    address: string,
+    title: string,
+    description: string,
+    proposalType: keyof typeof proposalTypeMapping,
+    initialDeposit: BigSource,
+    votingPeriod: BigSource
+  ) {
+    const accAddress = crypto.decodeAddress(address)
+    const coins = [
+      {
+        denom: "BNB",
+        amount: new Big(initialDeposit).mul(BASENUMBER).toString(),
+      },
+    ]
+
+    votingPeriod = +new Big(votingPeriod).mul(10 ** 9).toString()
+
+    const proposalMsg = {
+      title,
+      description,
+      proposal_type: proposalType,
+      proposer: accAddress,
+      initial_deposit: [
+        {
+          denom: "BNB",
+          amount: +new Big(initialDeposit).mul(BASENUMBER).toString(),
+        },
+      ],
+      voting_period: votingPeriod,
+      aminoPrefix: AminoPrefix.MsgSubmitProposal,
+    }
+
+    const signMsg = {
+      description,
+      initial_deposit: coins,
+      proposal_type: proposalTypeMapping[proposalType],
+      proposer: address,
+      title,
+      voting_period: votingPeriod.toString(),
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      proposalMsg,
+      signMsg,
+      address
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * Deposit tokens for activing proposal
+   * @param {Number} proposalId
+   * @param {String} address
+   * @param {Array} coins
+   * @example
+   * var coins = [{
+   *   "denom": "BNB",
+   *   "amount": 10
+   * }]
+   */
+  async deposit(proposalId: number, address: string, coins: Coin[]) {
+    const accAddress = crypto.decodeAddress(address)
+
+    checkCoins(coins)
+
+    const amount: Coin[] = []
+    coins.forEach((coin) => {
+      amount.push({
+        denom: coin.denom,
+        amount: +new Big(coin.amount).mul(BASENUMBER).toString(),
+      })
+    })
+
+    const depositMsg = {
+      proposal_id: proposalId,
+      depositer: accAddress,
+      amount,
+      aminoPrefix: AminoPrefix.MsgDeposit,
+    }
+
+    const signMsg = {
+      amount: amount.map((coin) => ({
+        denom: coin.denom,
+        amount: String(coin.amount),
+      })),
+      depositer: address,
+      proposal_id: String(proposalId),
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      depositMsg,
+      signMsg,
+      address
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   *
+   * @param {Number} proposalId
+   * @param {String} voter
+   * @param {VoteOption} option
+   */
+  async vote(
+    proposalId: number,
+    voter: string,
+    option: keyof typeof voteOptionMapping
+  ) {
+    const accAddress = crypto.decodeAddress(voter)
+
+    const voteMsg = {
+      proposal_id: proposalId,
+      voter: accAddress,
+      option,
+      aminoPrefix: AminoPrefix.MsgVote,
+    }
+
+    const signMsg = {
+      option: voteOptionMapping[option],
+      proposal_id: String(proposalId),
+      voter,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      voteMsg,
+      signMsg,
+      voter
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+}
+
+export default Gov
diff --git a/node_modules/@binance-chain/javascript-sdk/src/client/gov/proposalType.ts b/node_modules/@binance-chain/javascript-sdk/src/client/gov/proposalType.ts
new file mode 100644
index 0000000..799173c
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/client/gov/proposalType.ts
@@ -0,0 +1,19 @@
+const ProposalTypeNil = 0x00
+const ProposalTypeText = 0x01
+const ProposalTypeParameterChange = 0x02
+const ProposalTypeSoftwareUpgrade = 0x03
+const ProposalTypeListTradingPair = 0x04
+const ProposalTypeFeeChange = 0x05
+const ProposalTypeCreateValidator = 0x06
+const ProposalTypeRemoveValidator = 0x07
+
+export default {
+  ProposalTypeNil,
+  ProposalTypeText,
+  ProposalTypeParameterChange,
+  ProposalTypeSoftwareUpgrade,
+  ProposalTypeListTradingPair,
+  ProposalTypeFeeChange,
+  ProposalTypeCreateValidator,
+  ProposalTypeRemoveValidator,
+} as const
diff --git a/node_modules/@binance-chain/javascript-sdk/src/client/index.ts b/node_modules/@binance-chain/javascript-sdk/src/client/index.ts
new file mode 100644
index 0000000..1293a3b
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/client/index.ts
@@ -0,0 +1,1254 @@
+/* eslint-disable */
+import Big, { BigSource } from "big.js"
+
+import * as crypto from "../crypto"
+import LedgerApp, { PublicKey, SignedSignature } from "../ledger/ledger-app"
+import Transaction from "../tx"
+import { AminoPrefix, Coin, ListMiniMsg } from "../types/"
+import HttpRequest from "../utils/request"
+import { checkNumber } from "../utils/validateHelper"
+
+import Gov from "./gov"
+import Swap from "./swap"
+import TokenManagement, { validateMiniTokenSymbol } from "./token"
+import { Bridge } from "./bridge"
+import { Stake } from "./stake"
+
+const BASENUMBER = Math.pow(10, 8)
+
+export const api = {
+  broadcast: "/api/v1/broadcast",
+  nodeInfo: "/api/v1/node-info",
+  getAccount: "/api/v1/account",
+  getMarkets: "/api/v1/markets",
+  getSwaps: "/api/v1/atomic-swaps",
+  getOpenOrders: "/api/v1/orders/open",
+  getDepth: "/api/v1/depth",
+  getTransactions: "/api/v1/transactions",
+  getTxs: "/bc/api/v1/txs",
+  getTx: "/api/v1/tx",
+}
+
+export const NETWORK_PREFIX_MAPPING = {
+  testnet: "tbnb",
+  mainnet: "bnb",
+} as const
+
+export type Transfer = { to: string; coins: Coin[] }
+
+/**
+ * The default signing delegate which uses the local private key.
+ * @param  {Transaction} tx      the transaction
+ * @param  {Object}      signMsg the canonical sign bytes for the msg
+ * @return {Transaction}
+ */
+export const DefaultSigningDelegate = async function (
+  this: BncClient,
+  tx: Transaction,
+  signMsg?: any
+): Promise<Transaction> {
+  const privateKey = this.getPrivateKey()
+  if (!privateKey) {
+    return Promise.reject(
+      "Private key has to be set before signing a transaction"
+    )
+  }
+  return tx.sign(privateKey, signMsg)
+}
+
+/**
+ * The default broadcast delegate which immediately broadcasts a transaction.
+ * @param {Transaction} signedTx the signed transaction
+ */
+export const DefaultBroadcastDelegate = async function (
+  this: BncClient,
+  signedTx: Transaction
+) {
+  return this.sendTransaction(signedTx, true)
+}
+
+/**
+ * The Ledger signing delegate.
+ * @param  {LedgerApp}  ledgerApp
+ * @param  {preSignCb}  function
+ * @param  {postSignCb} function
+ * @param  {errCb} function
+ * @return {function}
+ */
+export const LedgerSigningDelegate = (
+  ledgerApp: LedgerApp,
+  preSignCb: (preSignCb: Buffer) => void,
+  postSignCb: (pubKeyResp: PublicKey, sigResp: SignedSignature) => void,
+  errCb: (error: any) => void,
+  hdPath: number[]
+): typeof DefaultSigningDelegate =>
+  async function (tx, signMsg) {
+    const signBytes = tx.getSignBytes(signMsg)
+    preSignCb && preSignCb(signBytes)
+    let pubKeyResp: PublicKey, sigResp: SignedSignature
+    try {
+      pubKeyResp = await ledgerApp.getPublicKey(hdPath)
+      sigResp = await ledgerApp.sign(signBytes, hdPath)
+      postSignCb && postSignCb(pubKeyResp, sigResp)
+    } catch (err) {
+      console.warn("LedgerSigningDelegate error", err)
+      errCb && errCb(err)
+    }
+    if (sigResp! && sigResp!.signature) {
+      const pubKey = crypto.getPublicKey(pubKeyResp!.pk!.toString("hex"))
+      return tx.addSignature(pubKey, sigResp!.signature)
+    }
+    return tx
+  }
+
+/**
+ * validate the input number.
+ * @param {Array} outputs
+ */
+const checkOutputs = (outputs: Transfer[]) => {
+  outputs.forEach((transfer) => {
+    const coins = transfer.coins || []
+    coins.forEach((coin) => {
+      checkNumber(coin.amount)
+      if (!coin.denom) {
+        throw new Error("invalid denmon")
+      }
+    })
+  })
+}
+
+/**
+ * sum corresponding input coin
+ * @param {Array} inputs
+ * @param {Array} coins
+ */
+const calInputCoins = (inputs: Array<{ coins: Coin[] }>, coins: Coin[]) => {
+  coins.forEach((coin) => {
+    const existCoin = inputs[0].coins.find((c) => c.denom === coin.denom)
+    if (existCoin) {
+      const existAmount = new Big(existCoin.amount)
+      existCoin.amount = Number(existAmount.plus(coin.amount).toString())
+    } else {
+      inputs[0].coins.push({ ...coin })
+    }
+  })
+}
+
+/**
+ * The Binance Chain client.
+ */
+export class BncClient {
+  public _httpClient: HttpRequest
+  public _signingDelegate: typeof DefaultSigningDelegate
+  public _broadcastDelegate: typeof DefaultBroadcastDelegate
+  public _useAsyncBroadcast: boolean
+  public _source: number
+  public tokens: TokenManagement
+  public swap: Swap
+  public gov: Gov
+  public bridge: Bridge
+  public stake: Stake
+  public chainId?: string | null
+  public addressPrefix: typeof NETWORK_PREFIX_MAPPING[keyof typeof NETWORK_PREFIX_MAPPING] =
+    "tbnb"
+  public network: keyof typeof NETWORK_PREFIX_MAPPING = "testnet"
+  public address?: string
+  public _setPkPromise?: ReturnType<HttpRequest["request"]>
+  public account_number?: string | number
+
+  private _privateKey: string | null = null
+
+  /**
+   * @param {String} server Binance Chain public url
+   * @param {Boolean} useAsyncBroadcast use async broadcast mode, faster but less guarantees (default off)
+   * @param {Number} source where does this transaction come from (default 0)
+   */
+  constructor(server: string, useAsyncBroadcast = false, source = 0) {
+    if (!server) {
+      throw new Error("Binance chain server should not be null")
+    }
+    this._httpClient = new HttpRequest(server)
+    this._signingDelegate = DefaultSigningDelegate
+    this._broadcastDelegate = DefaultBroadcastDelegate
+    this._useAsyncBroadcast = useAsyncBroadcast
+    this._source = source
+    this.tokens = new TokenManagement(this)
+    this.swap = new Swap(this)
+    this.gov = new Gov(this)
+    this.bridge = new Bridge(this)
+    this.stake = new Stake(this)
+  }
+
+  /**
+   * Initialize the client with the chain's ID. Asynchronous.
+   * @return {Promise}
+   */
+  async initChain() {
+    if (!this.chainId) {
+      const data = await this._httpClient.request("get", api.nodeInfo)
+      this.chainId = data.result.node_info && data.result.node_info.network
+    }
+    return this
+  }
+
+  /**
+   * Sets the client network (testnet or mainnet).
+   * @param {String} network Indicate testnet or mainnet
+   */
+  chooseNetwork(network: keyof typeof NETWORK_PREFIX_MAPPING) {
+    this.addressPrefix = NETWORK_PREFIX_MAPPING[network] || "tbnb"
+    this.network = NETWORK_PREFIX_MAPPING[network] ? network : "testnet"
+  }
+
+  /**
+   * Sets the client's private key for calls made by this client. Asynchronous.
+   * @param {string} privateKey the private key hexstring
+   * @param {boolean} localOnly set this to true if you will supply an account_number yourself via `setAccountNumber`. Warning: You must do that if you set this to true!
+   * @return {Promise}
+   */
+  async setPrivateKey(privateKey: string, localOnly = false) {
+    if (privateKey !== this._privateKey) {
+      const address = crypto.getAddressFromPrivateKey(
+        privateKey,
+        this.addressPrefix
+      )
+      if (!address)
+        throw new Error(`address is falsy: ${address}. invalid private key?`)
+
+      this._privateKey = privateKey
+      this.address = address
+      if (!localOnly) {
+        // _setPkPromise is used in _sendTransaction for non-await calls
+        try {
+          const promise = (this._setPkPromise = this._httpClient.request(
+            "get",
+            `${api.getAccount}/${address}`
+          ))
+          const data = await promise
+          this.account_number = data.result.account_number
+        } catch (e) {
+          throw new Error(
+            `unable to query the address on the blockchain. try sending it some funds first: ${address}`
+          )
+        }
+      }
+    }
+    return this
+  }
+
+  /**
+   * Removes client's private key.
+   * @return {BncClient} this instance (for chaining)
+   */
+  removePrivateKey() {
+    this._privateKey = null
+    return this
+  }
+
+  /**
+   * Gets client's private key.
+   * @return {string|null} the private key hexstring or `null` if no private key has been set
+   */
+  getPrivateKey() {
+    return this._privateKey
+  }
+
+  /**
+   * Sets the client's account number.
+   * @param {number} accountNumber
+   */
+  setAccountNumber(accountNumber: number) {
+    this.account_number = accountNumber
+  }
+
+  /**
+   * Use async broadcast mode. Broadcasts faster with less guarantees (default off)
+   * @param {Boolean} useAsyncBroadcast
+   * @return {BncClient} this instance (for chaining)
+   */
+  useAsyncBroadcast(useAsyncBroadcast = true): BncClient {
+    this._useAsyncBroadcast = useAsyncBroadcast
+    return this
+  }
+
+  /**
+   * Sets the signing delegate (for wallet integrations).
+   * @param {function} delegate
+   * @return {BncClient} this instance (for chaining)
+   */
+  setSigningDelegate(delegate: BncClient["_signingDelegate"]): BncClient {
+    if (typeof delegate !== "function")
+      throw new Error("signing delegate must be a function")
+    this._signingDelegate = delegate
+    return this
+  }
+
+  /**
+   * Sets the broadcast delegate (for wallet integrations).
+   * @param {function} delegate
+   * @return {BncClient} this instance (for chaining)
+   */
+  setBroadcastDelegate(delegate: BncClient["_broadcastDelegate"]): BncClient {
+    if (typeof delegate !== "function")
+      throw new Error("broadcast delegate must be a function")
+    this._broadcastDelegate = delegate
+    return this
+  }
+
+  /**
+   * Applies the default signing delegate.
+   * @return {BncClient} this instance (for chaining)
+   */
+  useDefaultSigningDelegate(): BncClient {
+    this._signingDelegate = DefaultSigningDelegate
+    return this
+  }
+
+  /**
+   * Applies the default broadcast delegate.
+   * @return {BncClient} this instance (for chaining)
+   */
+  useDefaultBroadcastDelegate(): BncClient {
+    this._broadcastDelegate = DefaultBroadcastDelegate
+    return this
+  }
+
+  /**
+   * Applies the Ledger signing delegate.
+   * @param {function} ledgerApp
+   * @param {function} preSignCb
+   * @param {function} postSignCb
+   * @param {function} errCb
+   * @return {BncClient} this instance (for chaining)
+   */
+  useLedgerSigningDelegate(...args: Parameters<typeof LedgerSigningDelegate>) {
+    this._signingDelegate = LedgerSigningDelegate(...args)
+    return this
+  }
+
+  /**
+   * Transfer tokens from one address to another.
+   * @param {String} fromAddress
+   * @param {String} toAddress
+   * @param {Number} amount
+   * @param {String} asset
+   * @param {String} memo optional memo
+   * @param {Number} sequence optional sequence
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async transfer(
+    fromAddress: string,
+    toAddress: string,
+    amount: BigSource,
+    asset: string,
+    memo = "",
+    sequence: number | null = null
+  ) {
+    const accCode = crypto.decodeAddress(fromAddress)
+    const toAccCode = crypto.decodeAddress(toAddress)
+
+    amount = new Big(amount)
+    amount = Number(amount.mul(BASENUMBER).toString())
+
+    checkNumber(amount, "amount")
+
+    const coin = {
+      denom: asset,
+      amount: amount,
+    }
+
+    const msg = {
+      inputs: [
+        {
+          address: accCode,
+          coins: [coin],
+        },
+      ],
+      outputs: [
+        {
+          address: toAccCode,
+          coins: [coin],
+        },
+      ],
+      aminoPrefix: AminoPrefix.MsgSend,
+    }
+
+    const signMsg = {
+      inputs: [
+        {
+          address: fromAddress,
+          coins: [
+            {
+              amount: amount,
+              denom: asset,
+            },
+          ],
+        },
+      ],
+      outputs: [
+        {
+          address: toAddress,
+          coins: [
+            {
+              amount: amount,
+              denom: asset,
+            },
+          ],
+        },
+      ],
+    }
+
+    const signedTx = await this._prepareTransaction(
+      msg,
+      signMsg,
+      fromAddress,
+      sequence,
+      memo
+    )
+    return this._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * Create and sign a multi send tx
+   * @param {String} fromAddress
+   * @param {Array} outputs
+   * @example
+   * const outputs = [
+   * {
+   *   "to": "tbnb1p4kpnj5qz5spsaf0d2555h6ctngse0me5q57qe",
+   *   "coins": [{
+   *     "denom": "BNB",
+   *     "amount": 10
+   *   },{
+   *     "denom": "BTC",
+   *     "amount": 10
+   *   }]
+   * },
+   * {
+   *   "to": "tbnb1scjj8chhhp7lngdeflltzex22yaf9ep59ls4gk",
+   *   "coins": [{
+   *     "denom": "BTC",
+   *     "amount": 10
+   *   },{
+   *     "denom": "BNB",
+   *     "amount": 10
+   *   }]
+   * }]
+   * @param {String} memo optional memo
+   * @param {Number} sequence optional sequence
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async multiSend(
+    fromAddress: string,
+    outputs: Transfer[],
+    memo = "",
+    sequence: number | null = null
+  ) {
+    if (!fromAddress) {
+      throw new Error("fromAddress should not be falsy")
+    }
+
+    if (!Array.isArray(outputs)) {
+      throw new Error("outputs should be array")
+    }
+
+    checkOutputs(outputs)
+
+    //sort denom by alphbet and init amount
+    outputs.forEach((item) => {
+      item.coins = item.coins.sort((a, b) => a.denom.localeCompare(b.denom))
+      item.coins.forEach((coin) => {
+        const amount = new Big(coin.amount)
+        coin.amount = Number(amount.mul(BASENUMBER).toString())
+      })
+    })
+
+    type AddressBufferCoins = { address: Buffer; coins: Coin[] }
+    type AddressStringCoins = { address: string; coins: Coin[] }
+
+    const fromAddrCode = crypto.decodeAddress(fromAddress)
+    const inputs: AddressBufferCoins[] = [{ address: fromAddrCode, coins: [] }]
+    const transfers: AddressBufferCoins[] = []
+
+    outputs.forEach((item) => {
+      const toAddcCode = crypto.decodeAddress(item.to)
+      calInputCoins(inputs, item.coins)
+      transfers.push({ address: toAddcCode, coins: item.coins })
+    })
+
+    const msg = {
+      inputs,
+      outputs: transfers,
+      aminoPrefix: AminoPrefix.MsgSend,
+    }
+
+    const signInputs = [{ address: fromAddress, coins: [] }]
+    const signOutputs: AddressStringCoins[] = []
+
+    outputs.forEach((item, index) => {
+      signOutputs.push({ address: item.to, coins: [] })
+      item.coins.forEach((c) => {
+        signOutputs[index].coins.push(c)
+      })
+      calInputCoins(signInputs, item.coins)
+    })
+
+    const signMsg = {
+      inputs: signInputs,
+      outputs: signOutputs,
+    }
+
+    const signedTx = await this._prepareTransaction(
+      msg,
+      signMsg,
+      fromAddress,
+      sequence,
+      memo
+    )
+    return this._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * Cancel an order.
+   * @param {String} fromAddress
+   * @param {String} symbol the market pair
+   * @param {String} refid the order ID of the order to cancel
+   * @param {Number} sequence optional sequence
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async cancelOrder(
+    fromAddress: string,
+    symbol: string,
+    refid: string,
+    sequence: number | null = null
+  ) {
+    const accCode = crypto.decodeAddress(fromAddress)
+
+    const msg = {
+      sender: accCode,
+      symbol: symbol,
+      refid: refid,
+      aminoPrefix: AminoPrefix.CancelOrderMsg,
+    }
+
+    const signMsg = {
+      refid: refid,
+      sender: fromAddress,
+      symbol: symbol,
+    }
+
+    const signedTx = await this._prepareTransaction(
+      msg,
+      signMsg,
+      fromAddress,
+      sequence,
+      ""
+    )
+    return this._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * Place an order.
+   * @param {String} address
+   * @param {String} symbol the market pair
+   * @param {Number} side (1-Buy, 2-Sell)
+   * @param {Number} price
+   * @param {Number} quantity
+   * @param {Number} sequence optional sequence
+   * @param {Number} timeinforce (1-GTC(Good Till Expire), 3-IOC(Immediate or Cancel))
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async placeOrder(
+    address: string = this.address!,
+    symbol: string,
+    side: number,
+    price: number,
+    quantity: number,
+    sequence: number | null = null,
+    timeinforce = 1
+  ) {
+    if (!address) {
+      throw new Error("address should not be falsy")
+    }
+    if (!symbol) {
+      throw new Error("symbol should not be falsy")
+    }
+    if (side !== 1 && side !== 2) {
+      throw new Error("side can only be 1 or 2")
+    }
+    if (timeinforce !== 1 && timeinforce !== 3) {
+      throw new Error("timeinforce can only be 1 or 3")
+    }
+
+    const accCode = crypto.decodeAddress(address)
+
+    if (sequence !== 0 && !sequence) {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getAccount}/${address}`
+      )
+      sequence = data.result && data.result.sequence
+    }
+
+    const bigPrice = new Big(price)
+    const bigQuantity = new Big(quantity)
+
+    const placeOrderMsg = {
+      sender: accCode,
+      id: `${accCode.toString("hex")}-${sequence! + 1}`.toUpperCase(),
+      symbol: symbol,
+      ordertype: 2,
+      side,
+      price: parseFloat(bigPrice.mul(BASENUMBER).toString()),
+      quantity: parseFloat(bigQuantity.mul(BASENUMBER).toString()),
+      timeinforce: timeinforce,
+      aminoPrefix: AminoPrefix.NewOrderMsg,
+    }
+
+    const signMsg = {
+      id: placeOrderMsg.id,
+      ordertype: placeOrderMsg.ordertype,
+      price: placeOrderMsg.price,
+      quantity: placeOrderMsg.quantity,
+      sender: address,
+      side: placeOrderMsg.side,
+      symbol: placeOrderMsg.symbol,
+      timeinforce: timeinforce,
+    }
+
+    checkNumber(placeOrderMsg.price, "price")
+    checkNumber(placeOrderMsg.quantity, "quantity")
+
+    const signedTx = await this._prepareTransaction(
+      placeOrderMsg,
+      signMsg,
+      address,
+      sequence,
+      ""
+    )
+
+    return this._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * @param {String} address
+   * @param {Number} proposalId
+   * @param {String} baseAsset
+   * @param {String} quoteAsset
+   * @param {Number} initPrice
+   * @param {Number} sequence optional sequence
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async list(
+    address: string,
+    proposalId: number,
+    baseAsset: string,
+    quoteAsset: string,
+    initPrice: number,
+    sequence: number | null = null
+  ) {
+    const accCode = crypto.decodeAddress(address)
+
+    if (!address) {
+      throw new Error("address should not be falsy")
+    }
+
+    if (proposalId <= 0) {
+      throw new Error("proposal id should larger than 0")
+    }
+
+    if (initPrice <= 0) {
+      throw new Error("price should larger than 0")
+    }
+
+    if (!baseAsset) {
+      throw new Error("baseAsset should not be falsy")
+    }
+
+    if (!quoteAsset) {
+      throw new Error("quoteAsset should not be falsy")
+    }
+
+    const init_price = Number(new Big(initPrice).mul(BASENUMBER).toString())
+
+    const listMsg = {
+      from: accCode,
+      proposal_id: proposalId,
+      base_asset_symbol: baseAsset,
+      quote_asset_symbol: quoteAsset,
+      init_price: init_price,
+      aminoPrefix: AminoPrefix.ListMsg,
+    }
+
+    const signMsg = {
+      base_asset_symbol: baseAsset,
+      from: address,
+      init_price: init_price,
+      proposal_id: proposalId,
+      quote_asset_symbol: quoteAsset,
+    }
+
+    const signedTx = await this._prepareTransaction(
+      listMsg,
+      signMsg,
+      address,
+      sequence,
+      ""
+    )
+    return this._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * list miniToken
+   */
+  async listMiniToken({
+    from,
+    baseAsset,
+    quoteAsset,
+    initPrice,
+    sequence = null,
+  }: {
+    from: string
+    baseAsset: string
+    quoteAsset: string
+    initPrice: number
+    sequence?: number | null
+  }) {
+    validateMiniTokenSymbol(baseAsset)
+
+    if (initPrice <= 0) {
+      throw new Error("price should larger than 0")
+    }
+
+    if (!from) {
+      throw new Error("address should not be falsy")
+    }
+
+    if (!quoteAsset) {
+      throw new Error("quoteAsset should not be falsy")
+    }
+
+    const init_price = Number(new Big(initPrice).mul(BASENUMBER).toString())
+
+    const listMiniMsg = new ListMiniMsg({
+      from,
+      base_asset_symbol: baseAsset,
+      quote_asset_symbol: quoteAsset,
+      init_price,
+    })
+
+    const signedTx = await this._prepareTransaction(
+      listMiniMsg.getMsg(),
+      listMiniMsg.getSignMsg(),
+      from,
+      sequence
+    )
+    return this._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * Set account flags
+   * @param {String} address
+   * @param {Number} flags new value of account flags
+   * @param {Number} sequence optional sequence
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async setAccountFlags(
+    address: string,
+    flags: number,
+    sequence: number | null = null
+  ) {
+    const accCode = crypto.decodeAddress(address)
+
+    const msg = {
+      from: accCode,
+      flags: flags,
+      aminoPrefix: AminoPrefix.SetAccountFlagsMsg,
+    }
+
+    const signMsg = {
+      flags: flags,
+      from: address,
+    }
+
+    const signedTx = await this._prepareTransaction(
+      msg,
+      signMsg,
+      address,
+      sequence,
+      ""
+    )
+    return this._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * Prepare a serialized raw transaction for sending to the blockchain.
+   * @param {Object} msg the msg object
+   * @param {Object} stdSignMsg the sign doc object used to generate a signature
+   * @param {String} address
+   * @param {Number} sequence optional sequence
+   * @param {String} memo optional memo
+   * @return {Transaction} signed transaction
+   */
+  async _prepareTransaction(
+    msg: any,
+    stdSignMsg: any,
+    address: string,
+    sequence: string | number | null = null,
+    memo = ""
+  ) {
+    if ((!this.account_number || (sequence !== 0 && !sequence)) && address) {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getAccount}/${address}`
+      )
+      sequence = data.result.sequence
+      this.account_number = data.result.account_number
+      // if user has not used `await` in its call to setPrivateKey (old API), we should wait for the promise here
+    } else if (this._setPkPromise) {
+      await this._setPkPromise
+    }
+
+    const tx = new Transaction({
+      accountNumber:
+        typeof this.account_number !== "number"
+          ? parseInt(this.account_number!)
+          : this.account_number,
+      chainId: this.chainId!,
+      memo: memo,
+      msg,
+      sequence: typeof sequence !== "number" ? parseInt(sequence!) : sequence,
+      source: this._source,
+    })
+
+    return this._signingDelegate.call(this, tx, stdSignMsg)
+  }
+
+  /**
+   * Broadcast a transaction to the blockchain.
+   * @param {signedTx} tx signed Transaction object
+   * @param {Boolean} sync use synchronous mode, optional
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async sendTransaction(signedTx: Transaction, sync: boolean) {
+    const signedBz = signedTx.serialize()
+    return this.sendRawTransaction(signedBz, sync)
+  }
+
+  /**
+   * Broadcast a raw transaction to the blockchain.
+   * @param {String} signedBz signed and serialized raw transaction
+   * @param {Boolean} sync use synchronous mode, optional
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async sendRawTransaction(signedBz: string, sync = !this._useAsyncBroadcast) {
+    const opts = {
+      data: signedBz,
+      headers: {
+        "content-type": "text/plain",
+      },
+    }
+    return this._httpClient.request(
+      "post",
+      `${api.broadcast}?sync=${sync}`,
+      null,
+      opts
+    )
+  }
+
+  /**
+   * Broadcast a raw transaction to the blockchain.
+   * @param {Object} msg the msg object
+   * @param {Object} stdSignMsg the sign doc object used to generate a signature
+   * @param {String} address
+   * @param {Number} sequence optional sequence
+   * @param {String} memo optional memo
+   * @param {Boolean} sync use synchronous mode, optional
+   * @return {Promise} resolves with response (success or fail)
+   */
+  async _sendTransaction(
+    msg: any,
+    stdSignMsg: any,
+    address: string,
+    sequence: string | number | null = null,
+    memo = "",
+    sync = !this._useAsyncBroadcast
+  ) {
+    const signedTx = await this._prepareTransaction(
+      msg,
+      stdSignMsg,
+      address,
+      sequence,
+      memo
+    )
+    return this.sendTransaction(signedTx, sync)
+  }
+
+  /**
+   * get account
+   * @param {String} address
+   * @return {Promise} resolves with http response
+   */
+  async getAccount(address = this.address) {
+    if (!address) {
+      throw new Error("address should not be falsy")
+    }
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getAccount}/${address}`
+      )
+      return data
+    } catch (err) {
+      return null
+    }
+  }
+
+  /**
+   * get balances
+   * @param {String} address optional address
+   * @return {Promise} resolves with http response
+   */
+  async getBalance(address = this.address) {
+    try {
+      const data = await this.getAccount(address)
+      return data!.result.balances
+    } catch (err) {
+      return []
+    }
+  }
+
+  /**
+   * get markets
+   * @param {Number} limit max 1000 is default
+   * @param {Number} offset from beggining, default 0
+   * @return {Promise} resolves with http response
+   */
+  async getMarkets(limit = 1000, offset = 0) {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getMarkets}?limit=${limit}&offset=${offset}`
+      )
+      return data
+    } catch (err) {
+      console.warn("getMarkets error", err)
+      return []
+    }
+  }
+
+  /**
+   * get transactions for an account
+   * @param {String} address optional address
+   * @param {Number} offset from beggining, default 0
+   * @return {Promise} resolves with http response
+   * @deprecated please use getTxs instead.
+   */
+  async getTransactions(address = this.address, offset = 0) {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getTransactions}?address=${address}&offset=${offset}`
+      )
+      return data
+    } catch (err) {
+      console.warn("getTransactions error", err)
+      return []
+    }
+  }
+
+  /**
+   * get transactions for an account
+   * @param {String} address optional address
+   * @param {Number} startTime start time in milliseconds
+   * @param {Number} endTime end time in in milliseconds, endTime - startTime should be smaller than 7 days
+   * @return {Promise} resolves with http response ([more details](https://docs.binance.org/api-reference/dex-api/block-service.html#apiv1txs))
+   * ```js
+   * // Example:
+   * const client = new BncClient('https://testnet-api.binance.org')
+   * client.getTxs(...);
+   * ```
+   */
+  async getTxs(address = this.address, startTime: number, endTime: number) {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getTxs}?address=${address}&startTime=${startTime}&endTime=${endTime}`
+      )
+      return data
+    } catch (err) {
+      console.warn("getTxs error", err)
+      return []
+    }
+  }
+
+  /**
+   * get transaction
+   * @param {String} hash the transaction hash
+   * @return {Promise} resolves with http response
+   */
+  async getTx(hash: string) {
+    try {
+      const data = await this._httpClient.request("get", `${api.getTx}/${hash}`)
+      return data
+    } catch (err) {
+      console.warn("getTx error", err)
+      return []
+    }
+  }
+
+  /**
+   * get depth for a given market
+   * @param {String} symbol the market pair
+   * @return {Promise} resolves with http response
+   */
+  async getDepth(symbol = "BNB_BUSD-BD1") {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getDepth}?symbol=${symbol}`
+      )
+      return data
+    } catch (err) {
+      console.warn("getDepth error", err)
+      return []
+    }
+  }
+
+  /**
+   * get open orders for an address
+   * @param {String} address binance address
+   * @param {String} symbol binance BEP2 symbol
+   * @return {Promise} resolves with http response
+   */
+  async getOpenOrders(address: string = this.address!) {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getOpenOrders}?address=${address}`
+      )
+      return data
+    } catch (err) {
+      console.warn("getOpenOrders error", err)
+      return []
+    }
+  }
+
+  /**
+   * get atomic swap
+   * @param {String} swapID: ID of an existing swap
+   * @return {Promise} AtomicSwap
+   */
+  async getSwapByID(swapID: string) {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getSwaps}/${swapID}`
+      )
+      return data
+    } catch (err) {
+      console.warn("query swap by swapID error", err)
+      return []
+    }
+  }
+
+  /**
+   * query atomic swap list by creator address
+   * @param {String} creator: swap creator address
+   * @param {Number} offset from beginning, default 0
+   * @param {Number} limit, max 1000 is default
+   * @return {Promise} Array of AtomicSwap
+   */
+  async getSwapByCreator(creator: string, limit = 100, offset = 0) {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getSwaps}?fromAddress=${creator}&limit=${limit}&offset=${offset}`
+      )
+      return data
+    } catch (err) {
+      console.warn("query swap list by swap creator error", err)
+      return []
+    }
+  }
+
+  /**
+   * query atomic swap list by recipient address
+   * @param {String} recipient: the recipient address of the swap
+   * @param {Number} offset from beginning, default 0
+   * @param {Number} limit, max 1000 is default
+   * @return {Promise} Array of AtomicSwap
+   */
+  async getSwapByRecipient(recipient: string, limit = 100, offset = 0) {
+    try {
+      const data = await this._httpClient.request(
+        "get",
+        `${api.getSwaps}?toAddress=${recipient}&limit=${limit}&offset=${offset}`
+      )
+      return data
+    } catch (err) {
+      console.warn("query swap list by swap recipient error", err)
+      return []
+    }
+  }
+
+  /**
+   * Creates a private key and returns it and its address.
+   * @return {object} the private key and address in an object.
+   * {
+   *  address,
+   *  privateKey
+   * }
+   */
+  createAccount() {
+    const privateKey = crypto.generatePrivateKey()
+    return {
+      privateKey,
+      address: crypto.getAddressFromPrivateKey(privateKey, this.addressPrefix),
+    }
+  }
+
+  /**
+   * Creates an account keystore object, and returns the private key and address.
+   * @param {String} password
+   *  {
+   *  privateKey,
+   *  address,
+   *  keystore
+   * }
+   */
+  createAccountWithKeystore(password: string) {
+    if (!password) {
+      throw new Error("password should not be falsy")
+    }
+    const privateKey = crypto.generatePrivateKey()
+    const address = crypto.getAddressFromPrivateKey(
+      privateKey,
+      this.addressPrefix
+    )
+    const keystore = crypto.generateKeyStore(privateKey, password)
+    return {
+      privateKey,
+      address,
+      keystore,
+    }
+  }
+
+  /**
+   * Creates an account from mnemonic seed phrase.
+   * @return {object}
+   * {
+   *  privateKey,
+   *  address,
+   *  mnemonic
+   * }
+   */
+  createAccountWithMneomnic() {
+    const mnemonic = crypto.generateMnemonic()
+    const privateKey = crypto.getPrivateKeyFromMnemonic(mnemonic)
+    const address = crypto.getAddressFromPrivateKey(
+      privateKey,
+      this.addressPrefix
+    )
+    return {
+      privateKey,
+      address,
+      mnemonic,
+    }
+  }
+
+  /**
+   * Recovers an account from a keystore object.
+   * @param {object} keystore object.
+   * @param {string} password password.
+   * {
+   * privateKey,
+   * address
+   * }
+   */
+  recoverAccountFromKeystore(
+    keystore: Parameters<typeof crypto.getPrivateKeyFromKeyStore>[0],
+    password: Parameters<typeof crypto.getPrivateKeyFromKeyStore>[1]
+  ) {
+    const privateKey = crypto.getPrivateKeyFromKeyStore(keystore, password)
+    const address = crypto.getAddressFromPrivateKey(
+      privateKey,
+      this.addressPrefix
+    )
+    return {
+      privateKey,
+      address,
+    }
+  }
+
+  /**
+   * Recovers an account from a mnemonic seed phrase.
+   * @param {string} mneomnic
+   * {
+   * privateKey,
+   * address
+   * }
+   */
+  recoverAccountFromMnemonic(mnemonic: string) {
+    const privateKey = crypto.getPrivateKeyFromMnemonic(mnemonic)
+    const address = crypto.getAddressFromPrivateKey(
+      privateKey,
+      this.addressPrefix
+    )
+    return {
+      privateKey,
+      address,
+    }
+  }
+  // support an old method name containing a typo
+  recoverAccountFromMneomnic(mnemonic: string) {
+    return this.recoverAccountFromMnemonic(mnemonic)
+  }
+
+  /**
+   * Recovers an account using private key.
+   * @param {String} privateKey
+   * {
+   * privateKey,
+   * address
+   * }
+   */
+  recoverAccountFromPrivateKey(privateKey: string) {
+    const address = crypto.getAddressFromPrivateKey(
+      privateKey,
+      this.addressPrefix
+    )
+    return {
+      privateKey,
+      address,
+    }
+  }
+
+  /**
+   * Validates an address.
+   * @param {String} address
+   * @param {String} prefix
+   * @return {Boolean}
+   */
+  checkAddress(
+    address: string,
+    prefix: BncClient["addressPrefix"] = this.addressPrefix
+  ) {
+    return crypto.checkAddress(address, prefix)
+  }
+
+  /**
+   * Returns the address for the current account if setPrivateKey has been called on this client.
+   * @return {String}
+   */
+  getClientKeyAddress() {
+    if (!this._privateKey)
+      throw new Error("no private key is set on this client")
+    const address = crypto.getAddressFromPrivateKey(
+      this._privateKey,
+      this.addressPrefix
+    )
+    this.address = address
+    return address
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/client/stake/index.ts b/node_modules/@binance-chain/javascript-sdk/src/client/stake/index.ts
new file mode 100644
index 0000000..6e6ea7d
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/client/stake/index.ts
@@ -0,0 +1,156 @@
+import Big from "big.js"
+
+import { BncClient } from "../"
+import * as crypto from "../../crypto"
+import {
+  BscDelegateMsg,
+  BaseMsg,
+  BscUndelegateMsg,
+  BscReDelegateMsg,
+} from "../../types"
+
+/**
+ * Stake
+ */
+export class Stake {
+  private _bncClient!: BncClient
+
+  /**
+   * @param {BncClient} bncClient
+   */
+  constructor(bncClient: BncClient) {
+    this._bncClient = bncClient
+  }
+
+  public async bscDelegate({
+    delegateAddress,
+    validatorAddress,
+    amount,
+    symbol = "BNB",
+    sideChainId = "chapel", //default value is ganges(testnet)
+  }: {
+    delegateAddress: string
+    validatorAddress: string
+    amount: number
+    symbol?: string
+    sideChainId?: string
+  }) {
+    if (!amount) {
+      throw new Error("amount should not be empty")
+    }
+
+    if (!delegateAddress) {
+      throw new Error("delegate address should not be null")
+    }
+
+    if (!crypto.checkAddress(validatorAddress, "bva")) {
+      throw new Error("validator address is not valid")
+    }
+
+    amount = Number(new Big(amount).mul(Math.pow(10, 8)).toString())
+
+    const bscDelegateMsg = new BscDelegateMsg({
+      delegator_addr: delegateAddress,
+      validator_addr: validatorAddress,
+      delegation: { denom: symbol, amount },
+      side_chain_id: sideChainId,
+    })
+
+    return await this.broadcast(bscDelegateMsg, delegateAddress)
+  }
+
+  public async bscUndelegate({
+    delegateAddress,
+    validatorAddress,
+    amount,
+    symbol = "BNB",
+    sideChainId = "chapel", //default value is ganges(testnet)
+  }: {
+    delegateAddress: string
+    validatorAddress: string
+    amount: number
+    symbol?: string
+    sideChainId?: string
+  }) {
+    if (!amount) {
+      throw new Error("amount should not be empty")
+    }
+
+    if (!delegateAddress) {
+      throw new Error("delegate address should not be null")
+    }
+
+    if (!crypto.checkAddress(validatorAddress, "bva")) {
+      throw new Error("validator address is not valid")
+    }
+
+    amount = Number(new Big(amount).mul(Math.pow(10, 8)).toString())
+
+    const unDelegateMsg = new BscUndelegateMsg({
+      delegator_addr: delegateAddress,
+      validator_addr: validatorAddress,
+      amount: { denom: symbol, amount },
+      side_chain_id: sideChainId,
+    })
+
+    return await this.broadcast(unDelegateMsg, delegateAddress)
+  }
+
+  public async bscReDelegate({
+    delegateAddress,
+    validatorSrcAddress,
+    validatorDstAddress,
+    amount,
+    symbol = "BNB",
+    sideChainId = "chapel", //default value is ganges(testnet)
+  }: {
+    delegateAddress: string
+    validatorSrcAddress: string
+    validatorDstAddress: string
+    amount: number
+    symbol?: string
+    sideChainId?: string
+  }) {
+    if (!amount) {
+      throw new Error("amount should not be empty")
+    }
+
+    if (!delegateAddress) {
+      throw new Error("delegate address should not be null")
+    }
+
+    if (!crypto.checkAddress(validatorSrcAddress, "bva")) {
+      throw new Error("validator source address is not valid")
+    }
+
+    if (!crypto.checkAddress(validatorDstAddress, "bva")) {
+      throw new Error("validator dest address is not valid")
+    }
+
+    amount = Number(new Big(amount).mul(Math.pow(10, 8)).toString())
+
+    const bscReDelegateMsg = new BscReDelegateMsg({
+      delegator_addr: delegateAddress,
+      validator_src_addr: validatorSrcAddress,
+      validator_dst_addr: validatorDstAddress,
+      amount: { denom: symbol, amount },
+      side_chain_id: sideChainId,
+    })
+
+    return await this.broadcast(bscReDelegateMsg, delegateAddress)
+  }
+
+  private async broadcast(
+    msg: BaseMsg,
+    fromAddress: string,
+    sequence?: number
+  ) {
+    const signedTx = await this._bncClient._prepareTransaction(
+      msg.getMsg(),
+      msg.getSignMsg(),
+      fromAddress,
+      sequence
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/client/swap/index.ts b/node_modules/@binance-chain/javascript-sdk/src/client/swap/index.ts
new file mode 100644
index 0000000..a6f7ee4
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/client/swap/index.ts
@@ -0,0 +1,174 @@
+/**
+ * @module Swap
+ */
+
+import { BncClient } from ".."
+import * as crypto from "../../crypto"
+import { Coin, AminoPrefix } from "../../types"
+import { checkCoins } from "../../utils/validateHelper"
+
+class Swap {
+  static instance: Swap
+  private _bncClient!: BncClient
+
+  /**
+   * @param {Object} bncClient
+   */
+  constructor(bncClient: BncClient) {
+    if (!Swap.instance) {
+      this._bncClient = bncClient
+      Swap.instance = this
+    }
+
+    return Swap.instance
+  }
+
+  /**
+   * HTLT(Hash timer locked transfer, create an atomic swap)
+   * @param {String} from
+   * @param {String} recipient
+   * @param {String} recipientOtherChain
+   * @param {String} senderOtherChain
+   * @param {String} randomNumberHash
+   * @param {Number} timestamp
+   * @param {Array} amount
+   * @param {String} expectedIncome
+   * @param {Number} heightSpan
+   * @param {boolean} crossChain
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async HTLT(
+    from: string,
+    recipient: string,
+    recipientOtherChain: string,
+    senderOtherChain: string,
+    randomNumberHash: string,
+    timestamp: number,
+    amount: Coin[],
+    expectedIncome: string,
+    heightSpan: number,
+    crossChain: boolean
+  ) {
+    checkCoins(amount)
+    const htltMsg = {
+      from: crypto.decodeAddress(from),
+      to: crypto.decodeAddress(recipient),
+      recipient_other_chain: recipientOtherChain,
+      sender_other_chain: senderOtherChain,
+      random_number_hash: Buffer.from(randomNumberHash, "hex"),
+      timestamp: timestamp,
+      amount: amount,
+      expected_income: expectedIncome,
+      height_span: heightSpan,
+      cross_chain: crossChain,
+      aminoPrefix: AminoPrefix.HTLTMsg,
+    }
+
+    const signHTLTMsg = {
+      from: from,
+      to: recipient,
+      recipient_other_chain: recipientOtherChain,
+      sender_other_chain: senderOtherChain,
+      random_number_hash: randomNumberHash,
+      timestamp: timestamp,
+      amount: amount,
+      expected_income: expectedIncome,
+      height_span: heightSpan,
+      cross_chain: crossChain,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      htltMsg,
+      signHTLTMsg,
+      from
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * depositHTLT(deposit assets to an existing swap)
+   * @param {String} from
+   * @param {String} swapID
+   * @param {Array} amount
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async depositHTLT(from: string, swapID: string, amount: Coin[]) {
+    checkCoins(amount)
+    const depositHTLTMsg = {
+      from: crypto.decodeAddress(from),
+      amount: amount,
+      swap_id: Buffer.from(swapID, "hex"),
+      aminoPrefix: AminoPrefix.DepositHTLTMsg,
+    }
+
+    const signDepositHTLTMsg = {
+      from: from,
+      amount: amount,
+      swap_id: swapID,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      depositHTLTMsg,
+      signDepositHTLTMsg,
+      from
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * claimHTLT(claim assets from an swap)
+   * @param {String} from
+   * @param {String} swapID
+   * @param {String} randomNumber
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async claimHTLT(from: string, swapID: string, randomNumber: string) {
+    const claimHTLTMsg = {
+      from: crypto.decodeAddress(from),
+      swap_id: Buffer.from(swapID, "hex"),
+      random_number: Buffer.from(randomNumber, "hex"),
+      aminoPrefix: AminoPrefix.ClaimHTLTMsg,
+    }
+
+    const signClaimHTLTMsg = {
+      from: from,
+      swap_id: swapID,
+      random_number: randomNumber,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      claimHTLTMsg,
+      signClaimHTLTMsg,
+      from
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * refundHTLT(refund assets from an swap)
+   * @param {String} from
+   * @param {String} swapID
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async refundHTLT(from: string, swapID: string) {
+    const refundHTLTMsg = {
+      from: crypto.decodeAddress(from),
+      swap_id: Buffer.from(swapID, "hex"),
+      aminoPrefix: AminoPrefix.RefundHTLTMsg,
+    }
+
+    const signRefundHTLTMsg = {
+      from: from,
+      swap_id: swapID,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      refundHTLTMsg,
+      signRefundHTLTMsg,
+      from
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+}
+
+export default Swap
diff --git a/node_modules/@binance-chain/javascript-sdk/src/client/token/index.ts b/node_modules/@binance-chain/javascript-sdk/src/client/token/index.ts
new file mode 100644
index 0000000..6858d71
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/client/token/index.ts
@@ -0,0 +1,581 @@
+import Big, { BigSource } from "big.js"
+
+import { api, BncClient } from ".."
+import * as crypto from "../../crypto"
+import {
+  Coin,
+  AminoPrefix,
+  IssueMiniTokenMsg,
+  IssueTinyTokenMsg,
+  SetTokenUriMsg,
+} from "../../types"
+import HttpRequest from "../../utils/request"
+import { validateSymbol, checkCoins } from "../../utils/validateHelper"
+
+const MAXTOTALSUPPLY = 9000000000000000000
+const MINI_TOKEN_MAX_TOTAL_SUPPAY = 1000000
+const TINY_TOKEN_MAX_TOTAL_SUPPAY = 10000
+
+const validateNonZeroAmount = async (
+  amountParam: BigSource,
+  symbol: string,
+  fromAddress: string,
+  httpClient: HttpRequest,
+  type = "free"
+) => {
+  const amount = new Big(amountParam)
+  if (amount.lte(0) || amount.gt(MAXTOTALSUPPLY)) {
+    throw new Error("invalid amount")
+  }
+
+  try {
+    const { result } = await httpClient.request(
+      "get",
+      `${api.getAccount}/${fromAddress}`
+    )
+    const balance = result.balances.find(
+      (b: { symbol: string }) => b.symbol.toUpperCase() === symbol.toUpperCase()
+    )
+    if (!balance) {
+      throw new Error(`the account doesn't have ${symbol}`)
+    }
+
+    if (amount.gte(balance[type])) {
+      throw new Error(`the account doesn't have enougth balance`)
+    }
+  } catch (err) {
+    //if get account failed. still broadcast
+  }
+}
+
+export const validateMiniTokenSymbol = (symbol: string) => {
+  if (!symbol) {
+    throw new Error("suffixed token symbol cannot be empty")
+  }
+
+  const splitedSymbol = symbol.split("-")
+  if (splitedSymbol.length != 2) {
+    throw new Error("suffixed mini-token symbol must contain a hyphen ('-')")
+  }
+
+  if (!splitedSymbol[1]) {
+    throw new Error(
+      `suffixed mini-token symbol must contain just one hyphen (" - ")`
+    )
+  }
+
+  if (!/^[a-zA-z\d]{3,8}$/.test(splitedSymbol[0])) {
+    throw new Error(
+      "symbol should be alphanumeric and length is limited to 3~8"
+    )
+  }
+
+  if (!splitedSymbol[1].endsWith("M")) {
+    throw new Error("mini-token symbol suffix must end with M")
+  }
+}
+
+/**
+ * issue or view tokens
+ */
+class TokenManagement {
+  private _bncClient!: BncClient
+
+  /**
+   * @param {Object} bncClient
+   */
+  constructor(bncClient: BncClient) {
+    this._bncClient = bncClient
+  }
+
+  /**
+   * create a new asset on Binance Chain
+   * @param {String} - senderAddress
+   * @param {String} - tokenName
+   * @param {String} - symbol
+   * @param {Number} - totalSupply
+   * @param {Boolean} - mintable
+   * @returns {Promise} resolves with response (success or fail)
+   */
+  async issue(
+    senderAddress: string,
+    tokenName: string,
+    symbol: string,
+    totalSupply = 0,
+    mintable = false
+  ) {
+    if (!senderAddress) {
+      throw new Error("sender address cannot be empty")
+    }
+
+    if (tokenName.length > 32) {
+      throw new Error("token name is limited to 32 characters")
+    }
+
+    if (!/^[a-zA-z\d]{3,8}$/.test(symbol)) {
+      throw new Error(
+        "symbol should be alphanumeric and length is limited to 3~8"
+      )
+    }
+
+    if (totalSupply <= 0 || totalSupply > MAXTOTALSUPPLY) {
+      throw new Error("invalid supply amount")
+    }
+
+    totalSupply = Number(new Big(totalSupply).mul(Math.pow(10, 8)).toString())
+
+    const issueMsg = {
+      from: crypto.decodeAddress(senderAddress),
+      name: tokenName,
+      symbol,
+      total_supply: totalSupply,
+      mintable,
+      aminoPrefix: AminoPrefix.IssueMsg,
+    }
+
+    const signIssueMsg = {
+      from: senderAddress,
+      name: tokenName,
+      symbol,
+      total_supply: totalSupply,
+      mintable,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      issueMsg,
+      signIssueMsg,
+      senderAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * issue a new mini-token, total supply should be less than 1M
+   * @param {String} - senderAddress
+   * @param {String} - tokenName
+   * @param {String} - symbol
+   * @param {Number} - totalSupply
+   * @param {Boolean} - mintable
+   * @param {string} - token_uri
+   * @returns {Promise} resolves with response (success or fail)
+   */
+  async issueMiniToken(
+    senderAddress: string,
+    tokenName: string,
+    symbol: string,
+    totalSupply = 0,
+    mintable = false,
+    tokenUri?: string
+  ) {
+    if (!senderAddress) {
+      throw new Error("sender address cannot be empty")
+    }
+
+    if (tokenName.length > 32) {
+      throw new Error("token name is limited to 32 characters")
+    }
+
+    if (!/^[a-zA-z\d]{3,8}$/.test(symbol)) {
+      throw new Error(
+        "symbol should be alphanumeric and length is limited to 3~8"
+      )
+    }
+
+    if (totalSupply <= 0 || totalSupply > MINI_TOKEN_MAX_TOTAL_SUPPAY) {
+      throw new Error("invalid supply amount")
+    }
+
+    totalSupply = Number(new Big(totalSupply).mul(Math.pow(10, 8)).toString())
+
+    const issueMiniMsg = new IssueMiniTokenMsg({
+      name: tokenName,
+      symbol,
+      total_supply: totalSupply,
+      mintable,
+      token_uri: tokenUri,
+      from: senderAddress,
+    })
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      issueMiniMsg.getMsg(),
+      issueMiniMsg.getSignMsg(),
+      senderAddress
+    )
+
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * issue a new tiny-token, total supply should be less than 10K
+   * @param {String} - senderAddress
+   * @param {String} - tokenName
+   * @param {String} - symbol
+   * @param {Number} - totalSupply
+   * @param {Boolean} - mintable
+   * @param {string} - token_uri
+   * @returns {Promise} resolves with response (success or fail)
+   */
+  async issueTinyToken(
+    senderAddress: string,
+    tokenName: string,
+    symbol: string,
+    totalSupply = 0,
+    mintable = false,
+    tokenUri?: string
+  ) {
+    if (!senderAddress) {
+      throw new Error("sender address cannot be empty")
+    }
+
+    if (tokenName.length > 32) {
+      throw new Error("token name is limited to 32 characters")
+    }
+
+    if (!/^[a-zA-z\d]{3,8}$/.test(symbol)) {
+      throw new Error(
+        "symbol should be alphanumeric and length is limited to 3~8"
+      )
+    }
+
+    if (totalSupply <= 0 || totalSupply > TINY_TOKEN_MAX_TOTAL_SUPPAY) {
+      throw new Error("invalid supply amount")
+    }
+
+    totalSupply = Number(new Big(totalSupply).mul(Math.pow(10, 8)).toString())
+
+    const issueMiniMsg = new IssueTinyTokenMsg({
+      name: tokenName,
+      symbol,
+      total_supply: totalSupply,
+      mintable,
+      token_uri: tokenUri,
+      from: senderAddress,
+    })
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      issueMiniMsg.getMsg(),
+      issueMiniMsg.getSignMsg(),
+      senderAddress
+    )
+
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * set token URI of mini-token
+   */
+  async setTokenUri({
+    fromAddress,
+    tokenUri,
+    symbol,
+  }: {
+    fromAddress: string
+    tokenUri: string
+    symbol: string
+  }) {
+    validateMiniTokenSymbol(symbol)
+
+    if (tokenUri.length > 2048) {
+      throw new Error("uri cannot be longer than 2048 characters")
+    }
+
+    if (!fromAddress) {
+      throw new Error("address cannot be empty")
+    }
+
+    const setUriMsg = new SetTokenUriMsg({
+      from: fromAddress,
+      token_uri: tokenUri,
+      symbol,
+    })
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      setUriMsg.getMsg(),
+      setUriMsg.getSignMsg(),
+      fromAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * freeze some amount of token
+   * @param {String} fromAddress
+   * @param {String} symbol
+   * @param {String} amount
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async freeze(fromAddress: string, symbol: string, amount: BigSource) {
+    validateSymbol(symbol)
+
+    validateNonZeroAmount(
+      amount,
+      symbol,
+      fromAddress,
+      this._bncClient._httpClient,
+      "free"
+    )
+
+    amount = +Number(new Big(amount).mul(Math.pow(10, 8)).toString())
+
+    const freezeMsg = {
+      from: crypto.decodeAddress(fromAddress),
+      symbol,
+      amount: amount,
+      aminoPrefix: AminoPrefix.FreezeMsg,
+    }
+
+    const freezeSignMsg = {
+      amount: amount,
+      from: fromAddress,
+      symbol,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      freezeMsg,
+      freezeSignMsg,
+      fromAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * unfreeze some amount of token
+   * @param {String} fromAddress
+   * @param {String} symbol
+   * @param {String} amount
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async unfreeze(fromAddress: string, symbol: string, amount: BigSource) {
+    validateSymbol(symbol)
+
+    validateNonZeroAmount(
+      amount,
+      symbol,
+      fromAddress,
+      this._bncClient._httpClient,
+      "frozen"
+    )
+
+    amount = +Number(new Big(amount).mul(Math.pow(10, 8)).toString())
+
+    const unfreezeMsg = {
+      from: crypto.decodeAddress(fromAddress),
+      symbol,
+      amount: amount,
+      aminoPrefix: AminoPrefix.UnfreezeMsg,
+    }
+
+    const unfreezeSignMsg = {
+      amount: amount,
+      from: fromAddress,
+      symbol,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      unfreezeMsg,
+      unfreezeSignMsg,
+      fromAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * burn some amount of token
+   * @param {String} fromAddress
+   * @param {String} symbol
+   * @param {Number} amount
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async burn(fromAddress: string, symbol: string, amount: BigSource) {
+    validateSymbol(symbol)
+
+    validateNonZeroAmount(
+      amount,
+      symbol,
+      fromAddress,
+      this._bncClient._httpClient
+    )
+    amount = +Number(new Big(amount).mul(Math.pow(10, 8)).toString())
+    const burnMsg = {
+      from: crypto.decodeAddress(fromAddress),
+      symbol,
+      amount: amount,
+      aminoPrefix: AminoPrefix.BurnMsg,
+    }
+
+    const burnSignMsg = {
+      amount: amount,
+      from: fromAddress,
+      symbol,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      burnMsg,
+      burnSignMsg,
+      fromAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * mint tokens for an existing token
+   * @param {String} fromAddress
+   * @param {String} symbol
+   * @param {Number} amount
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async mint(fromAddress: string, symbol: string, amount: BigSource) {
+    validateSymbol(symbol)
+
+    if (amount <= 0 || amount > MAXTOTALSUPPLY) {
+      throw new Error("invalid amount")
+    }
+
+    amount = Number(new Big(amount).mul(Math.pow(10, 8)).toString())
+
+    const mintMsg = {
+      from: crypto.decodeAddress(fromAddress),
+      symbol,
+      amount: amount,
+      aminoPrefix: AminoPrefix.MintMsg,
+    }
+
+    const mintSignMsg = {
+      amount: amount,
+      from: fromAddress,
+      symbol,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      mintMsg,
+      mintSignMsg,
+      fromAddress
+    )
+
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * lock token for a while
+   * @param {String} fromAddress
+   * @param {String} description
+   * @param {Array} amount
+   * @param {Number} lockTime
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async timeLock(
+    fromAddress: string,
+    description: string,
+    amount: Coin[],
+    lockTime: number
+  ) {
+    checkCoins(amount)
+
+    if (description.length > 128) {
+      throw new Error("description is too long")
+    }
+
+    if (lockTime < 60 || lockTime > 253402300800) {
+      throw new Error("timeTime must be in [60, 253402300800]")
+    }
+    const timeLockMsg = {
+      from: crypto.decodeAddress(fromAddress),
+      description,
+      amount,
+      lock_time: lockTime,
+      aminoPrefix: AminoPrefix.TimeLockMsg,
+    }
+
+    const signTimeLockMsg = {
+      from: fromAddress,
+      description: description,
+      amount,
+      lock_time: lockTime,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      timeLockMsg,
+      signTimeLockMsg,
+      fromAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * lock more token or increase locked period
+   * @param {String} fromAddress
+   * @param {Number} id
+   * @param {String} description
+   * @param {Array} amount
+   * @param {Number} lockTime
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async timeRelock(
+    fromAddress: string,
+    id: number,
+    description: string,
+    amount: Coin[],
+    lockTime: number
+  ) {
+    checkCoins(amount)
+
+    if (description.length > 128) {
+      throw new Error("description is too long")
+    }
+
+    if (lockTime < 60 || lockTime > 253402300800) {
+      throw new Error("timeTime must be in [60, 253402300800]")
+    }
+    const timeRelockMsg = {
+      from: crypto.decodeAddress(fromAddress),
+      time_lock_id: id,
+      description,
+      amount,
+      lock_time: lockTime,
+      aminoPrefix: AminoPrefix.TimeRelockMsg,
+    }
+
+    const signTimeRelockMsg = {
+      from: fromAddress,
+      time_lock_id: id,
+      description: description,
+      amount,
+      lock_time: lockTime,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      timeRelockMsg,
+      signTimeRelockMsg,
+      fromAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+
+  /**
+   * unlock locked tokens
+   * @param {String} fromAddress
+   * @param {Number} id
+   * @returns {Promise}  resolves with response (success or fail)
+   */
+  async timeUnlock(fromAddress: string, id: number) {
+    const timeUnlockMsg = {
+      from: crypto.decodeAddress(fromAddress),
+      time_lock_id: id,
+      aminoPrefix: AminoPrefix.TimeUnlockMsg,
+    }
+
+    const signTimeUnlockMsg = {
+      from: fromAddress,
+      time_lock_id: id,
+    }
+
+    const signedTx = await this._bncClient._prepareTransaction(
+      timeUnlockMsg,
+      signTimeUnlockMsg,
+      fromAddress
+    )
+    return this._bncClient._broadcastDelegate(signedTx)
+  }
+}
+
+export default TokenManagement
diff --git a/node_modules/@binance-chain/javascript-sdk/src/crypto/index.ts b/node_modules/@binance-chain/javascript-sdk/src/crypto/index.ts
new file mode 100644
index 0000000..47c80a5
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/crypto/index.ts
@@ -0,0 +1,407 @@
+import bech32 from "bech32"
+import * as bip32 from "bip32"
+import * as bip39 from "bip39"
+import cryp from "crypto-browserify"
+import { ec as EC, curve } from "elliptic"
+import is from "is_js"
+import csprng from "secure-random"
+import * as ecc from "tiny-secp256k1"
+import uuid from "uuid"
+
+import { ab2hexstring, sha3, sha256, sha256ripemd160 } from "../utils"
+
+export interface KeyStore {
+  version: number
+  id: string
+  crypto: {
+    ciphertext: string
+    cipherparams: {
+      iv: string
+    }
+    cipher: string
+    kdf: string
+    kdfparams: {
+      dklen: number
+      salt: string
+      c: number
+      prf: string
+    }
+    /** Must use sha3 according to web3 secret storage spec. */
+    mac: string
+  }
+}
+
+// secp256k1 privkey is 32 bytes
+const PRIVKEY_LEN = 32
+const MNEMONIC_LEN = 256
+const DECODED_ADDRESS_LEN = 20
+const CURVE = "secp256k1"
+
+//hdpath
+const HDPATH = "44'/714'/0'/0/"
+
+const ec = new EC(CURVE)
+
+/**
+ * Decodes an address in bech32 format.
+ * @category crypto
+ * @param {string} value the bech32 address to decode
+ */
+export const decodeAddress = (value: string): Buffer => {
+  const decodeAddress = bech32.decode(value)
+  return Buffer.from(bech32.fromWords(decodeAddress.words))
+}
+
+/**
+ * Checks whether an address is valid.
+ * @category crypto
+ * @param {string} address the bech32 address to decode
+ * @param {string} hrp the prefix to check for the bech32 address
+ * @return {boolean}
+ */
+export const checkAddress = (address: string, hrp: string): boolean => {
+  try {
+    if (!address.startsWith(hrp)) {
+      return false
+    }
+
+    const decodedAddress = bech32.decode(address)
+    const decodedAddressLength = decodeAddress(address).length
+    if (
+      decodedAddressLength === DECODED_ADDRESS_LEN &&
+      decodedAddress.prefix === hrp
+    ) {
+      return true
+    }
+
+    return false
+  } catch (err) {
+    return false
+  }
+}
+
+/**
+ * Encodes an address from input data bytes.
+ * @category crypto
+ * @param {string} value the public key to encode
+ * @param {*} prefix the address prefix
+ * @param {*} type the output type (default: hex)
+ */
+export const encodeAddress = (
+  value: string | Buffer,
+  prefix = "tbnb",
+  type: BufferEncoding = "hex"
+): string => {
+  let words
+  if (Buffer.isBuffer(value)) {
+    words = bech32.toWords(Buffer.from(value))
+  } else {
+    words = bech32.toWords(Buffer.from(value, type))
+  }
+  return bech32.encode(prefix, words)
+}
+
+/**
+ * Generates 32 bytes of random entropy
+ * @category crypto
+ * @param {number} len output length (default: 32 bytes)
+ * @returns {string} entropy bytes hexstring
+ */
+export const generatePrivateKey = (len: number = PRIVKEY_LEN): string =>
+  ab2hexstring(csprng(len))
+
+/**
+ * Generates an arrayBuffer filled with random bits.
+ * @category crypto
+ * @param {number} length - Length of buffer.
+ * @returns {ArrayBuffer}
+ */
+export const generateRandomArray = (length: number): ArrayBuffer =>
+  csprng(length)
+
+/**
+ * @category crypto
+ * @param {string} publicKey - Encoded public key
+ * @return {Elliptic.PublicKey} public key hexstring
+ */
+export const getPublicKey = (publicKey: string) => {
+  const keyPair = ec.keyFromPublic(publicKey, "hex")
+  return keyPair.getPublic()
+}
+
+/**
+ * Calculates the public key from a given private key.
+ * @category crypto
+ * @param {string} privateKeyHex the private key hexstring
+ * @return {string} public key hexstring
+ */
+export const getPublicKeyFromPrivateKey = (privateKeyHex: string): string => {
+  if (!privateKeyHex || privateKeyHex.length !== PRIVKEY_LEN * 2) {
+    throw new Error("invalid privateKey")
+  }
+  const curve = new EC(CURVE)
+  const keypair = curve.keyFromPrivate(privateKeyHex, "hex")
+  const unencodedPubKey = keypair.getPublic().encode("hex", false)
+  return unencodedPubKey
+}
+
+/**
+ * PubKey performs the point-scalar multiplication from the privKey on the
+ * generator point to get the pubkey.
+ * @category crypto
+ * @param {Buffer} privateKey
+ * @return {Elliptic.PublicKey} PubKey
+ * */
+export const generatePubKey = (privateKey: Buffer): curve.base.BasePoint => {
+  const curve = new EC(CURVE)
+  const keypair = curve.keyFromPrivate(privateKey)
+  return keypair.getPublic()
+}
+
+/**
+ * Gets an address from a public key hex.
+ * @category crypto
+ * @param {string} publicKeyHex the public key hexstring
+ * @param {string} prefix the address prefix
+ */
+export const getAddressFromPublicKey = (
+  publicKeyHex: string,
+  prefix?: string
+) => {
+  const pubKey = ec.keyFromPublic(publicKeyHex, "hex")
+  const pubPoint = pubKey.getPublic()
+  const compressed = pubPoint.encodeCompressed()
+  const hexed = ab2hexstring(compressed)
+  const hash = sha256ripemd160(hexed) // https://git.io/fAn8N
+  const address = encodeAddress(hash, prefix)
+  return address
+}
+
+/**
+ * Gets an address from a private key.
+ * @category crypto
+ * @param {string} privateKeyHex the private key hexstring
+ * @param {string} prefix the address prefix
+ */
+export const getAddressFromPrivateKey = (
+  privateKeyHex: string,
+  prefix?: string
+): string => {
+  return getAddressFromPublicKey(
+    getPublicKeyFromPrivateKey(privateKeyHex),
+    prefix
+  )
+}
+
+/**
+ * Generates a signature (64 byte <r,s>) for a transaction based on given private key.
+ * @category crypto
+ * @param {string} signBytesHex - Unsigned transaction sign bytes hexstring.
+ * @param {string | Buffer} privateKey - The private key.
+ * @return {Buffer} Signature. Does not include tx.
+ */
+export const generateSignature = (
+  signBytesHex: string,
+  privateKey: string | Buffer
+): Buffer => {
+  const msgHash = sha256(signBytesHex)
+  const msgHashHex = Buffer.from(msgHash, "hex")
+  const signature = ecc.sign(
+    msgHashHex,
+    typeof privateKey === "string" ? Buffer.from(privateKey, "hex") : privateKey
+  )
+  return signature
+}
+
+/**
+ * Verifies a signature (64 byte <r,s>) given the sign bytes and public key.
+ * @category crypto
+ * @param {string} sigHex - The signature hexstring.
+ * @param {string} signBytesHex - Unsigned transaction sign bytes hexstring.
+ * @param {string} publicKeyHex - The public key.
+ * @return {boolean}
+ */
+export const verifySignature = (
+  sigHex: string,
+  signBytesHex: string,
+  publicKeyHex: string
+): boolean => {
+  const publicKey = Buffer.from(publicKeyHex, "hex")
+  if (!ecc.isPoint(publicKey)) throw new Error("Invalid public key provided")
+  const msgHash = sha256(signBytesHex)
+  const msgHashHex = Buffer.from(msgHash, "hex")
+  return ecc.verify(msgHashHex, publicKey, Buffer.from(sigHex, "hex"))
+}
+
+/**
+ * Generates a keystore object (web3 secret storage format) given a private key to store and a password.
+ * @category crypto
+ * @param {string} privateKeyHex the private key hexstring.
+ * @param {string} password the password.
+ * @return {object} the keystore object.
+ */
+export const generateKeyStore = (
+  privateKeyHex: string,
+  password: string
+): KeyStore => {
+  const salt = cryp.randomBytes(32)
+  const iv = cryp.randomBytes(16)
+  const cipherAlg = "aes-256-ctr"
+
+  const kdf = "pbkdf2"
+  const kdfparams = {
+    dklen: 32,
+    salt: salt.toString("hex"),
+    c: 262144,
+    prf: "hmac-sha256",
+  }
+
+  const derivedKey = cryp.pbkdf2Sync(
+    Buffer.from(password),
+    salt,
+    kdfparams.c,
+    kdfparams.dklen,
+    "sha256"
+  )
+  const cipher = cryp.createCipheriv(cipherAlg, derivedKey.slice(0, 32), iv)
+  if (!cipher) {
+    throw new Error("Unsupported cipher")
+  }
+
+  const ciphertext = Buffer.concat([
+    cipher.update(Buffer.from(privateKeyHex, "hex")),
+    cipher.final(),
+  ])
+  const bufferValue = Buffer.concat([derivedKey.slice(16, 32), ciphertext])
+
+  return {
+    version: 1,
+    id: uuid.v4({
+      random: cryp.randomBytes(16),
+    }),
+    crypto: {
+      ciphertext: ciphertext.toString("hex"),
+      cipherparams: {
+        iv: iv.toString("hex"),
+      },
+      cipher: cipherAlg,
+      kdf,
+      kdfparams,
+      // mac must use sha3 according to web3 secret storage spec
+      mac: sha3(bufferValue.toString("hex")),
+    },
+  }
+}
+
+/**
+ * Gets a private key from a keystore given its password.
+ * @category crypto
+ * @param {string} keystore the keystore in json format
+ * @param {string} password the password.
+ */
+export const getPrivateKeyFromKeyStore = (
+  keystore: string,
+  password: string
+): string => {
+  if (!is.string(password)) {
+    throw new Error("No password given.")
+  }
+
+  const json: KeyStore = is.object(keystore) ? keystore : JSON.parse(keystore)
+  const kdfparams = json.crypto.kdfparams
+
+  if (kdfparams.prf !== "hmac-sha256") {
+    throw new Error("Unsupported parameters to PBKDF2")
+  }
+
+  const derivedKey = cryp.pbkdf2Sync(
+    Buffer.from(password),
+    Buffer.from(kdfparams.salt, "hex"),
+    kdfparams.c,
+    kdfparams.dklen,
+    "sha256"
+  )
+  const ciphertext = Buffer.from(json.crypto.ciphertext, "hex")
+  const bufferValue = Buffer.concat([derivedKey.slice(16, 32), ciphertext])
+
+  // try sha3 (new / ethereum keystore) mac first
+  const mac = sha3(bufferValue.toString("hex"))
+  if (mac !== json.crypto.mac) {
+    // the legacy (sha256) mac is next to be checked. pre-testnet keystores used a sha256 digest for the mac.
+    // the sha256 mac was not compatible with ethereum keystores, so it was changed to sha3 for mainnet.
+    const macLegacy = sha256(bufferValue.toString("hex"))
+    if (macLegacy !== json.crypto.mac) {
+      throw new Error(
+        "Keystore mac check failed (sha3 & sha256) - wrong password?"
+      )
+    }
+  }
+
+  const decipher = cryp.createDecipheriv(
+    json.crypto.cipher,
+    derivedKey.slice(0, 32),
+    Buffer.from(json.crypto.cipherparams.iv, "hex")
+  )
+  const privateKey = Buffer.concat([
+    decipher.update(ciphertext),
+    decipher.final(),
+  ]).toString("hex")
+
+  return privateKey
+}
+
+/**
+ * Generates mnemonic phrase words using random entropy.
+ * @category crypto
+ */
+export const generateMnemonic = (): string =>
+  bip39.generateMnemonic(MNEMONIC_LEN)
+
+/**
+ * Validates mnemonic phrase words.
+ * @ignore
+ * @param {string} mnemonic the mnemonic phrase words
+ * @return {bool} validation result
+ */
+export const validateMnemonic = bip39.validateMnemonic
+
+/**
+ * Get a private key from mnemonic words.
+ * @category crypto
+ * @param {string} mnemonic the mnemonic phrase words
+ * @param {Boolean} derive derive a private key using the default HD path (default: true)
+ * @param {number} index the bip44 address index (default: 0)
+ * @param {string} password according to bip39
+ * @return {string} hexstring
+ */
+export const getPrivateKeyFromMnemonic = (
+  mnemonic: string,
+  derive = true,
+  index = 0,
+  password = ""
+): string => {
+  if (
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.english) &&
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.chinese_simplified) &&
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.chinese_traditional) &&
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.korean) &&
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.french) &&
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.italian) &&
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.spanish) &&
+    !bip39.validateMnemonic(mnemonic, bip39.wordlists.japanese)
+  ) {
+    throw new Error("wrong mnemonic format")
+  }
+
+  const seed = bip39.mnemonicToSeedSync(mnemonic, password)
+  if (derive) {
+    const master = bip32.fromSeed(seed)
+    const child = master.derivePath(HDPATH + index)
+    if (!child.privateKey) {
+      throw new Error("child does not have a privateKey")
+    }
+
+    return child.privateKey.toString("hex")
+  }
+  return seed.toString("hex")
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/declarations.ts b/node_modules/@binance-chain/javascript-sdk/src/declarations.ts
new file mode 100644
index 0000000..deea5f8
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/declarations.ts
@@ -0,0 +1,73 @@
+/* eslint-disable */
+
+declare module "is_js" {
+  export const boolean: (a: any) => a is boolean
+  export const number: (a: any) => a is number
+  export const integer: (a: any) => a is number
+  export const string: (a: any) => a is string
+  export const array: (a: any) => a is Array<any>
+  export const object: (a: any) => a is object
+}
+
+declare module "secure-random" {
+  const csprng: (lenght: number) => ArrayBuffer
+  export default csprng
+}
+
+declare module "crypto-browserify" {
+  import * as _crypto from "crypto"
+  const crypto: Pick<
+    typeof _crypto,
+    | "createHash"
+    | "createHmac"
+    | "pbkdf2"
+    | "pbkdf2Sync"
+    | "randomBytes"
+    | "pseudoRandomBytes"
+    | "createCipher"
+    | "createDecipher"
+    | "createDiffieHellman"
+    | "createSign"
+    | "createVerify"
+    | "createECDH"
+    | "publicEncrypt"
+    | "privateDecrypt"
+    | "privateEncrypt"
+    | "publicDecrypt"
+    | "createCipheriv"
+    | "createDecipheriv"
+  >
+  export default crypto
+}
+
+declare module "protocol-buffers-encodings" {
+  export namespace string {
+    export const encode: (val: any, buffer: Buffer, offset?: number) => Buffer
+    export const decode: (buf: Buffer | number[], offset?: number) => any
+    export const encodingLength: (val: any) => number
+  }
+
+  export namespace bytes {
+    export const encode: (val: any, buffer: Buffer, offset?: number) => Buffer
+    export const decode: (buf: Buffer | number[], offset?: number) => any
+    export const encodingLength: (val: any) => number
+  }
+
+  export namespace bool {
+    export const encode: (val: any, buffer: Buffer, offset?: number) => Buffer
+    export const decode: (buf: Buffer | number[], offset?: number) => any
+    export const encodingLength: (val: any) => number
+  }
+
+  export namespace varint {
+    export const encode: (val: any, buffer: Buffer, offset?: number) => Buffer
+    export const decode: (buf: Buffer | number[], offset?: number) => any
+    export const encodingLength: (val: any) => number
+  }
+}
+
+declare module "ndjson" {
+  import { Stream } from "stream"
+  const wat: { stringify: () => Stream }
+  export default wat
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/index.ts b/node_modules/@binance-chain/javascript-sdk/src/index.ts
new file mode 100644
index 0000000..0e17b7f
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/index.ts
@@ -0,0 +1,13 @@
+import "./declarations"
+
+import * as amino from "./amino"
+import { BncClient } from "./client"
+import * as crypto from "./crypto"
+import * as types from "./types"
+import * as utils from "./utils"
+
+export { default as ledger } from "./ledger"
+export { default as rpc } from "./rpc"
+export { default as Transaction } from "./tx"
+
+export { BncClient, crypto, amino, types, utils }
diff --git a/node_modules/@binance-chain/javascript-sdk/src/ledger/README.md b/node_modules/@binance-chain/javascript-sdk/src/ledger/README.md
new file mode 100644
index 0000000..893a4bf
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/ledger/README.md
@@ -0,0 +1,179 @@
+# Ledger App
+
+The general structure of Ledger commands and responses is as follows:
+
+#### Payload
+
+| Field   | Type     | Content                | Note |
+| :------ | :------- | :--------------------- | ---- |
+| CLA     | byte (1) | Application Identifier | 0xBC |
+| INS     | byte (1) | Instruction ID         |      |
+| P1      | byte (1) | Parameter 1            |      |
+| P2      | byte (1) | Parameter 2            |      |
+| L       | byte (1) | Bytes in payload       |      |
+| PAYLOAD | byte (L) | Payload                |      |
+
+#### Response
+
+| Field   | Type     | Content     | Note                     |
+| ------- | -------- | ----------- | ------------------------ |
+| ANSWER  | byte (?) | Answer      | depends on the command   |
+| SW1-SW2 | byte (2) | Return code | see list of return codes |
+
+#### Return codes
+
+| Return code | Description             |
+| ----------- | ----------------------- |
+| 0x6400      | Execution Error         |
+| 0x6982      | Empty buffer            |
+| 0x6983      | Output buffer too small |
+| 0x6986      | Command not allowed     |
+| 0x6A80      | Incorrect tx data       |
+| 0x6D00      | INS not supported       |
+| 0x6E00      | CLA not supported       |
+| 0x6F00      | Unknown                 |
+| 0x9000      | Success                 |
+
+---
+
+## Commands
+
+### GET_VERSION
+
+#### Payload
+
+| Field | Type     | Content                | Expected |
+| ----- | -------- | ---------------------- | -------- |
+| CLA   | byte (1) | Application Identifier | 0xBC     |
+| INS   | byte (1) | Instruction ID         | 0x00     |
+| P1    | byte (1) | Parameter 1            | ignored  |
+| P2    | byte (1) | Parameter 2            | ignored  |
+| L     | byte (1) | Bytes in payload       | 0        |
+
+#### Response
+
+| Field   | Type     | Content       | Note                            |
+| ------- | -------- | ------------- | ------------------------------- |
+| CLA     | byte (1) | Test Mode     | 0xFF means test mode is enabled |
+| MAJOR   | byte (1) | Version Major |                                 |
+| MINOR   | byte (1) | Version Minor |                                 |
+| PATCH   | byte (1) | Version Patch |                                 |
+| LOCKED  | byte (1) | Device Locked | boolean                         |
+| SW1-SW2 | byte (2) | Return code   | see list of return codes        |
+
+### PUBLIC_KEY_SECP256K1
+
+#### Payload
+
+| Field      | Type     | Content                | Expected  |
+| ---------- | -------- | ---------------------- | --------- |
+| CLA        | byte (1) | Application Identifier | 0xBC      |
+| INS        | byte (1) | Instruction ID         | 0x01      |
+| P1         | byte (1) | Parameter 1            | ignored   |
+| P2         | byte (1) | Parameter 2            | ignored   |
+| L          | byte (1) | Bytes in payload       | (depends) |
+| PL         | byte (1) | Derivation Path Length | 3<=PL<=10 |
+| Path[0]    | byte (4) | Derivation Path Data   | 44        |
+| Path[1]    | byte (4) | Derivation Path Data   | 118       |
+| ..         | byte (4) | Derivation Path Data   |           |
+| Path[PL-1] | byte (4) | Derivation Path Data   |           |
+
+First three items in the derivation path will be hardened automatically hardened
+
+#### Response
+
+| Field   | Type      | Content     | Note                     |
+| ------- | --------- | ----------- | ------------------------ |
+| PK      | byte (65) | Public Key  |                          |
+| SW1-SW2 | byte (2)  | Return code | see list of return codes |
+
+### SIGN_SECP256K1
+
+#### Payload
+
+| Field | Type     | Content                | Expected  |
+| ----- | -------- | ---------------------- | --------- |
+| CLA   | byte (1) | Application Identifier | 0xBC      |
+| INS   | byte (1) | Instruction ID         | 0x02      |
+| P1    | byte (1) | Packet Current Index   |           |
+| P2    | byte (1) | Packet Total Count     |
+|       |
+| L     | byte (1) | Bytes in payload       | (depends) |
+
+The first packet/chunk includes only the derivation path
+
+All other packets/chunks should contain message to sign
+
+_First Packet_
+
+| Field      | Type     | Content                | Expected  |
+| ---------- | -------- | ---------------------- | --------- |
+| PL         | byte (1) | Derivation Path Length | 3<=PL<=10 |
+| Path[0]    | byte (4) | Derivation Path Data   | 44        |
+| Path[1]    | byte (4) | Derivation Path Data   | 118       |
+| ..         | byte (4) | Derivation Path Data   |           |
+| Path[PL-1] | byte (4) | Derivation Path Data   |           |
+| Message    | bytes... | Message to Sign        |           |
+
+_Other Chunks/Packets_
+
+| Field   | Type     | Content         | Expected |
+| ------- | -------- | --------------- | -------- |
+| Message | bytes... | Message to Sign |          |
+
+#### Response
+
+| Field   | Type       | Content     | Note                          |
+| ------- | ---------- | ----------- | ----------------------------- |
+| SIG     | byte (~71) | Signature   | DER encoded (length prefixed) |
+| SW1-SW2 | byte (2)   | Return code | see list of return codes      |
+
+### INS_SHOW_ADDR_SECP256K1
+
+#### Payload
+
+| Field      | Type           | Content                | Expected       |
+| ---------- | -------------- | ---------------------- | -------------- |
+| CLA        | byte (1)       | Application Identifier | 0xBC           |
+| INS        | byte (1)       | Instruction ID         | 0x03           |
+| P1         | byte (1)       | Parameter 1            | ignored        |
+| P2         | byte (1)       | Parameter 2            | ignored        |
+| L          | byte (1)       | Bytes in payload       | (depends)      |
+| HRP_LEN    | byte(1)        | Bech32 HRP Length      | 1<=HRP_LEN<=83 |
+| HRP        | byte (HRP_LEN) | Bech32 HRP             |                |
+| PL         | byte (1)       | Derivation Path Length | 3<=PL<=5       |
+| Path[0]    | byte (4)       | Derivation Path Data   | 44             |
+| Path[1]    | byte (4)       | Derivation Path Data   | 714            |
+| ..         | byte (4)       | Derivation Path Data   |                |
+| Path[PL-1] | byte (4)       | Derivation Path Data   |                |
+
+First three items in the derivation path will be automatically hardened
+
+### INS_GET_ADDR_SECP256K1
+
+#### Payload
+
+| Field      | Type           | Content                | Expected       |
+| ---------- | -------------- | ---------------------- | -------------- |
+| CLA        | byte (1)       | Application Identifier | 0xBC           |
+| INS        | byte (1)       | Instruction ID         | 0x04           |
+| P1         | byte (1)       | Parameter 1            | ignored        |
+| P2         | byte (1)       | Parameter 2            | ignored        |
+| L          | byte (1)       | Bytes in payload       | (depends)      |
+| HRP_LEN    | byte(1)        | Bech32 HRP Length      | 1<=HRP_LEN<=83 |
+| HRP        | byte (HRP_LEN) | Bech32 HRP             |                |
+| PL         | byte (1)       | Derivation Path Length | 3<=PL<=5       |
+| Path[0]    | byte (4)       | Derivation Path Data   | 44             |
+| Path[1]    | byte (4)       | Derivation Path Data   | 714            |
+| ..         | byte (4)       | Derivation Path Data   |                |
+| Path[PL-1] | byte (4)       | Derivation Path Data   |                |
+
+First three items in the derivation path will be hardened automatically hardened
+
+#### Response
+
+| Field   | Type      | Content               | Note                     |
+| ------- | --------- | --------------------- | ------------------------ |
+| PK      | byte (33) | Compressed Public Key |                          |
+| ADDR    | byte (65) | Bech 32 addr          |                          |
+| SW1-SW2 | byte (2)  | Return code           | see list of return codes |
diff --git a/node_modules/@binance-chain/javascript-sdk/src/ledger/index.ts b/node_modules/@binance-chain/javascript-sdk/src/ledger/index.ts
new file mode 100644
index 0000000..9ccbc55
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/ledger/index.ts
@@ -0,0 +1,46 @@
+/********************************************************************************
+ *   Binance Chain Ledger App Interface
+ *   (c) 2018-2019 Binance
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ ********************************************************************************/
+/* eslint-disable*/
+import ledgerApp from "./ledger-app"
+
+import u2f from "@ledgerhq/hw-transport-webusb"
+import wble from "@ledgerhq/hw-transport-web-ble"
+
+const Ledger: any = {
+  app: ledgerApp,
+  LedgerApp: ledgerApp,
+  transports: {
+    u2f,
+    wble,
+
+    // requiring the node transport in the browser causes a bit of an issue with webpack! this is a conditional require
+    // node:
+    //   !isBrowser && moduleExists(LEDGER_NODE_HID_TRANSPORT_MODULE)
+    //     ? require(LEDGER_NODE_HID_TRANSPORT_MODULE).default
+    //     : null,
+  },
+}
+
+export default Ledger
+
+function moduleExists(name: string) {
+  try {
+    return require.resolve(name)
+  } catch (e) {
+    return false
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/ledger/ledger-app.ts b/node_modules/@binance-chain/javascript-sdk/src/ledger/ledger-app.ts
new file mode 100644
index 0000000..4dc98e8
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/ledger/ledger-app.ts
@@ -0,0 +1,626 @@
+/* eslint-disable */
+/********************************************************************************
+ *   Binance Chain Ledger App Interface
+ *   (c) 2018-2019 Binance
+ *   (c) 2018 ZondaX GmbH
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *******************************************************************************
+ */
+
+import Transport from "@ledgerhq/hw-transport"
+
+const DEFAULT_LEDGER_INTERACTIVE_TIMEOUT = 50000
+const DEFAULT_LEDGER_NONINTERACTIVE_TIMEOUT = 3000
+
+const CLA = 0xbc
+const SCRAMBLE_KEY = "CSM"
+const ACCEPT_STATUSES = [0x9000] // throw if not
+const CHUNK_SIZE = 250
+
+const INS_GET_VERSION = 0x00
+const INS_PUBLIC_KEY_SECP256K1 = 0x01
+const INS_SIGN_SECP256K1 = 0x02
+const INS_SHOW_ADDR_SECP256K1 = 0x03
+// const INS_GET_ADDR_SECP256K1 = 0x04
+
+export interface Version {
+  test_mode?: boolean
+  major?: number
+  minor?: number
+  patch?: number
+  device_locked?: boolean
+  return_code?: number
+  error_message?: string
+}
+
+export interface PublicKey {
+  pk?: Buffer
+  return_code?: number
+  error_message?: string
+}
+
+export interface SignedSignature {
+  return_code?: number
+  error_message?: string
+  signature?: Buffer | null
+}
+
+export interface ReturnResponse {
+  return_code?: number
+  error_message?: string
+}
+
+// The general structure of commands and responses is as follows:
+
+// #### Commands
+
+// | Field   | Type     | Content                | Note |
+// |:------- |:-------- |:---------------------- | ---- |
+// | CLA     | byte (1) | Application Identifier | 0xBC |
+// | INS     | byte (1) | Instruction ID         |      |
+// | P1      | byte (1) | Parameter 1            |      |
+// | P2      | byte (1) | Parameter 2            |      |
+// | L       | byte (1) | Bytes in payload       |      |
+// | PAYLOAD | byte (L) | Payload                |      |
+
+// #### Response
+
+// | Field   | Type     | Content     | Note                     |
+// | ------- | -------- | ----------- | ------------------------ |
+// | ANSWER  | byte (?) | Answer      | depends on the command   |
+// | SW1-SW2 | byte (2) | Return code | see list of return codes |
+
+/**
+ * Ledger app interface.
+ * @static
+ */
+class LedgerApp {
+  private _transport: Transport
+  private _interactiveTimeout: number
+  private _nonInteractiveTimeout: number
+  /**
+   * Constructs a new LedgerApp.
+   * @param {Transport} transport Ledger Transport, a subclass of ledgerjs Transport.
+   * @param {Number} interactiveTimeout The interactive (user input) timeout in ms. Default 45s.
+   * @param {Number} nonInteractiveTimeout The non-interactive timeout in ms. Default 3s.
+   */
+  constructor(
+    transport: Transport,
+    interactiveTimeout: number = DEFAULT_LEDGER_INTERACTIVE_TIMEOUT,
+    nonInteractiveTimeout: number = DEFAULT_LEDGER_NONINTERACTIVE_TIMEOUT
+  ) {
+    if (!transport || !transport.send) {
+      throw new Error("LedgerApp expected a Transport")
+    }
+    this._transport = transport
+    this._interactiveTimeout = interactiveTimeout
+    this._nonInteractiveTimeout = nonInteractiveTimeout
+    this._transport.setScrambleKey(SCRAMBLE_KEY)
+  }
+
+  _serialize(cla: number = CLA, ins: number, p1 = 0, p2 = 0, data: any = null) {
+    let size = 5
+    if (data != null) {
+      if (data.length > 255) {
+        throw new Error("maximum data size = 255")
+      }
+      size += data.length
+    }
+    const buffer = Buffer.alloc(size)
+
+    buffer[0] = cla
+    buffer[1] = ins
+    buffer[2] = p1
+    buffer[3] = p2
+    buffer[4] = 0
+
+    if (data != null) {
+      buffer[4] = data.length
+      buffer.set(data, 5)
+    }
+
+    return buffer
+  }
+
+  _serializeHRP(hrp: string) {
+    if (hrp == null || hrp.length < 3 || hrp.length > 83) {
+      throw new Error("Invalid HRP")
+    }
+    const buf = Buffer.alloc(1 + hrp.length)
+    buf.writeUInt8(hrp.length, 0)
+    buf.write(hrp, 1)
+    return buf
+  }
+
+  _serializeHDPath(path: number[]) {
+    if (path == null || path.length < 3) {
+      throw new Error("Invalid path.")
+    }
+    if (path.length > 10) {
+      throw new Error("Invalid path. Length should be <= 10")
+    }
+    const buf = Buffer.alloc(1 + 4 * path.length)
+    buf.writeUInt8(path.length, 0)
+    for (let i = 0; i < path.length; i++) {
+      let v = path[i]
+      if (i < 3) {
+        v |= 0x80000000 // Harden
+      }
+      buf.writeInt32LE(v, 1 + i * 4)
+    }
+    return buf
+  }
+
+  _errorMessage(code: number) {
+    switch (code) {
+      case 1:
+        return "U2F: Unknown"
+      case 2:
+        return "U2F: Bad request"
+      case 3:
+        return "U2F: Configuration unsupported"
+      case 4:
+        return "U2F: Device Ineligible"
+      case 5:
+        return "U2F: Timeout"
+      case 14:
+        return "Timeout"
+      case 0x9000:
+        return "No errors"
+      case 0x9001:
+        return "Device is busy"
+      case 0x6400:
+        return "Execution Error"
+      case 0x6700:
+        return "Wrong Length"
+      case 0x6982:
+        return "Empty Buffer"
+      case 0x6983:
+        return "Output buffer too small"
+      case 0x6984:
+        return "Data is invalid"
+      case 0x6985:
+        return "Conditions not satisfied"
+      case 0x6986:
+        return "Transaction rejected"
+      case 0x6a80:
+        return "Bad key handle"
+      case 0x6b00:
+        return "Invalid P1/P2"
+      case 0x6d00:
+        return "Instruction not supported"
+      case 0x6e00:
+        return "The app does not seem to be open"
+      case 0x6f00:
+        return "Unknown error"
+      case 0x6f01:
+        return "Sign/verify error"
+      default:
+        return "Unknown error code"
+    }
+  }
+
+  /* GET_VERSION */
+
+  // #### Payload
+
+  // | Field | Type     | Content                | Expected |
+  // | ----- | -------- | ---------------------- | -------- |
+  // | CLA   | byte (1) | Application Identifier | 0xBC     |
+  // | INS   | byte (1) | Instruction ID         | 0x00     |
+  // | P1    | byte (1) | Parameter 1            | ignored  |
+  // | P2    | byte (1) | Parameter 2            | ignored  |
+  // | L     | byte (1) | Bytes in payload       | 0        |
+
+  // #### Response
+
+  // | Field   | Type     | Content       | Note                            |
+  // | ------- | -------- | ------------- | ------------------------------- |
+  // | CLA     | byte (1) | Test Mode     | 0xFF means test mode is enabled |
+  // | MAJOR   | byte (1) | Version Major |                                 |
+  // | MINOR   | byte (1) | Version Minor |                                 |
+  // | PATCH   | byte (1) | Version Patch |                                 |
+  // | LOCKED  | byte (1) | Device Locked | boolean                         |
+  // | SW1-SW2 | byte (2) | Return code   | see list of return codes        |
+
+  /**
+   * Gets the version of the Ledger app that is currently open on the device.
+   * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
+   */
+  async getVersion(): Promise<Version> {
+    const result: Version = {}
+    try {
+      this._transport.setExchangeTimeout(this._nonInteractiveTimeout)
+      const apduResponse = await this._transport.send(
+        CLA,
+        INS_GET_VERSION,
+        0,
+        0,
+        Buffer.alloc(0),
+        ACCEPT_STATUSES
+      )
+      if (!Buffer.isBuffer(apduResponse))
+        throw new Error("expected apduResponse to be Buffer")
+      const returnCode = apduResponse.slice(-2)
+      result["test_mode"] = apduResponse[0] !== 0
+      result["major"] = apduResponse[1]
+      result["minor"] = apduResponse[2]
+      result["patch"] = apduResponse[3]
+      result["device_locked"] = apduResponse[4] === 1
+      result["return_code"] = returnCode[0] * 256 + returnCode[1]
+      result["error_message"] = this._errorMessage(result["return_code"])
+    } catch (err) {
+      const { statusCode, statusText, message, stack } = err
+      console.warn(
+        "Ledger getVersion error:",
+        this._errorMessage(statusCode),
+        message,
+        statusText,
+        stack
+      )
+      throw err
+    }
+    return result
+  }
+
+  /* PUBLIC_KEY_SECP256K1 */
+
+  // #### Payload
+
+  // | Field | Type     | Content                 | Expected |
+  // | ----- | -------- | ----------------------  | -------- |
+  // | CLA   | byte (1) | Application Identifier  | 0xBC     |
+  // | INS   | byte (1) | Instruction ID          | 0x01     |
+  // | P1    | byte (1) | Parameter 1             | ignored  |
+  // | P2    | byte (1) | Parameter 2             | ignored  |
+  // | L     | byte (1) | Bytes in payload        | (depends) |
+  // | PL    | byte (1) | Derivation Path Length  | 3<=PL<=10 |
+  // | Path[0] | byte (4) | Derivation Path Data    | 44 |
+  // | Path[1] | byte (4) | Derivation Path Data    | 118 |
+  // | ..  | byte (4) | Derivation Path Data    |  |
+  // | Path[PL-1]  | byte (4) | Derivation Path Data    |  |
+
+  // First three items in the derivation path will be hardened automatically hardened
+
+  // #### Response
+
+  // | Field   | Type      | Content       | Note                            |
+  // | ------- | --------- | ------------- | ------------------------------- |
+  // | PK      | byte (65) | Public Key    |  |
+  // | SW1-SW2 | byte (2)  | Return code   | see list of return codes        |
+
+  /**
+   * Gets the public key from the Ledger app that is currently open on the device.
+   * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
+   * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
+   */
+  async publicKeySecp256k1(
+    hdPath: number[] = [44, 714, 0, 0, 0]
+  ): Promise<PublicKey> {
+    const result: PublicKey = {}
+    try {
+      this._transport.setExchangeTimeout(this._nonInteractiveTimeout)
+      const apduResponse = await this._transport.send(
+        CLA,
+        INS_PUBLIC_KEY_SECP256K1,
+        0,
+        0,
+        this._serializeHDPath(hdPath),
+        ACCEPT_STATUSES
+      )
+      if (!Buffer.isBuffer(apduResponse))
+        throw new Error("expected apduResponse to be Buffer")
+      const returnCode = apduResponse.slice(-2)
+      result["pk"] = apduResponse.slice(0, 1 + 64)
+      result["return_code"] = returnCode[0] * 256 + returnCode[1]
+      result["error_message"] = this._errorMessage(result["return_code"])
+    } catch (err) {
+      const { statusCode, statusText, message, stack } = err
+      console.warn(
+        "Ledger publicKeySecp256k1 error:",
+        this._errorMessage(statusCode),
+        message,
+        statusText,
+        stack
+      )
+      throw err
+    }
+    return result
+  }
+
+  /* SIGN_SECP256K1 */
+
+  // #### Payload
+
+  // | Field | Type     | Content                | Expected |
+  // | ----- | -------- | ---------------------- | -------- |
+  // | CLA   | byte (1) | Application Identifier | 0xBC     |
+  // | INS   | byte (1) | Instruction ID         | 0x02     |
+  // | P1    | byte (1) | Packet Current Index   |   |
+  // | P2    | byte (1) | Packet Total Count     |
+  //   |
+  // | L     | byte (1) | Bytes in payload       | (depends)        |
+
+  // The first packet/chunk includes only the derivation path
+
+  // All other packets/chunks should contain message to sign
+
+  // *First Packet*
+
+  // | Field | Type     | Content                | Expected |
+  // | ----- | -------- | ---------------------- | -------- |
+  // | PL    | byte (1) | Derivation Path Length  | 3<=PL<=10 |
+  // | Path[0] | byte (4) | Derivation Path Data    | 44 |
+  // | Path[1] | byte (4) | Derivation Path Data    | 118 |
+  // | ..  | byte (4) | Derivation Path Data    |  |
+  // | Path[PL-1]  | byte (4) | Derivation Path Data    |  |
+  // | Message | bytes... | Message to Sign | |
+
+  // *Other Chunks/Packets*
+
+  // | Field | Type     | Content                | Expected |
+  // | ----- | -------- | ---------------------- | -------- |
+  // | Message | bytes... | Message to Sign | |
+
+  // #### Response
+
+  // | Field   | Type      | Content       | Note                            |
+  // | ------- | --------- | ------------- | ------------------------------- |
+  // | SIG     | byte (~71) | Signature     | DER encoded (length prefixed parts) |
+  // | SW1-SW2 | byte (2)  | Return code   | see list of return codes        |
+
+  _signGetChunks(data: any, hdPath: number[]) {
+    const chunks = []
+    chunks.push(this._serializeHDPath(hdPath))
+    const buffer = Buffer.from(data)
+    for (let i = 0; i < buffer.length; i += CHUNK_SIZE) {
+      let end = i + CHUNK_SIZE
+      if (i > buffer.length) {
+        end = buffer.length
+      }
+      chunks.push(buffer.slice(i, end))
+    }
+    return chunks
+  }
+
+  async _signSendChunk(chunkIdx: any, chunksCount: any, chunk: any) {
+    const result: SignedSignature = {}
+    try {
+      const apduResponse = await this._transport.send(
+        CLA,
+        INS_SIGN_SECP256K1,
+        chunkIdx,
+        chunksCount,
+        chunk
+      )
+      if (!Buffer.isBuffer(apduResponse))
+        throw new Error("expected apduResponse to be Buffer")
+      const returnCode = apduResponse.slice(-2)
+
+      result["return_code"] = returnCode[0] * 256 + returnCode[1]
+      result["error_message"] = this._errorMessage(result["return_code"])
+
+      result["signature"] = null
+      if (apduResponse.length > 2) {
+        result["signature"] = apduResponse.slice(0, apduResponse.length - 2)
+      }
+    } catch (err) {
+      const { statusCode, statusText, message, stack } = err
+      console.warn(
+        "Ledger signSendChunk error:",
+        this._errorMessage(statusCode),
+        message,
+        statusText,
+        stack
+      )
+      throw err
+    }
+    return result
+  }
+
+  /**
+   * Sends a transaction sign doc to the Ledger app to be signed.
+   * @param {Buffer} signBytes The TX sign doc bytes to sign
+   * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
+   * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
+   */
+  async signSecp256k1(
+    signBytes: Buffer,
+    hdPath: number[] = [44, 714, 0, 0, 0]
+  ): Promise<SignedSignature> {
+    const result: SignedSignature = {}
+    const chunks = this._signGetChunks(signBytes, hdPath)
+    // _signSendChunk doesn't throw, it catches exceptions itself. no need for try/catch
+    let response
+    try {
+      if (chunks.length <= 1) {
+        this._transport.setExchangeTimeout(this._interactiveTimeout)
+      } else {
+        // more to come, non-interactive
+        this._transport.setExchangeTimeout(this._nonInteractiveTimeout)
+      }
+      response = await this._signSendChunk(1, chunks.length, chunks[0])
+      result["return_code"] = response.return_code
+      result["error_message"] = response.error_message
+      result["signature"] = null
+    } catch (err) {
+      const { statusCode, statusText, message, stack } = err
+      console.warn(
+        "Ledger signSecp256k1 error (chunk 1):",
+        this._errorMessage(statusCode),
+        message,
+        statusText,
+        stack
+      )
+      throw err
+    }
+    if (response.return_code === 0x9000) {
+      for (let i = 1; i < chunks.length; i++) {
+        try {
+          if (i === chunks.length - 1) {
+            // last?
+            this._transport.setExchangeTimeout(this._interactiveTimeout)
+          }
+          response = await this._signSendChunk(1 + i, chunks.length, chunks[i])
+          result["return_code"] = response.return_code
+          result["error_message"] = response.error_message
+        } catch (err) {
+          const { statusCode, statusText, message, stack } = err
+          console.warn(
+            "Ledger signSecp256k1 error (chunk 2):",
+            this._errorMessage(statusCode),
+            message,
+            statusText,
+            stack
+          )
+          throw err
+        }
+        if (response.return_code !== 0x9000) {
+          break
+        }
+      }
+      result["return_code"] = response.return_code
+      result["error_message"] = response.error_message
+
+      // Ledger has encoded the sig in ASN1 DER format, but we need a 64-byte buffer of <r,s>
+      // DER-encoded signature from Ledger:
+      // 0 0x30: a header byte indicating a compound structure
+      // 1 A 1-byte length descriptor for all what follows (ignore)
+      // 2 0x02: a header byte indicating an integer
+      // 3 A 1-byte length descriptor for the R value
+      // 4 The R coordinate, as a big-endian integer
+      //   0x02: a header byte indicating an integer
+      //   A 1-byte length descriptor for the S value
+      //   The S coordinate, as a big-endian integer
+      //  = 7 bytes of overhead
+      let signature = response.signature
+      if (!signature || !signature.length) {
+        throw new Error(
+          "Ledger assertion failed: Expected a non-empty signature from the device"
+        )
+      }
+      if (signature[0] !== 0x30) {
+        throw new Error(
+          "Ledger assertion failed: Expected a signature header of 0x30"
+        )
+      }
+      // decode DER string format
+      let rOffset = 4
+      let rLen = signature[3]
+      const sLen = signature[4 + rLen + 1] // skip over following 0x02 type prefix for s
+      let sOffset = signature.length - sLen
+      // we can safely ignore the first byte in the 33 bytes cases
+      if (rLen === 33) {
+        rOffset++ // chop off 0x00 padding
+        rLen--
+      }
+      if (sLen === 33) sOffset++ // as above
+      const sigR = signature.slice(rOffset, rOffset + rLen) // skip e.g. 3045022100 and pad
+      const sigS = signature.slice(sOffset)
+
+      signature = result["signature"] = Buffer.concat([sigR, sigS])
+      if (signature.length !== 64) {
+        throw new Error(
+          `Ledger assertion failed: incorrect signature length ${signature.length}`
+        )
+      }
+    } else {
+      throw new Error(
+        "Unable to sign the transaction. Return code " + response.return_code
+      )
+    }
+    return result
+  }
+
+  /* INS_SHOW_ADDR_SECP256K1 */
+
+  // #### Command
+
+  // | Field      | Type           | Content                | Expected       |
+  // | ---------- | -------------- | ---------------------- | -------------- |
+  // | CLA        | byte (1)       | Application Identifier | 0xBC           |
+  // | INS        | byte (1)       | Instruction ID         | 0x03           |
+  // | P1         | byte (1)       | Parameter 1            | ignored        |
+  // | P2         | byte (1)       | Parameter 2            | ignored        |
+  // | L          | byte (1)       | Bytes in payload       | (depends)      |
+  // | HRP_LEN    | byte(1)        | Bech32 HRP Length      | 1<=HRP_LEN<=83 |
+  // | HRP        | byte (HRP_LEN) | Bech32 HRP             |                |
+  // | PL         | byte (1)       | Derivation Path Length | 3<=PL<=5       |
+  // | Path[0]    | byte (4)       | Derivation Path Data   | 44             |
+  // | Path[1]    | byte (4)       | Derivation Path Data   | 714            |
+  // | ..         | byte (4)       | Derivation Path Data   |                |
+  // | Path[PL-1] | byte (4)       | Derivation Path Data   |                |
+
+  // First three items in the derivation path will be automatically hardened
+
+  /**
+   * Shows the user's address for the given HD path on the device display.
+   * @param {string} hrp The bech32 human-readable prefix
+   * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
+   * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
+   */
+  async showAddress(
+    hrp = "bnb",
+    hdPath: number[] = [44, 714, 0, 0, 0]
+  ): Promise<ReturnResponse> {
+    const result: ReturnResponse = {}
+    const data = Buffer.concat([
+      this._serializeHRP(hrp),
+      this._serializeHDPath(hdPath),
+    ])
+    this._transport.setExchangeTimeout(this._interactiveTimeout)
+    const apduResponse = await this._transport.send(
+      CLA,
+      INS_SHOW_ADDR_SECP256K1,
+      0,
+      0,
+      data,
+      ACCEPT_STATUSES
+    )
+    if (!Buffer.isBuffer(apduResponse))
+      throw new Error("expected apduResponse to be Buffer")
+    const returnCode = apduResponse.slice(-2)
+    result["return_code"] = returnCode[0] * 256 + returnCode[1]
+    result["error_message"] = this._errorMessage(result["return_code"])
+    if (result.return_code === 0x6a80) {
+      result["error_message"] = apduResponse
+        .slice(0, apduResponse.length - 2)
+        .toString("ascii")
+    }
+    return result
+  }
+
+  // convenience aliases
+
+  /**
+   * Gets the public key from the Ledger app that is currently open on the device.
+   * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
+   * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
+   */
+  getPublicKey(hdPath: number[]): Promise<PublicKey> {
+    return this.publicKeySecp256k1(hdPath)
+  }
+
+  /**
+   * Sends a transaction sign doc to the Ledger app to be signed.
+   * @param {Buffer} signBytes The TX sign doc bytes to sign
+   * @param {array} hdPath The HD path to use to get the public key. Default is [44, 714, 0, 0, 0]
+   * @throws Will throw Error if a transport error occurs, or if the firmware app is not open.
+   */
+  sign(signBytes: Buffer, hdPath: number[]): Promise<SignedSignature> {
+    return this.signSecp256k1(signBytes, hdPath)
+  }
+}
+
+export default LedgerApp
diff --git a/node_modules/@binance-chain/javascript-sdk/src/rpc/baseRpc.ts b/node_modules/@binance-chain/javascript-sdk/src/rpc/baseRpc.ts
new file mode 100644
index 0000000..b4076c3
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/rpc/baseRpc.ts
@@ -0,0 +1,188 @@
+/**
+ * https://github.com/nomic-io/js-tendermint/blob/master/src/rpc.js
+ */
+
+import axios from "axios"
+import { EventEmitter } from "events"
+import is from "is_js"
+import ndjson from "ndjson"
+import Pumpify from "pumpify"
+import url from "url"
+import websocket from "websocket-stream"
+
+export type Args = { [k: string]: any }
+
+function convertHttpArgs(url: string, args: Args = {}) {
+  const search = []
+  for (const k in args) {
+    if (is.string(args[k])) {
+      search.push(`${k}="${args[k]}"`)
+    } else if (Buffer.isBuffer(args[k])) {
+      search.push(`${k}=0x${args[k].toString("hex")}`)
+    } else {
+      search.push(`${k}=${args[k]}`)
+    }
+  }
+  return `${url}?${search.join("&")}`
+}
+
+function convertWsArgs(args: Args = {}) {
+  for (const k in args) {
+    const v = args[k]
+    if (typeof v === "number") {
+      args[k] = String(v)
+    } else if (Buffer.isBuffer(v)) {
+      args[k] = "0x" + v.toString("hex")
+    } else if (v instanceof Uint8Array) {
+      args[k] = "0x" + Buffer.from(v).toString("hex")
+    }
+  }
+  return args
+}
+
+const wsProtocols = ["ws:", "wss:"]
+const httpProtocols = ["http:", "https:"]
+const allProtocols = wsProtocols.concat(httpProtocols)
+
+export default class BaseRpc extends EventEmitter {
+  private uri: string
+  public call!: BaseRpc["callWs"] | BaseRpc["callHttp"]
+  private closed = false
+  private ws?: Pumpify
+
+  constructor(uriString = "localhost:27146") {
+    super()
+
+    // parse full-node URI
+    let { protocol, hostname, port } = url.parse(uriString)
+
+    // default to http
+    if (!protocol || !allProtocols.includes(protocol)) {
+      const uri = url.parse(`http://${uriString}`)
+      protocol = uri.protocol
+      hostname = uri.hostname
+      port = uri.port
+    }
+
+    this.uri = !port
+      ? `${protocol}//${hostname}/`
+      : `${protocol}//${hostname}:${port}/`
+
+    if (protocol && wsProtocols.includes(protocol)) {
+      this.uri = `${this.uri}websocket`
+      this.call = this.callWs
+      this.connectWs()
+    } else if (protocol && httpProtocols.includes(protocol)) {
+      this.call = this.callHttp
+    }
+  }
+
+  connectWs() {
+    this.ws = new Pumpify.obj(ndjson.stringify(), websocket(this.uri))
+
+    this.ws.on("error", (err) => this.emit("error", err))
+    this.ws.on("close", () => {
+      if (this.closed) return
+      this.emit("error", Error("websocket disconnected"))
+    })
+    this.ws.on("data", (data) => {
+      data = JSON.parse(data)
+      if (!data.id) return
+      this.emit(data.id, data.error, data.result)
+    })
+  }
+
+  callHttp(method: string, args?: Args) {
+    let url = this.uri + method
+    url = convertHttpArgs(url, args)
+    return axios({
+      url: url,
+    }).then(
+      function ({ data }) {
+        if (data.error) {
+          const err = Error(data.error.message)
+          Object.assign(err, data.error)
+          throw err
+        }
+        return data.result
+      },
+      function (err) {
+        throw Error(err)
+      }
+    )
+  }
+
+  callWs(method: string, args?: Args, listener?: (value: any) => void) {
+    const self = this
+    return new Promise((resolve, reject) => {
+      const id = Math.random().toString(36)
+      const params = convertWsArgs(args)
+      if (method === "subscribe") {
+        if (typeof listener !== "function") {
+          throw Error("Must provide listener function")
+        }
+
+        // events get passed to listener
+        this.on(id + "#event", (err, res) => {
+          if (err) return self.emit("error", err)
+          return listener(res.data.value)
+        })
+
+        // promise resolves on successful subscription or error
+        this.on(id, (err) => {
+          if (err) return reject(err)
+          resolve()
+        })
+      } else {
+        // response goes to promise
+        this.once(id, (err, res) => {
+          if (err) return reject(err)
+          resolve(res)
+        })
+      }
+
+      this.ws?.write({ jsonrpc: "2.0", id, method, params })
+    })
+  }
+
+  close() {
+    this.closed = true
+    if (!this.ws) return
+    this.ws.destroy()
+  }
+
+  private createCallBasedMethod = (name: string) => (
+    args?: Args,
+    listener?: Parameters<BaseRpc["call"]>[2]
+  ): any => {
+    return this.call(name, args, listener).then((res) => {
+      return res
+    })
+  }
+
+  subscribe = this.createCallBasedMethod("subscribe")
+  unsubscribe = this.createCallBasedMethod("unsubscribe")
+  unsubscribeAll = this.createCallBasedMethod("unsubscribe_all")
+
+  status = this.createCallBasedMethod("status")
+  netInfo = this.createCallBasedMethod("net_info")
+  blockchain = this.createCallBasedMethod("blockchain")
+  genesis = this.createCallBasedMethod("genesis")
+  health = this.createCallBasedMethod("health")
+  block = this.createCallBasedMethod("block")
+  blockResults = this.createCallBasedMethod("block_results")
+  validators = this.createCallBasedMethod("validators")
+  consensusState = this.createCallBasedMethod("consensus_state")
+  dumpConsensusState = this.createCallBasedMethod("dump_consensus_state")
+  broadcastTxCommit = this.createCallBasedMethod("broadcast_tx_commit")
+  broadcastTxSync = this.createCallBasedMethod("broadcast_tx_sync")
+  broadcastTxAsync = this.createCallBasedMethod("broadcast_tx_async")
+  unconfirmedTxs = this.createCallBasedMethod("unconfirmed_txs")
+  numUnconfirmedTxs = this.createCallBasedMethod("num_unconfirmed_txs")
+  commit = this.createCallBasedMethod("commit")
+  tx = this.createCallBasedMethod("tx")
+  txSearch = this.createCallBasedMethod("tx_search")
+
+  abciQuery = this.createCallBasedMethod("abci_query")
+  abciInfo = this.createCallBasedMethod("abci_info")
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/rpc/index.ts b/node_modules/@binance-chain/javascript-sdk/src/rpc/index.ts
new file mode 100644
index 0000000..843c483
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/rpc/index.ts
@@ -0,0 +1,319 @@
+import { Big } from "big.js"
+
+import { unMarshalBinaryLengthPrefixed, unMarshalBinaryBare } from "../amino"
+import { NETWORK_PREFIX_MAPPING } from "../client"
+import * as crypto from "../crypto"
+import Transaction from "../tx"
+import {
+  Token,
+  AppAccount,
+  OpenOrder,
+  TradingPair,
+  OrderBook,
+  TokenOfList,
+  TokenBalance,
+  Coin,
+  AminoPrefix,
+  abciQueryResponseResult,
+  StdTx,
+  ResponseDeliverTx,
+} from "../types"
+import {
+  validateSymbol,
+  validateTradingPair,
+  validateOffsetLimit,
+  convertObjectArrayNum,
+  getMsgByAminoPrefix,
+} from "../utils"
+
+import BaseRpc from "./baseRpc"
+
+/**
+ * The Binance Chain Node rpc client
+ */
+class RpcClient extends BaseRpc {
+  private netWork: keyof typeof NETWORK_PREFIX_MAPPING
+
+  /**
+   * @param {String} uriString dataseed address
+   * @param {String} netWork Binance Chain network
+   */
+  constructor(
+    uriString = "localhost:27146",
+    netWork: keyof typeof NETWORK_PREFIX_MAPPING
+  ) {
+    super(uriString)
+    this.netWork = netWork || "mainnet"
+  }
+
+  /**
+   * The RPC broadcast delegate broadcasts a transaction via RPC. This is intended for optional use as BncClient's broadcast delegate.
+   * @param {Transaction} signedTx the signed transaction
+   * @return {Promise}
+   */
+  async broadcastDelegate(signedTx: Transaction) {
+    // amino encode the signed TX
+    const encoded = signedTx.serialize()
+    // broadcast it via RPC; we have to use a promise here because that's
+    // what the BncClient expects as the return value of this function.
+    const res: any = await this.broadcastTxSync({
+      tx: Buffer.from(encoded, "hex"),
+    })
+    if (`${res.code}` === "0") {
+      return res
+    } else {
+      throw new Error(`broadcastDelegate: non-zero status code ${res.code}`)
+    }
+  }
+
+  getBech32Prefix() {
+    if (this.netWork === "mainnet") {
+      return "bnb"
+    }
+
+    if (this.netWork === "testnet") {
+      return "tbnb"
+    }
+
+    return ""
+  }
+
+  /**
+   * @param {String} symbol - required
+   * @returns {Object} token detail info
+   */
+  async getTokenInfo(symbol: string) {
+    validateSymbol(symbol)
+
+    const path = "/tokens/info/" + symbol
+
+    const res: abciQueryResponseResult = await this.abciQuery({ path })
+    const bytes = Buffer.from(res.response.value, "base64")
+    const tokenInfo = new Token()
+    unMarshalBinaryLengthPrefixed(bytes, tokenInfo)
+    const bech32Prefix = this.getBech32Prefix()
+    const ownerAddress = crypto.encodeAddress(tokenInfo.owner, bech32Prefix)
+
+    delete tokenInfo.aminoPrefix
+    //TODO all the result contains aminoPrefix, need to improve
+    return { ...tokenInfo, owner: ownerAddress }
+  }
+
+  /**
+   * get tokens by offset and limit
+   * @param {Number} offset
+   * @param {Number} limit
+   * @returns {Array} token list
+   */
+  async listAllTokens(offset: number, limit: number) {
+    validateOffsetLimit(offset, limit)
+    const path = `tokens/list/${offset}/${limit}`
+    const res: abciQueryResponseResult = await this.abciQuery({ path })
+    const bytes = Buffer.from(res.response.value, "base64")
+    const tokenArr = [new TokenOfList()]
+    const { val: tokenList }: any = unMarshalBinaryLengthPrefixed(
+      bytes,
+      tokenArr
+    )
+
+    unMarshalBinaryLengthPrefixed(bytes, tokenList)
+
+    return tokenList.map((item: TokenOfList) => ({
+      ...item,
+      owner: crypto.encodeAddress(item.owner, this.getBech32Prefix()),
+    }))
+  }
+
+  /**
+   * @param {String} address
+   * @returns {Object} Account info
+   */
+  async getAccount(address: string) {
+    const res: any = await this.abciQuery({
+      path: `/account/${address}`,
+    })
+    const accountInfo = new AppAccount()
+    const bytes = Buffer.from(res.response.value, "base64")
+    unMarshalBinaryBare(bytes, accountInfo)
+    const bech32Prefix = this.getBech32Prefix()
+
+    return {
+      name: accountInfo.name,
+      locked: accountInfo.locked,
+      frozen: accountInfo.frozen,
+      base: {
+        ...accountInfo.base,
+        address: crypto.encodeAddress(accountInfo.base.address, bech32Prefix),
+      },
+    }
+  }
+
+  /**
+   * @param {Array} balances
+   */
+  async getBalances(address: string) {
+    const account = await this.getAccount(address)
+    let coins: Coin[] = []
+    const balances: TokenBalance[] = []
+    if (account) {
+      coins = (account.base && account.base.coins) || []
+      convertObjectArrayNum<any>(coins, ["amount"])
+      convertObjectArrayNum<any>(account.locked, ["amount"])
+      convertObjectArrayNum<any>(account.frozen, ["amount"])
+    }
+
+    coins.forEach((item) => {
+      const locked: any =
+        account.locked.find((lockedItem) => item.denom === lockedItem.denom) ||
+        {}
+      const frozen: any =
+        account.frozen.find((frozenItem) => item.denom === frozenItem.denom) ||
+        {}
+      const bal = new TokenBalance()
+      bal.symbol = item.denom
+      bal.free = +new Big(item.amount).toString()
+      bal.locked = locked.amount || 0
+      bal.frozen = frozen.amount || 0
+      balances.push(bal)
+    })
+
+    return balances
+  }
+
+  /**
+   * get balance by symbol and address
+   * @param {String} address
+   * @param {String} symbol
+   * @returns {Object}
+   */
+  async getBalance(address: string, symbol: string) {
+    validateSymbol(symbol)
+    const balances = await this.getBalances(address)
+    const bal = balances.find(
+      (item) => item.symbol.toUpperCase() === symbol.toUpperCase()
+    )
+    return bal
+  }
+
+  /**
+   * @param {String} address
+   * @param {String} symbol
+   * @returns {Object}
+   */
+  async getOpenOrders(address: string, symbol: string) {
+    const path = `/dex/openorders/${symbol}/${address}`
+    const res = await this.abciQuery({ path })
+    const bytes = Buffer.from(res.response.value, "base64")
+    const result = [new OpenOrder()]
+    const { val: openOrders }: any = unMarshalBinaryLengthPrefixed(
+      bytes,
+      result
+    )
+    convertObjectArrayNum(openOrders, ["price", "quantity", "cumQty"])
+    return openOrders
+  }
+
+  /**
+   * @param {Number} offset
+   * @param {Number} limit
+   * @returns {Array}
+   */
+  async getTradingPairs(offset: number, limit: number) {
+    validateOffsetLimit(offset, limit)
+    const path = `/dex/pairs/${offset}/${limit}`
+    const res = await this.abciQuery({ path })
+    const bytes = Buffer.from(res.response.value, "base64")
+    const result = [new TradingPair()]
+    const { val: tradingPairs }: any = unMarshalBinaryLengthPrefixed(
+      bytes,
+      result
+    )
+    convertObjectArrayNum(tradingPairs, ["list_price", "tick_size", "lot_size"])
+    return tradingPairs
+  }
+
+  /**
+   * @param {String} tradePair
+   * @returns {Array}
+   */
+  async getDepth(tradePair: string) {
+    validateTradingPair(tradePair)
+    const path = `dex/orderbook/${tradePair}`
+    const res = await this.abciQuery({ path })
+    const bytes = Buffer.from(res.response.value, "base64")
+    const result = new OrderBook()
+    const { val: depth }: any = unMarshalBinaryLengthPrefixed(bytes, result)
+    convertObjectArrayNum(depth.levels, [
+      "buyQty",
+      "buyPrice",
+      "sellQty",
+      "sellPrice",
+    ])
+    return depth
+  }
+
+  async getTxByHash(hash: Buffer | string, prove = true) {
+    if (!Buffer.isBuffer(hash)) {
+      hash = Buffer.from(hash, "hex")
+    }
+
+    const res = await this.tx({
+      hash,
+      prove,
+    })
+    const txBytes = Buffer.from(res.tx, "base64")
+    const msgAminoPrefix = txBytes.slice(8, 12).toString("hex")
+    const msgType = getMsgByAminoPrefix(msgAminoPrefix)
+    const type: StdTx = {
+      msg: [msgType.defaultMsg()],
+      signatures: [
+        {
+          pub_key: Buffer.from(""),
+          signature: Buffer.from(""),
+          account_number: 0,
+          sequence: 0,
+        },
+      ],
+      memo: "",
+      source: 0,
+      data: "",
+      aminoPrefix: AminoPrefix.StdTx,
+    }
+
+    const { val: result }: any = unMarshalBinaryLengthPrefixed(txBytes, type)
+
+    const txResult = this.parseTxResult(res.tx_result)
+
+    //TODO remove aminoPrefix
+    return { ...res, tx: result, tx_result: txResult }
+  }
+
+  private parseTxResult(txResult: ResponseDeliverTx) {
+    if (txResult.data) {
+      txResult.data = Buffer.from(txResult.data, "base64").toString()
+    }
+
+    if (txResult.events && txResult.events.length > 0) {
+      for (let i = 0; i < txResult.events.length; i++) {
+        const event = txResult.events[i]
+        if (event.attributes && event.attributes.length > 0) {
+          event.attributes = event.attributes.map((item) => ({
+            key: Buffer.from(item.key, "base64").toString(),
+            value: Buffer.from(item.value, "base64").toString(),
+          }))
+        }
+      }
+    }
+
+    if (txResult.tags && txResult.tags.length > 0) {
+      txResult.tags = txResult.tags.map((item) => ({
+        key: Buffer.from(item.key, "base64").toString(),
+        value: Buffer.from(item.value, "base64").toString(),
+      }))
+    }
+
+    return { ...txResult }
+  }
+}
+
+export default RpcClient
diff --git a/node_modules/@binance-chain/javascript-sdk/src/tx/index.ts b/node_modules/@binance-chain/javascript-sdk/src/tx/index.ts
new file mode 100644
index 0000000..a5c8e0a
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/tx/index.ts
@@ -0,0 +1,172 @@
+import { curve } from "elliptic"
+
+import {
+  convertObjectToSignBytes,
+  UVarInt,
+  marshalBinary,
+  encodeBinaryByteArray,
+} from "../amino"
+import * as crypto from "../crypto"
+import {
+  BaseMsg,
+  SignMsg,
+  StdSignMsg,
+  StdSignature,
+  StdTx,
+  AminoPrefix,
+} from "../types"
+
+/**
+ * Creates a new transaction object.
+ * @example
+ * var rawTx = {
+ *   accountNumber: 1,
+ *   chainId: 'bnbchain-1000',
+ *   memo: '',
+ *   msg: {},
+ *   type: 'NewOrderMsg',
+ *   sequence: 29,
+ *   source: 0
+ * };
+ * var tx = new Transaction(rawTx);
+ * @property {Buffer} raw The raw vstruct encoded transaction
+ * @param {Number} data.account_number account number
+ * @param {String} data.chain_id bnbChain Id
+ * @param {String} data.memo transaction memo
+ * @param {String} type transaction type
+ * @param {Msg} data.msg object data of tx type
+ * @param {Number} data.sequence transaction counts
+ * @param {Number} data.source where does this transaction come from
+ */
+export default class Transaction {
+  private sequence: NonNullable<StdSignMsg["sequence"]>
+  private accountNumber: NonNullable<StdSignMsg["accountNumber"]>
+  private chainId: StdSignMsg["chainId"]
+
+  // DEPRECATED: Retained for backward compatibility,
+  private msg?: any
+
+  private baseMsg?: NonNullable<BaseMsg>
+  private memo: StdSignMsg["memo"]
+  private source: NonNullable<StdSignMsg["source"]>
+  private signatures: Array<StdSignature>
+
+  constructor(data: StdSignMsg) {
+    data = data || {}
+    if (!data.chainId) {
+      throw new Error("chain id should not be null")
+    }
+
+    this.sequence = data.sequence || 0
+    this.accountNumber = data.accountNumber || 0
+    this.chainId = data.chainId
+    this.msg = data.msg
+    this.baseMsg = data.baseMsg
+    this.memo = data.memo
+    this.source = data.source || 0 // default value is 0
+    this.signatures = []
+  }
+
+  /**
+   * generate the sign bytes for a transaction, given a msg
+   * @param {SignMsg} concrete msg object
+   * @return {Buffer}
+   **/
+  getSignBytes(msg?: SignMsg): Buffer {
+    msg = msg || (this.baseMsg && this.baseMsg.getSignMsg())
+    const signMsg = {
+      account_number: this.accountNumber.toString(),
+      chain_id: this.chainId,
+      data: null,
+      memo: this.memo,
+      msgs: [msg],
+      sequence: this.sequence.toString(),
+      source: this.source.toString(),
+    }
+    return convertObjectToSignBytes(signMsg)
+  }
+
+  /**
+   * attaches a signature to the transaction
+   * @param {Elliptic.PublicKey} pubKey
+   * @param {Buffer} signature
+   * @return {Transaction}
+   **/
+  addSignature(pubKey: curve.base.BasePoint, signature: Buffer): Transaction {
+    const pubKeyBuf = this._serializePubKey(pubKey) // => Buffer
+    this.signatures = [
+      {
+        pub_key: pubKeyBuf,
+        signature: signature,
+        account_number: this.accountNumber,
+        sequence: this.sequence,
+      },
+    ]
+    return this
+  }
+
+  /**
+   * sign transaction with a given private key and msg
+   * @param {string} privateKey private key hex string
+   * @param {SignMsg} concrete msg object
+   * @return {Transaction}
+   **/
+  sign(privateKey: string, msg?: SignMsg): Transaction {
+    if (!privateKey) {
+      throw new Error("private key should not be null")
+    }
+
+    const signBytes = this.getSignBytes(msg)
+    const privKeyBuf = Buffer.from(privateKey, "hex")
+    const signature = crypto.generateSignature(
+      signBytes.toString("hex"),
+      privKeyBuf
+    )
+    this.addSignature(crypto.generatePubKey(privKeyBuf), signature)
+    return this
+  }
+
+  /**
+   * encode signed transaction to hex which is compatible with amino
+   */
+  serialize(): string {
+    if (!this.signatures) {
+      throw new Error("need signature")
+    }
+    const msg = this.msg || (this.baseMsg && this.baseMsg.getMsg())
+    const stdTx: StdTx = {
+      msg: [msg],
+      signatures: this.signatures,
+      memo: this.memo,
+      source: this.source, // sdk value is 0, web wallet value is 1
+      data: "",
+      aminoPrefix: AminoPrefix.StdTx,
+    }
+    const bytes = marshalBinary(stdTx)
+    return bytes.toString("hex")
+  }
+
+  /**
+   * serializes a public key in a 33-byte compressed format.
+   * @param {Elliptic.PublicKey} unencodedPubKey
+   * @return {Buffer}
+   */
+  private _serializePubKey(unencodedPubKey: curve.base.BasePoint) {
+    let format = 0x2
+    const y = unencodedPubKey.getY()
+    const x = unencodedPubKey.getX()
+    if (y && y.isOdd()) {
+      format |= 0x1
+    }
+    let pubBz = Buffer.concat([
+      UVarInt.encode(format),
+      x.toArrayLike(Buffer, "be", 32),
+    ])
+
+    // prefixed with length
+    pubBz = encodeBinaryByteArray(pubBz)
+    // add the amino prefix
+    pubBz = Buffer.concat([Buffer.from("EB5AE987", "hex"), pubBz])
+    return pubBz
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/index.ts
new file mode 100644
index 0000000..9be33bc
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/index.ts
@@ -0,0 +1,3 @@
+export * from "./msg"
+export * from "./tx"
+export * from "./rpc"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/base/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/base/index.ts
new file mode 100644
index 0000000..0b1ec56
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/base/index.ts
@@ -0,0 +1,11 @@
+/* eslint-disable */
+export interface SignMsg {}
+export interface Msg {}
+
+export abstract class BaseMsg {
+  public abstract getSignMsg(): SignMsg
+  public abstract getMsg(): Msg
+  public static defaultMsg(): object {
+    return {}
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/bindMsg.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/bindMsg.ts
new file mode 100644
index 0000000..4cb7d7e
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/bindMsg.ts
@@ -0,0 +1,90 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedBindMsg extends SignMsg {
+  from: string
+  symbol: string
+  amount: number
+  contract_address: string
+  contract_decimals: number
+  expire_time: number
+}
+
+export interface BindMsgData extends Msg {
+  from: Buffer
+  symbol: string
+  amount: number
+  contract_address: Buffer
+  contract_decimals: number
+  expire_time: number
+  aminoPrefix: AminoPrefix
+}
+
+export class BindMsg extends BaseMsg {
+  private from: string
+  private symbol: string
+  private amount: number
+  private contract_address: string
+  private contract_decimals: number
+  private expire_time: number
+
+  constructor({
+    from,
+    symbol,
+    amount,
+    contract_address,
+    contract_decimals,
+    expire_time,
+  }: {
+    from: string
+    symbol: string
+    amount: number
+    contract_address: string
+    contract_decimals: number
+    expire_time: number
+  }) {
+    super()
+    this.from = from
+    this.symbol = symbol
+    this.amount = amount
+    this.contract_address = contract_address
+    this.contract_decimals = contract_decimals
+    this.expire_time = expire_time
+  }
+
+  getSignMsg(): SignedBindMsg {
+    return {
+      from: this.from,
+      symbol: this.symbol,
+      amount: this.amount,
+      contract_address: this.contract_address,
+      contract_decimals: this.contract_decimals,
+      expire_time: this.expire_time,
+    }
+  }
+
+  getMsg(): BindMsgData {
+    return {
+      from: crypto.decodeAddress(this.from),
+      symbol: this.symbol,
+      amount: this.amount,
+      contract_address: Buffer.from(this.contract_address.slice(2), "hex"),
+      contract_decimals: this.contract_decimals,
+      expire_time: this.expire_time,
+      aminoPrefix: AminoPrefix.BindMsg,
+    }
+  }
+
+  static defaultMsg(): BindMsgData {
+    return {
+      from: Buffer.from(""),
+      symbol: "",
+      amount: 0,
+      contract_address: Buffer.from(""),
+      contract_decimals: 0,
+      expire_time: 0,
+      aminoPrefix: AminoPrefix.BindMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/claimMsg.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/claimMsg.ts
new file mode 100644
index 0000000..0eba2ec
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/claimMsg.ts
@@ -0,0 +1,74 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+import { ClaimTypes } from "./claimTypes"
+
+export interface SignedClaimMsg extends SignMsg {
+  claim_type: ClaimTypes
+  sequence: number
+  claim: string
+  validator_address: string
+}
+
+export interface ClaimMsgData extends Msg {
+  claim_type: ClaimTypes
+  sequence: number
+  claim: string
+  validator_address: Buffer
+  aminoPrefix: AminoPrefix
+}
+
+export class ClaimMsg extends BaseMsg {
+  private claim_type: ClaimTypes
+  private sequence: number
+  private claim: string
+  private validator_address: string
+
+  constructor({
+    claim_type,
+    sequence,
+    claim,
+    validator_address,
+  }: {
+    claim_type: ClaimTypes
+    sequence: number
+    claim: string
+    validator_address: string
+  }) {
+    super()
+    this.claim_type = claim_type
+    this.sequence = sequence
+    this.claim = claim
+    this.validator_address = validator_address
+  }
+
+  getSignMsg(): SignedClaimMsg {
+    return {
+      claim_type: this.claim_type,
+      sequence: this.sequence,
+      claim: this.claim,
+      validator_address: this.validator_address,
+    }
+  }
+
+  getMsg(): ClaimMsgData {
+    return {
+      claim_type: this.claim_type,
+      sequence: this.sequence,
+      claim: this.claim,
+      validator_address: crypto.decodeAddress(this.validator_address),
+      aminoPrefix: AminoPrefix.ClaimMsg,
+    }
+  }
+
+  static defaultMsg(): ClaimMsgData {
+    return {
+      claim_type: ClaimTypes.ClaimTypeSkipSequence,
+      sequence: 0,
+      claim: "",
+      validator_address: Buffer.from(""),
+      aminoPrefix: AminoPrefix.ClaimMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/claimTypes.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/claimTypes.ts
new file mode 100644
index 0000000..8eb3e35
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/claimTypes.ts
@@ -0,0 +1,50 @@
+import { Coin } from ".."
+
+export enum ClaimTypes {
+  ClaimTypeSkipSequence = 0x1,
+  ClaimTypeUpdateBind = 0x2,
+  ClaimTypeTransferOutRefund = 0x3,
+  ClaimTypeTransferIn = 0x4,
+}
+
+export enum RefundReason {
+  UnboundToken = 1,
+  Timeout = 2,
+  InsufficientBalance = 3,
+  Unkown = 4,
+}
+
+export enum BindStatus {
+  BindStatusSuccess = 0,
+  BindStatusRejected = 1,
+  BindStatusTimeout = 2,
+  BindStatusInvalidParameter = 3,
+}
+
+export interface TransferInClaim {
+  contract_address: string
+  refund_addresses: string[]
+  receiver_addresses: string[]
+  amounts: number[]
+  symbol: string
+  relay_fee: Coin
+  expire_time: number
+}
+
+export interface TransferOutRefundClaim {
+  transfer_out_sequence: number
+  refund_address: string
+  amount: Coin
+  refund_reason: RefundReason
+}
+
+export interface UpdateBindClaim {
+  status: BindStatus
+  symbol: string
+  contract_address: string
+}
+
+export interface SkipSequenceClaim {
+  claim_type: ClaimTypes
+  sequenceToSkip: number
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/index.ts
new file mode 100644
index 0000000..02a7b70
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/index.ts
@@ -0,0 +1,4 @@
+export * from "./bindMsg"
+export * from "./claimMsg"
+export * from "./claimTypes"
+export * from "./transferOutMsg"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/transferOutMsg.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/transferOutMsg.ts
new file mode 100644
index 0000000..e201b6d
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/claim/transferOutMsg.ts
@@ -0,0 +1,77 @@
+import Big from "big.js"
+
+import { BaseMsg, Msg, SignMsg, Coin } from ".."
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedTransferOutMsg extends SignMsg {
+  from: string
+  to: string
+  amount: Coin
+  expire_time: number
+}
+
+export interface TransferoutData extends Msg {
+  from: Buffer
+  to: Buffer
+  amount: Coin
+  expire_time: number
+  aminoPrefix: AminoPrefix
+}
+
+export class TransferOutMsg extends BaseMsg {
+  private from: string
+  private to: string
+  private amount: Coin
+  private expire_time: number
+
+  constructor({
+    from,
+    to,
+    amount,
+    expire_time,
+  }: {
+    from: string
+    to: string
+    amount: Coin
+    expire_time: number
+  }) {
+    super()
+    this.from = from
+    this.to = to
+    this.amount = {
+      ...amount,
+      amount: Number(new Big(amount.amount).mul(Math.pow(10, 8)).toString()),
+    }
+    this.expire_time = expire_time
+  }
+
+  getSignMsg(): SignedTransferOutMsg {
+    return {
+      from: this.from,
+      to: this.to,
+      amount: this.amount,
+      expire_time: this.expire_time,
+    }
+  }
+
+  getMsg(): TransferoutData {
+    return {
+      from: crypto.decodeAddress(this.from),
+      to: Buffer.from(this.to.slice(2), "hex"),
+      amount: this.amount,
+      expire_time: this.expire_time,
+      aminoPrefix: AminoPrefix.TransferOutMsg,
+    }
+  }
+
+  static defaultMsg(): TransferoutData {
+    return {
+      from: Buffer.from(""),
+      to: Buffer.from(""),
+      amount: { denom: "", amount: 0 },
+      expire_time: 0,
+      aminoPrefix: AminoPrefix.TransferOutMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/cancelOrder.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/cancelOrder.ts
new file mode 100644
index 0000000..d10026b
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/cancelOrder.ts
@@ -0,0 +1,60 @@
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+import { BaseMsg, Msg, SignMsg } from "../base"
+
+export interface SignedCancelOrder extends SignMsg {
+  sender: string
+  symbol: string
+  refid: string
+}
+
+export interface CancelOrderData extends Msg {
+  sender: Buffer
+  symbol: string
+  refid: string
+  aminoPrefix: AminoPrefix
+}
+
+export class CancelOrderMsg extends BaseMsg {
+  private address: string
+  private symbol: string
+  private orderId: string
+  public readonly aminoPrefix: AminoPrefix = AminoPrefix.CancelOrderMsg
+
+  constructor(address: string, sybmol: string, orderId: string) {
+    super()
+    this.address = address
+    this.symbol = sybmol
+    this.orderId = orderId
+  }
+
+  getSignMsg() {
+    const signMsg: SignedCancelOrder = {
+      sender: this.address,
+      symbol: this.symbol,
+      refid: this.orderId,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: CancelOrderData = {
+      sender: crypto.decodeAddress(this.address),
+      symbol: this.symbol,
+      refid: this.orderId,
+      aminoPrefix: AminoPrefix.CancelOrderMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      sender: Buffer.from(""),
+      symbol: "",
+      refid: "",
+      aminoPrefix: AminoPrefix.CancelOrderMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/index.ts
new file mode 100644
index 0000000..16eabd3
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/index.ts
@@ -0,0 +1,3 @@
+export * from "./cancelOrder"
+export * from "./newOrder"
+export * from "./listMiniMsg"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/listMiniMsg.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/listMiniMsg.ts
new file mode 100644
index 0000000..0ac3e50
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/listMiniMsg.ts
@@ -0,0 +1,71 @@
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+import { BaseMsg, Msg, SignMsg } from "../base"
+
+export interface SignedListMini extends SignMsg {
+  from: string
+  base_asset_symbol: string
+  quote_asset_symbol: string
+  init_price: number
+}
+
+export interface ListMiniData extends Msg {
+  from: Buffer
+  base_asset_symbol: string
+  quote_asset_symbol: string
+  init_price: number
+  aminoPrefix: AminoPrefix
+}
+
+export class ListMiniMsg extends BaseMsg {
+  private from: string
+  private base_asset_symbol: string
+  private quote_asset_symbol: string
+  private init_price: number
+
+  constructor({
+    from,
+    base_asset_symbol,
+    quote_asset_symbol,
+    init_price,
+  }: SignedListMini) {
+    super()
+    this.from = from
+    this.base_asset_symbol = base_asset_symbol
+    this.quote_asset_symbol = quote_asset_symbol
+    this.init_price = init_price
+  }
+
+  getSignMsg() {
+    const signMsg: SignedListMini = {
+      from: this.from,
+      base_asset_symbol: this.base_asset_symbol,
+      quote_asset_symbol: this.quote_asset_symbol,
+      init_price: this.init_price,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: ListMiniData = {
+      from: crypto.decodeAddress(this.from),
+      base_asset_symbol: this.base_asset_symbol,
+      quote_asset_symbol: this.quote_asset_symbol,
+      init_price: this.init_price,
+      aminoPrefix: AminoPrefix.ListMiniMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      base_asset_symbol: "",
+      quote_asset_symbol: "",
+      init_price: 0,
+      aminoPrefix: AminoPrefix.ListMiniMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/newOrder.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/newOrder.ts
new file mode 100644
index 0000000..a2f4a30
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/dex/newOrder.ts
@@ -0,0 +1,81 @@
+import Big from "big.js"
+
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface NewOrder {
+  id: string
+  symbol: string
+  ordertype: number
+  side: number
+  price: number
+  quantity: number
+  timeinforce: number
+}
+
+export interface SignedNewOrder extends SignMsg, NewOrder {
+  sender: string
+}
+
+export interface NewOrderData extends Msg, NewOrder {
+  sender: Buffer
+  aminoPrefix: AminoPrefix
+}
+
+const BASENUMBER = Math.pow(10, 8)
+
+export class NewOrderMsg extends BaseMsg {
+  private newOrder: NewOrder
+  private address: string
+  public readonly aminoPrefix: AminoPrefix = AminoPrefix.NewOrderMsg
+
+  constructor(data: NewOrder, address: string) {
+    super()
+    const bigPrice = new Big(data.price)
+    const bigQuantity = new Big(data.quantity)
+
+    this.newOrder = data
+    this.newOrder.price = Number(bigPrice.mul(BASENUMBER).toString())
+    this.newOrder.quantity = Number(bigQuantity.mul(BASENUMBER).toString())
+    this.address = address
+  }
+
+  getSignMsg() {
+    const signMsg: SignedNewOrder = {
+      sender: this.address,
+      ...this.newOrder,
+    }
+    return signMsg
+  }
+
+  getMsg() {
+    const data: NewOrderData = {
+      sender: crypto.decodeAddress(this.address),
+      id: this.newOrder.id,
+      symbol: this.newOrder.symbol,
+      ordertype: this.newOrder.ordertype,
+      side: this.newOrder.side,
+      price: this.newOrder.price,
+      quantity: this.newOrder.quantity,
+      timeinforce: this.newOrder.timeinforce,
+      aminoPrefix: this.aminoPrefix,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      sender: Buffer.from(""),
+      id: "",
+      symbol: "",
+      orderType: 0,
+      side: 0,
+      price: 0,
+      quantity: 0,
+      timeinforce: 0,
+      aminoPrefix: AminoPrefix.NewOrderMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/gov/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/gov/index.ts
new file mode 100644
index 0000000..63aaac6
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/gov/index.ts
@@ -0,0 +1 @@
+export * from "./submitProposal"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/gov/submitProposal.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/gov/submitProposal.ts
new file mode 100644
index 0000000..b5f891b
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/gov/submitProposal.ts
@@ -0,0 +1,115 @@
+import { BaseMsg, Msg, SignMsg, Coin } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+const proposalTypeMapping = {
+  0x04: "ListTradingPair",
+  0x00: "Nil",
+  0x01: "Text",
+  0x02: "ParameterChange",
+  0x03: "SoftwareUpgrade",
+  0x05: "FeeChange",
+  0x06: "CreateValidator",
+  0x07: "RemoveValidator",
+} as const
+
+export interface SignedSubmitProposal extends SignMsg {
+  title: string
+  description: string
+  proposal_type: string
+  proposer: string
+  initial_deposit: { denom: string; amount: string }[]
+  voting_period: string
+}
+
+export interface SubmitProposalData extends Msg {
+  title: string
+  description: string
+  proposal_type: keyof typeof proposalTypeMapping
+  proposer: Buffer
+  initial_deposit: Coin[]
+  voting_period: number
+  aminoPrefix: AminoPrefix
+}
+
+export class SubmitProposalMsg extends BaseMsg {
+  private title: string
+  private description: string
+  private proposal_type: keyof typeof proposalTypeMapping
+  private address: string
+  private initialDeposit: number
+  private voting_period: number
+
+  constructor({
+    address,
+    title,
+    proposal_type,
+    initialDeposit,
+    voting_period,
+    description,
+  }: {
+    title: string
+    description: string
+    proposal_type: keyof typeof proposalTypeMapping
+    address: string
+    initialDeposit: number
+    voting_period: number
+  }) {
+    super()
+    this.address = address
+    this.title = title
+    this.proposal_type = proposal_type
+    this.initialDeposit = initialDeposit
+    this.voting_period = voting_period
+    this.description = description
+  }
+
+  getSignMsg() {
+    const signMsg: SignedSubmitProposal = {
+      title: this.title,
+      description: this.description,
+      proposal_type: proposalTypeMapping[this.proposal_type],
+      proposer: this.address,
+      voting_period: this.voting_period.toString(),
+      initial_deposit: [
+        {
+          denom: "BNB",
+          amount: new Big(this.initialDeposit).mul(Math.pow(10, 8)).toString(),
+        },
+      ],
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: SubmitProposalData = {
+      title: this.title,
+      description: this.description,
+      proposal_type: this.proposal_type,
+      proposer: crypto.decodeAddress(this.address),
+      initial_deposit: [
+        {
+          denom: "BNB",
+          amount: +new Big(this.initialDeposit).mul(Math.pow(10, 8)).toString(),
+        },
+      ],
+      voting_period: this.voting_period,
+      aminoPrefix: AminoPrefix.MsgSubmitProposal,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      title: "",
+      description: "",
+      propsal_type: 0,
+      proposer: Buffer.from(""),
+      inital_deposit: [{ denom: "", amount: 0 }],
+      voting_period: 0,
+      aminoPrefix: AminoPrefix.MsgSubmitProposal,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/index.ts
new file mode 100644
index 0000000..356037c
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/index.ts
@@ -0,0 +1,6 @@
+export * from "./base"
+export * from "./dex"
+export * from "./token"
+export * from "./send"
+export * from "./claim"
+export * from "./stake"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/send.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/send.ts
new file mode 100644
index 0000000..1fe0f4e
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/send.ts
@@ -0,0 +1,103 @@
+import Big, { BigSource } from "big.js"
+
+import * as crypto from "../../crypto"
+import { AminoPrefix } from "../tx"
+
+import { BaseMsg, Msg, SignMsg } from "./"
+
+export interface Coin {
+  denom: string
+  amount: BigSource
+}
+
+export interface SignInputOutput {
+  address: string
+  coins: Coin[]
+}
+
+interface InputOutput {
+  address: Buffer
+  coins: Coin[]
+}
+
+export interface SignedSend extends SignMsg {
+  inputs: SignInputOutput[]
+  outputs: SignInputOutput[]
+}
+
+export interface SendData extends Msg {
+  inputs: InputOutput[]
+  outputs: InputOutput[]
+  aminoPrefix: AminoPrefix
+}
+
+/**
+ * @ignore
+ * Only support transfers of one-to-one, one-to-many
+ */
+export class SendMsg extends BaseMsg {
+  private sender: string
+  private outputs: SignInputOutput[]
+  public readonly aminoPrefix: AminoPrefix = AminoPrefix.MsgSend
+  constructor(sender: string, outputs: SignInputOutput[]) {
+    super()
+    this.sender = sender
+    this.outputs = outputs
+  }
+
+  calInputCoins(inputsCoins: Coin[], coins: Coin[]) {
+    coins.forEach((coin) => {
+      const existCoin = inputsCoins.find((c) => c.denom === coin.denom)
+      if (existCoin) {
+        const existAmount = new Big(existCoin.amount)
+        existCoin.amount = Number(existAmount.plus(coin.amount).toString())
+      } else {
+        inputsCoins.push({ ...coin })
+      }
+    })
+  }
+
+  getSignMsg() {
+    const signMsg: SignedSend = {
+      inputs: [{ address: this.sender, coins: [] }],
+      outputs: this.outputs,
+    }
+
+    this.outputs.forEach((item) => {
+      this.calInputCoins(signMsg.inputs[0].coins, item.coins)
+    })
+
+    return signMsg
+  }
+
+  getMsg() {
+    const msg: SendData = {
+      inputs: [{ address: crypto.decodeAddress(this.sender), coins: [] }],
+      outputs: [],
+      aminoPrefix: this.aminoPrefix,
+    }
+
+    this.outputs.forEach((item) => {
+      this.calInputCoins(msg.inputs[0].coins, item.coins)
+
+      const output: InputOutput = {
+        address: crypto.decodeAddress(item.address),
+        coins: item.coins,
+      }
+
+      msg.outputs.push(output)
+    })
+
+    return msg
+  }
+
+  static defaultMsg() {
+    return {
+      inputs: [{ address: Buffer.from(""), coins: [{ denom: "", amount: 0 }] }],
+      outputs: [
+        { address: Buffer.from(""), coins: [{ denom: "", amount: 0 }] },
+      ],
+      aminoPrefix: AminoPrefix.MsgSend,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscDelegateMsg.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscDelegateMsg.ts
new file mode 100644
index 0000000..71372ce
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscDelegateMsg.ts
@@ -0,0 +1,80 @@
+import { BaseMsg, Msg, SignMsg, Coin } from ".."
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedBscDelegate extends SignMsg {
+  delegator_addr: string
+  validator_addr: string
+  delegation: Coin
+  side_chain_id: string
+}
+
+export interface BscDelegateData extends Msg {
+  delegator_addr: Buffer
+  validator_addr: Buffer
+  delegation: Coin
+  side_chain_id: string
+  aminoPrefix: AminoPrefix
+}
+
+export class BscDelegateMsg extends BaseMsg {
+  private delegator_addr: string
+  private validator_addr: string
+  private delegation: Coin
+  private side_chain_id: string
+
+  constructor({
+    delegator_addr,
+    validator_addr,
+    delegation,
+    side_chain_id,
+  }: {
+    delegator_addr: string
+    validator_addr: string
+    delegation: Coin
+    side_chain_id: string
+  }) {
+    super()
+    this.delegator_addr = delegator_addr
+    this.validator_addr = validator_addr
+    this.delegation = delegation
+    this.side_chain_id = side_chain_id
+  }
+
+  getSignMsg() {
+    const { denom, amount } = this.delegation
+    const signMsg: SignedBscDelegate = {
+      delegator_addr: this.delegator_addr,
+      validator_addr: this.validator_addr,
+      delegation: { denom, amount: String(amount) },
+      side_chain_id: this.side_chain_id,
+    }
+
+    return {
+      type: "cosmos-sdk/MsgSideChainDelegate",
+      value: signMsg,
+    }
+  }
+
+  getMsg() {
+    const data: BscDelegateData = {
+      delegator_addr: crypto.decodeAddress(this.delegator_addr),
+      validator_addr: crypto.decodeAddress(this.validator_addr),
+      delegation: this.delegation,
+      side_chain_id: this.side_chain_id,
+      aminoPrefix: AminoPrefix.MsgSideChainDelegate,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      delegator_addr: Buffer.from(""),
+      validator_addr: Buffer.from(""),
+      delegation: [{ denom: "", amount: 0 }],
+      side_chain_id: "",
+      aminoPrefix: AminoPrefix.MsgSideChainDelegate,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscRedelegateMsg.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscRedelegateMsg.ts
new file mode 100644
index 0000000..b69a3a4
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscRedelegateMsg.ts
@@ -0,0 +1,89 @@
+import { BaseMsg, Msg, SignMsg, Coin } from ".."
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedBscReDelegate extends SignMsg {
+  delegator_addr: string
+  validator_src_addr: string
+  validator_dst_addr: string
+  amount: Coin
+  side_chain_id: string
+}
+
+export interface BscReDelegateData extends Msg {
+  delegator_addr: Buffer
+  validator_src_addr: Buffer
+  validator_dst_addr: Buffer
+  amount: Coin
+  side_chain_id: string
+  aminoPrefix: AminoPrefix
+}
+
+export class BscReDelegateMsg extends BaseMsg {
+  private delegator_addr: string
+  private validator_src_addr: string
+  private validator_dst_addr: string
+  private amount: Coin
+  private side_chain_id: string
+
+  constructor({
+    delegator_addr,
+    validator_src_addr,
+    validator_dst_addr,
+    amount,
+    side_chain_id,
+  }: {
+    delegator_addr: string
+    validator_src_addr: string
+    validator_dst_addr: string
+    amount: Coin
+    side_chain_id: string
+  }) {
+    super()
+    this.delegator_addr = delegator_addr
+    this.validator_src_addr = validator_src_addr
+    this.validator_dst_addr = validator_dst_addr
+    this.amount = amount
+    this.side_chain_id = side_chain_id
+  }
+
+  getSignMsg() {
+    const { denom, amount } = this.amount
+    const signMsg: SignedBscReDelegate = {
+      delegator_addr: this.delegator_addr,
+      validator_src_addr: this.validator_src_addr,
+      validator_dst_addr: this.validator_dst_addr,
+      amount: { denom, amount: String(amount) },
+      side_chain_id: this.side_chain_id,
+    }
+
+    return {
+      type: "cosmos-sdk/MsgSideChainRedelegate",
+      value: signMsg,
+    }
+  }
+
+  getMsg() {
+    const data: BscReDelegateData = {
+      delegator_addr: crypto.decodeAddress(this.delegator_addr),
+      validator_src_addr: crypto.decodeAddress(this.validator_src_addr),
+      validator_dst_addr: crypto.decodeAddress(this.validator_dst_addr),
+      amount: this.amount,
+      side_chain_id: this.side_chain_id,
+      aminoPrefix: AminoPrefix.MsgSideChainRedelegate,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      delegator_addr: Buffer.from(""),
+      validator_src_addr: Buffer.from(""),
+      validator_dst_addr: Buffer.from(""),
+      amount: [{ denom: "", amount: 0 }],
+      side_chain_id: "",
+      aminoPrefix: AminoPrefix.MsgSideChainRedelegate,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscUndelegateMsg.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscUndelegateMsg.ts
new file mode 100644
index 0000000..c71c857
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/bscUndelegateMsg.ts
@@ -0,0 +1,80 @@
+import { BaseMsg, Msg, SignMsg, Coin } from ".."
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedBscUndelegate extends SignMsg {
+  delegator_addr: string
+  validator_addr: string
+  amount: Coin
+  side_chain_id: string
+}
+
+export interface BscUndelegateData extends Msg {
+  delegator_addr: Buffer
+  validator_addr: Buffer
+  amount: Coin
+  side_chain_id: string
+  aminoPrefix: AminoPrefix
+}
+
+export class BscUndelegateMsg extends BaseMsg {
+  private delegator_addr: string
+  private validator_addr: string
+  private amount: Coin
+  private side_chain_id: string
+
+  constructor({
+    delegator_addr,
+    validator_addr,
+    amount,
+    side_chain_id,
+  }: {
+    delegator_addr: string
+    validator_addr: string
+    amount: Coin
+    side_chain_id: string
+  }) {
+    super()
+    this.delegator_addr = delegator_addr
+    this.validator_addr = validator_addr
+    this.amount = amount
+    this.side_chain_id = side_chain_id
+  }
+
+  getSignMsg() {
+    const { denom, amount } = this.amount
+    const signMsg: SignedBscUndelegate = {
+      delegator_addr: this.delegator_addr,
+      validator_addr: this.validator_addr,
+      amount: { denom, amount: String(amount) },
+      side_chain_id: this.side_chain_id,
+    }
+
+    return {
+      type: "cosmos-sdk/MsgSideChainUndelegate",
+      value: signMsg,
+    }
+  }
+
+  getMsg() {
+    const data: BscUndelegateData = {
+      delegator_addr: crypto.decodeAddress(this.delegator_addr),
+      validator_addr: crypto.decodeAddress(this.validator_addr),
+      amount: this.amount,
+      side_chain_id: this.side_chain_id,
+      aminoPrefix: AminoPrefix.MsgSideChainUndelegate,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      delegator_addr: Buffer.from(""),
+      validator_addr: Buffer.from(""),
+      amount: [{ denom: "", amount: 0 }],
+      side_chain_id: "",
+      aminoPrefix: AminoPrefix.MsgSideChainUndelegate,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/index.ts
new file mode 100644
index 0000000..09963b7
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/stake/index.ts
@@ -0,0 +1,3 @@
+export * from "./bscDelegateMsg"
+export * from "./bscUndelegateMsg"
+export * from "./bscRedelegateMsg"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/burnToken.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/burnToken.ts
new file mode 100644
index 0000000..73fdeb4
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/burnToken.ts
@@ -0,0 +1,67 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedBurnToken extends SignMsg {
+  from: string
+  symbol: string
+  amount: number
+}
+
+export interface BurnTokenData extends Msg {
+  from: Buffer
+  symbol: string
+  amount: number
+  aminoPrefix: AminoPrefix
+}
+
+export class BurnTokenMsg extends BaseMsg {
+  private from: string
+  private symbol: string
+  private amount: number
+
+  constructor({
+    address,
+    sybmol,
+    amount,
+  }: {
+    address: string
+    sybmol: string
+    amount: number
+  }) {
+    super()
+    this.from = address
+    this.symbol = sybmol
+    this.amount = amount
+  }
+
+  getSignMsg() {
+    const signMsg: SignedBurnToken = {
+      from: this.from,
+      symbol: this.symbol,
+      amount: this.amount,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: BurnTokenData = {
+      from: crypto.decodeAddress(this.from),
+      symbol: this.symbol,
+      amount: this.amount,
+      aminoPrefix: AminoPrefix.BurnMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      symbol: "",
+      amount: 0,
+      aminoPrefix: AminoPrefix.BurnMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/freezeToken.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/freezeToken.ts
new file mode 100644
index 0000000..1f6afbd
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/freezeToken.ts
@@ -0,0 +1,67 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedFreezeToken extends SignMsg {
+  from: string
+  symbol: string
+  amount: number
+}
+
+export interface FreezeTokenData extends Msg {
+  from: Buffer
+  symbol: string
+  amount: number
+  aminoPrefix: AminoPrefix
+}
+
+export class FreezeTokenMsg extends BaseMsg {
+  private from: string
+  private symbol: string
+  private amount: number
+
+  constructor({
+    address,
+    sybmol,
+    amount,
+  }: {
+    address: string
+    sybmol: string
+    amount: number
+  }) {
+    super()
+    this.from = address
+    this.symbol = sybmol
+    this.amount = amount
+  }
+
+  getSignMsg() {
+    const signMsg: SignedFreezeToken = {
+      from: this.from,
+      symbol: this.symbol,
+      amount: this.amount,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: FreezeTokenData = {
+      from: crypto.decodeAddress(this.from),
+      symbol: this.symbol,
+      amount: this.amount,
+      aminoPrefix: AminoPrefix.FreezeMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      symbol: "",
+      amount: 0,
+      aminoPrefix: AminoPrefix.FreezeMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/index.ts
new file mode 100644
index 0000000..d81dfde
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/index.ts
@@ -0,0 +1,11 @@
+export * from "./burnToken"
+export * from "./freezeToken"
+export * from "./unFreezeToken"
+export * from "./issueToken"
+export * from "./mintToken"
+export * from "./timelock"
+export * from "./timeRelock"
+export * from "./timeUnlock"
+export * from "./issueMiniToken"
+export * from "./issueTinyToken"
+export * from "./setTokenUri"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueMiniToken.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueMiniToken.ts
new file mode 100644
index 0000000..c878ce9
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueMiniToken.ts
@@ -0,0 +1,65 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedIssueMiniTokenMsg extends SignMsg {
+  name: string
+  symbol: string
+  total_supply: number
+  mintable: boolean
+  from: string
+  token_uri: string | undefined
+}
+
+export interface IssueMiniTokenData extends Msg {
+  name: string
+  symbol: string
+  total_supply: number
+  mintable: boolean
+  from: Buffer
+  token_uri: string | undefined
+  aminoPrefix: AminoPrefix
+}
+
+export class IssueMiniTokenMsg extends BaseMsg {
+  private params: SignedIssueMiniTokenMsg
+
+  constructor(params: SignedIssueMiniTokenMsg) {
+    super()
+    this.params = params
+  }
+
+  getSignMsg() {
+    const signMsg: SignedIssueMiniTokenMsg = {
+      ...this.params,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: IssueMiniTokenData = {
+      from: crypto.decodeAddress(this.params.from),
+      name: this.params.name,
+      symbol: this.params.symbol,
+      total_supply: this.params.total_supply,
+      mintable: this.params.mintable,
+      token_uri: this.params.token_uri,
+      aminoPrefix: AminoPrefix.IssueMiniMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from,
+      name: "",
+      symbol: "",
+      total_supply: 0,
+      mintable: false,
+      token_uri: "",
+      aminoPrefix: AminoPrefix.IssueMiniMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueTinyToken.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueTinyToken.ts
new file mode 100644
index 0000000..305e0fc
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueTinyToken.ts
@@ -0,0 +1,65 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedIssueTinyTokenMsg extends SignMsg {
+  name: string
+  symbol: string
+  total_supply: number
+  mintable: boolean
+  from: string
+  token_uri: string | undefined
+}
+
+export interface IssueTinyTokenData extends Msg {
+  name: string
+  symbol: string
+  total_supply: number
+  mintable: boolean
+  from: Buffer
+  token_uri: string | undefined
+  aminoPrefix: AminoPrefix
+}
+
+export class IssueTinyTokenMsg extends BaseMsg {
+  private params: SignedIssueTinyTokenMsg
+
+  constructor(params: SignedIssueTinyTokenMsg) {
+    super()
+    this.params = params
+  }
+
+  getSignMsg() {
+    const signMsg: SignedIssueTinyTokenMsg = {
+      ...this.params,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: IssueTinyTokenData = {
+      from: crypto.decodeAddress(this.params.from),
+      name: this.params.name,
+      symbol: this.params.symbol,
+      total_supply: this.params.total_supply,
+      mintable: this.params.mintable,
+      token_uri: this.params.token_uri,
+      aminoPrefix: AminoPrefix.IssueTinyMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from,
+      name: "",
+      symbol: "",
+      total_supply: 0,
+      mintable: false,
+      token_uri: "",
+      aminoPrefix: AminoPrefix.IssueTinyMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueToken.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueToken.ts
new file mode 100644
index 0000000..c5ebb39
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/issueToken.ts
@@ -0,0 +1,63 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface IssueParams {
+  name: string
+  symbol: string
+  total_supply: number
+  mintable: boolean
+}
+
+export interface SignedIssueTokenMsg extends SignMsg, IssueParams {
+  from: string
+}
+
+export interface IssueTokenData extends Msg, IssueParams {
+  from: Buffer
+  aminoPrefix: AminoPrefix
+}
+
+export class IssueTokenMsg extends BaseMsg {
+  private from: string
+  private params: IssueParams
+
+  constructor(params: IssueParams, address: string) {
+    super()
+    this.from = address
+    this.params = params
+  }
+
+  getSignMsg() {
+    const signMsg: SignedIssueTokenMsg = {
+      from: this.from,
+      ...this.params,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: IssueTokenData = {
+      from: crypto.decodeAddress(this.from),
+      name: this.params.name,
+      symbol: this.params.symbol,
+      total_supply: this.params.total_supply,
+      mintable: this.params.mintable,
+      aminoPrefix: AminoPrefix.IssueMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from,
+      name: "",
+      symbol: "",
+      total_supply: 0,
+      mintable: false,
+      aminoPrefix: AminoPrefix.IssueMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/mintToken.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/mintToken.ts
new file mode 100644
index 0000000..b4f6054
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/mintToken.ts
@@ -0,0 +1,69 @@
+import Big from "big.js"
+
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedMintTokenMsg extends SignMsg {
+  from: string
+  symbol: string
+  amount: number
+}
+
+export interface MintTokenData extends Msg {
+  from: Buffer
+  symbol: string
+  amount: number
+  aminoPrefix: AminoPrefix
+}
+
+export class MintTokenMsg extends BaseMsg {
+  private from: string
+  private symbol: string
+  private amount: number
+
+  constructor({
+    address,
+    sybmol,
+    amount,
+  }: {
+    address: string
+    sybmol: string
+    amount: number
+  }) {
+    super()
+    this.from = address
+    this.symbol = sybmol
+    this.amount = amount
+  }
+
+  getSignMsg() {
+    const signMsg: SignedMintTokenMsg = {
+      from: this.from,
+      amount: Number(new Big(this.amount).mul(Math.pow(10, 8)).toString()),
+      symbol: this.symbol,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: MintTokenData = {
+      from: crypto.decodeAddress(this.from),
+      symbol: this.symbol,
+      amount: Number(new Big(this.amount).mul(Math.pow(10, 8)).toString()),
+      aminoPrefix: AminoPrefix.MintMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      symbol: "",
+      amount: 0,
+      aminoPrefix: AminoPrefix.MintMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/setTokenUri.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/setTokenUri.ts
new file mode 100644
index 0000000..f3b69a5
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/setTokenUri.ts
@@ -0,0 +1,59 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedSetUri extends SignMsg {
+  from: string
+  symbol: string
+  token_uri: string
+}
+
+export interface SetUriData extends Msg {
+  from: Buffer
+  symbol: string
+  token_uri: string
+  aminoPrefix: AminoPrefix
+}
+
+export class SetTokenUriMsg extends BaseMsg {
+  private from: string
+  private symbol: string
+  private token_uri: string
+
+  constructor({ from, symbol, token_uri }: SignedSetUri) {
+    super()
+    this.from = from
+    this.symbol = symbol
+    this.token_uri = token_uri
+  }
+
+  getSignMsg() {
+    const signMsg: SignedSetUri = {
+      from: this.from,
+      symbol: this.symbol,
+      token_uri: this.token_uri,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: SetUriData = {
+      from: crypto.decodeAddress(this.from),
+      symbol: this.symbol,
+      token_uri: this.token_uri,
+      aminoPrefix: AminoPrefix.SetURIMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      symbol: "",
+      token_uri: "",
+      aminoPrefix: AminoPrefix.SetURIMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timeRelock.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timeRelock.ts
new file mode 100644
index 0000000..e959fdd
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timeRelock.ts
@@ -0,0 +1,84 @@
+import { BaseMsg, Msg, SignMsg, Coin } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedTimeReLockMsg extends SignMsg {
+  from: string
+  time_lock_id: number
+  description: string
+  amount: Coin[]
+  lock_time: number
+}
+
+export interface TimeReLockData extends Msg {
+  from: Buffer
+  time_lock_id: number
+  description: string
+  amount: Coin[]
+  lock_time: number
+  aminoPrefix: AminoPrefix
+}
+
+export class TimeReLockMsg extends BaseMsg {
+  private from: string
+  private time_lock_id: number
+  private description: string
+  private lock_time: number
+  private amount: Coin[]
+
+  constructor({
+    address,
+    time_lock_id,
+    description,
+    amount,
+    lock_time,
+  }: {
+    address: string
+    time_lock_id: number
+    description: string
+    amount: Coin[]
+    lock_time: number
+  }) {
+    super()
+    this.from = address
+    this.description = description
+    this.amount = amount
+    this.lock_time = lock_time
+    this.time_lock_id = time_lock_id
+  }
+
+  getSignMsg() {
+    const signMsg: SignedTimeReLockMsg = {
+      from: this.from,
+      time_lock_id: this.time_lock_id,
+      amount: this.amount,
+      description: this.description,
+      lock_time: this.lock_time,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: TimeReLockData = {
+      from: crypto.decodeAddress(this.from),
+      time_lock_id: this.time_lock_id,
+      description: this.description,
+      amount: this.amount,
+      lock_time: this.lock_time,
+      aminoPrefix: AminoPrefix.TimeRelockMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      description: "",
+      amount: 0,
+      lock_time: 0,
+      aminoPrefix: AminoPrefix.TimeRelockMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timeUnlock.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timeUnlock.ts
new file mode 100644
index 0000000..5cf9ba0
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timeUnlock.ts
@@ -0,0 +1,58 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedTimeUnlockMsg extends SignMsg {
+  from: string
+  time_lock_id: number
+}
+
+export interface TimeUnlockData extends Msg {
+  from: Buffer
+  time_lock_id: number
+  aminoPrefix: AminoPrefix
+}
+
+export class TimeUnlockMsg extends BaseMsg {
+  private from: string
+  private time_lock_id: number
+
+  constructor({
+    address,
+    time_lock_id,
+  }: {
+    address: string
+    time_lock_id: number
+  }) {
+    super()
+    this.from = address
+    this.time_lock_id = time_lock_id
+  }
+
+  getSignMsg() {
+    const signMsg: SignedTimeUnlockMsg = {
+      from: this.from,
+      time_lock_id: this.time_lock_id,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: TimeUnlockData = {
+      from: crypto.decodeAddress(this.from),
+      time_lock_id: this.time_lock_id,
+      aminoPrefix: AminoPrefix.TimeUnlockMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      time_lock_id: 0,
+      aminoPrefix: AminoPrefix.TimeUnlockMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timelock.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timelock.ts
new file mode 100644
index 0000000..dfc42ca
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/timelock.ts
@@ -0,0 +1,76 @@
+import { BaseMsg, Msg, SignMsg, Coin } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedTimeLockMsg extends SignMsg {
+  from: string
+  description: string
+  amount: Coin[]
+  lock_time: number
+}
+
+export interface TimeLockData extends Msg {
+  from: Buffer
+  description: string
+  amount: Coin[]
+  lock_time: number
+  aminoPrefix: AminoPrefix
+}
+
+export class TimeLockMsg extends BaseMsg {
+  private from: string
+  private description: string
+  private lock_time: number
+  private amount: Coin[]
+
+  constructor({
+    address,
+    description,
+    amount,
+    lock_time,
+  }: {
+    address: string
+    description: string
+    amount: Coin[]
+    lock_time: number
+  }) {
+    super()
+    this.from = address
+    this.description = description
+    this.amount = amount
+    this.lock_time = lock_time
+  }
+
+  getSignMsg() {
+    const signMsg: SignedTimeLockMsg = {
+      from: this.from,
+      amount: this.amount,
+      description: this.description,
+      lock_time: this.lock_time,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: TimeLockData = {
+      from: crypto.decodeAddress(this.from),
+      description: this.description,
+      amount: this.amount,
+      lock_time: this.lock_time,
+      aminoPrefix: AminoPrefix.TimeLockMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      description: "",
+      amount: [{ denom: "", amount: 0 }],
+      lock_time: 0,
+      aminoPrefix: AminoPrefix.TimeLockMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/unFreezeToken.ts b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/unFreezeToken.ts
new file mode 100644
index 0000000..70ad8ec
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/msg/token/unFreezeToken.ts
@@ -0,0 +1,67 @@
+import { BaseMsg, Msg, SignMsg } from "../"
+import * as crypto from "../../../crypto"
+import { AminoPrefix } from "../../tx"
+
+export interface SignedUnFreezeToken extends SignMsg {
+  from: string
+  symbol: string
+  amount: number
+}
+
+export interface UnFreezeTokenData extends Msg {
+  from: Buffer
+  symbol: string
+  amount: number
+  aminoPrefix: AminoPrefix
+}
+
+export class UnFreezeTokenMsg extends BaseMsg {
+  private from: string
+  private symbol: string
+  private amount: number
+
+  constructor({
+    address,
+    sybmol,
+    amount,
+  }: {
+    address: string
+    sybmol: string
+    amount: number
+  }) {
+    super()
+    this.from = address
+    this.symbol = sybmol
+    this.amount = amount
+  }
+
+  getSignMsg() {
+    const signMsg: SignedUnFreezeToken = {
+      from: this.from,
+      symbol: this.symbol,
+      amount: this.amount,
+    }
+
+    return signMsg
+  }
+
+  getMsg() {
+    const data: UnFreezeTokenData = {
+      from: crypto.decodeAddress(this.from),
+      symbol: this.symbol,
+      amount: this.amount,
+      aminoPrefix: AminoPrefix.UnfreezeMsg,
+    }
+
+    return data
+  }
+
+  static defaultMsg() {
+    return {
+      from: Buffer.from(""),
+      symbol: "",
+      amount: 0,
+      aminoPrefix: AminoPrefix.UnfreezeMsg,
+    }
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/rpc/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/rpc/index.ts
new file mode 100644
index 0000000..eb01495
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/rpc/index.ts
@@ -0,0 +1,249 @@
+import { Coin } from "../msg"
+import { AminoPrefix } from "../tx"
+
+export class Token {
+  public aminoPrefix = AminoPrefix.BnbchainToken
+
+  public name: string
+  public symbol: string
+  public original_symbol: string
+  public total_supply: number
+  public owner: Buffer
+  public mintable: boolean
+
+  constructor(
+    opts: Partial<{
+      name: string
+      symbol: string
+      original_symbol: string
+      total_supply: number
+      owner: Buffer
+      mintable: boolean
+    }> = {}
+  ) {
+    this.name = opts.name || ""
+    this.symbol = opts.symbol || ""
+    this.original_symbol = opts.original_symbol || ""
+    this.total_supply = opts.total_supply || 0
+    this.owner = opts.owner || Buffer.alloc(0)
+    this.mintable = opts.mintable || false
+  }
+}
+
+export class TokenOfList {
+  public name: string
+  public symbol: string
+  public original_symbol: string
+  public total_supply: number
+  public owner: Buffer
+  public mintable: boolean
+
+  constructor(
+    opts: Partial<{
+      name: string
+      symbol: string
+      original_symbol: string
+      total_supply: number
+      owner: Buffer
+      mintable: boolean
+    }> = {}
+  ) {
+    this.name = opts.name || ""
+    this.symbol = opts.symbol || ""
+    this.original_symbol = opts.original_symbol || ""
+    this.total_supply = opts.total_supply || 0
+    this.owner = opts.owner || Buffer.alloc(0)
+    this.mintable = opts.mintable || false
+  }
+}
+
+export class BaseAccount {
+  public address: Buffer
+  public coins: Coin[]
+  public public_key: Buffer
+  public account_number: number
+  public sequence: number
+
+  constructor(
+    opts: Partial<{
+      address: Buffer
+      coins: Coin[]
+      public_key: Buffer
+      account_number: number
+      sequence: number
+    }> = {}
+  ) {
+    this.address = opts.address || Buffer.alloc(0)
+    this.coins = opts.coins || [{ denom: "", amount: 0 }]
+    this.public_key = opts.public_key || Buffer.alloc(0)
+    this.account_number = opts.account_number || 0
+    this.sequence = opts.sequence || 0
+  }
+}
+
+export class AppAccount {
+  public aminoPrefix = AminoPrefix.BnbchainAccount
+
+  public base: BaseAccount
+  public name: string
+  public locked: Coin[]
+  public frozen: Coin[]
+
+  constructor(
+    opts: Partial<{
+      base: BaseAccount
+      name: string
+      locked: Coin[]
+      frozen: Coin[]
+    }> = {}
+  ) {
+    this.base = opts.base || new BaseAccount()
+    this.name = opts.name || ""
+    this.locked = opts.locked || [{ denom: "", amount: 0 }]
+    this.frozen = opts.frozen || [{ denom: "", amount: 0 }]
+  }
+}
+
+export class TokenBalance {
+  public symbol: string
+  public free: number
+  public locked: number
+  public frozen: number
+
+  constructor(
+    opts: Partial<{
+      symbol: string
+      free: number
+      locked: number
+      frozen: number
+    }> = {}
+  ) {
+    this.symbol = opts.symbol || ""
+    this.free = opts.free || 0
+    this.locked = opts.locked || 0
+    this.frozen = opts.frozen || 0
+  }
+}
+
+export class OpenOrder {
+  public id: string
+  public symbol: string
+  public price: number
+  public quantity: number
+  public cumQty: number
+  public createdHeight: number
+  public createdTimestamp: number
+  public lastUpdatedHeight: number
+  public lastUpdatedTimestamp: number
+
+  constructor(
+    opts: Partial<{
+      id: string
+      symbol: string
+      price: number
+      quantity: number
+      cumQty: number
+      createdHeight: number
+      createdTimestamp: number
+      lastUpdatedHeight: number
+      lastUpdatedTimestamp: number
+    }> = {}
+  ) {
+    this.id = opts.id || ""
+    this.symbol = opts.symbol || ""
+    this.price = opts.price || 0
+    this.quantity = opts.quantity || 0
+    this.cumQty = opts.cumQty || 0
+    this.createdHeight = opts.createdHeight || 0
+    this.createdTimestamp = opts.createdTimestamp || 0
+    this.lastUpdatedHeight = opts.lastUpdatedHeight || 0
+    this.lastUpdatedTimestamp = opts.lastUpdatedTimestamp || 0
+  }
+}
+
+export class TradingPair {
+  public base_asset_symbol: string
+  public quote_asset_symbol: string
+  public list_price: number
+  public tick_size: number
+  public lot_size: number
+
+  constructor(
+    opts: Partial<{
+      base_asset_symbol: string
+      quote_asset_symbol: string
+      list_price: number
+      tick_size: number
+      lot_size: number
+    }> = {}
+  ) {
+    this.base_asset_symbol = opts.base_asset_symbol || ""
+    this.quote_asset_symbol = opts.quote_asset_symbol || ""
+    this.list_price = opts.list_price || 0
+    this.tick_size = opts.tick_size || 0
+    this.lot_size = opts.lot_size || 0
+  }
+}
+
+export class OrderBookLevel {
+  public buyQty: number
+  public buyPrice: number
+  public sellQty: number
+  public sellPrice: number
+
+  constructor(
+    opts: Partial<{
+      buyQty: number
+      buyPrice: number
+      sellQty: number
+      sellPrice: number
+    }> = {}
+  ) {
+    this.buyQty = opts.buyQty || 0
+    this.buyPrice = opts.buyPrice || 0
+    this.sellQty = opts.sellQty || 0
+    this.sellPrice = opts.sellPrice || 0
+  }
+}
+
+export class OrderBook {
+  public height: number
+  public levels: OrderBookLevel[]
+
+  constructor(
+    opts: Partial<{ height: number; levels: OrderBookLevel[] }> = {}
+  ) {
+    this.height = opts.height || 0
+    this.levels = opts.levels || [new OrderBookLevel()]
+  }
+}
+
+export class SubmitProposalMsg {
+  public aminoPrefix = AminoPrefix.MsgSubmitProposal
+
+  public title: string
+  public description: string
+  public proposal_type: number
+  public proposer: Buffer
+  public initial_deposit: number[]
+  public voting_period: number
+
+  constructor(
+    opts: Partial<{
+      title: string
+      description: string
+      proposal_type: number
+      proposer: Buffer
+      initial_deposit: number[]
+      voting_period: number
+    }> = {}
+  ) {
+    opts = opts || {}
+    this.title = opts.title || ""
+    this.description = opts.description || ""
+    this.proposal_type = opts.proposal_type || 0
+    this.proposer = opts.proposer || Buffer.alloc(0)
+    this.initial_deposit = opts.initial_deposit || []
+    this.voting_period = opts.voting_period || 0
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/abciResponse.d.ts b/node_modules/@binance-chain/javascript-sdk/src/types/tx/abciResponse.ts
similarity index 55%
rename from node_modules/@binance-chain/javascript-sdk/lib/types/tx/abciResponse.d.ts
rename to node_modules/@binance-chain/javascript-sdk/src/types/tx/abciResponse.ts
index 4fb1d96..851bf4b 100644
--- a/node_modules/@binance-chain/javascript-sdk/lib/types/tx/abciResponse.d.ts
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/tx/abciResponse.ts
@@ -1,7 +1,7 @@
 export interface abciQueryResponseResult {
-    response: abciQueryResponse;
+  response: abciQueryResponse
 }
+
 interface abciQueryResponse {
-    value: string;
+  value: string
 }
-export {};
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/tx/index.ts b/node_modules/@binance-chain/javascript-sdk/src/types/tx/index.ts
new file mode 100644
index 0000000..fe1b6b0
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/tx/index.ts
@@ -0,0 +1,3 @@
+export * from "./abciResponse"
+export * from "./stdTx"
+export * from "./txResult"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/tx/stdTx.ts b/node_modules/@binance-chain/javascript-sdk/src/types/tx/stdTx.ts
new file mode 100644
index 0000000..0ee8944
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/tx/stdTx.ts
@@ -0,0 +1,77 @@
+import { BaseMsg, Msg } from "../msg"
+
+export interface StdSignMsg {
+  chainId: string
+  accountNumber: number
+  sequence: number
+  baseMsg?: BaseMsg
+  msg?: Msg
+  memo: string
+  source: number
+  data?: Buffer | null | string
+}
+
+export interface StdSignature {
+  pub_key?: Buffer
+  signature: Buffer
+  account_number: number
+  sequence: number
+}
+
+export interface StdTx {
+  msg: Array<Msg>
+  signatures: Array<StdSignature>
+  memo: string
+  source: number
+  data?: Buffer | null | string
+  aminoPrefix: AminoPrefix
+}
+
+export enum AminoPrefix {
+  MsgSend = "2A2C87FA",
+  NewOrderMsg = "CE6DC043",
+  CancelOrderMsg = "166E681B",
+  IssueMsg = "17EFAB80",
+  BurnMsg = "7ED2D2A0",
+  FreezeMsg = "E774B32D",
+  UnfreezeMsg = "6515FF0D",
+  MintMsg = "467E0829",
+  ListMsg = "B41DE13F",
+  StdTx = "F0625DEE",
+  PubKeySecp256k1 = "EB5AE987",
+  SignatureSecp256k1 = "7FC4A495",
+  MsgSubmitProposal = "B42D614E",
+  MsgDeposit = "A18A56E5",
+  MsgVote = "A1CADD36",
+  TimeLockMsg = "07921531",
+  TimeUnlockMsg = "C4050C6C",
+  TimeRelockMsg = "504711DA",
+  HTLTMsg = "B33F9A24",
+  DepositHTLTMsg = "63986496",
+  ClaimHTLTMsg = "C1665300",
+  RefundHTLTMsg = "3454A27C",
+  SetAccountFlagsMsg = "BEA6E301",
+  BnbchainAccount = "4BDC4C27",
+  BnbchainToken = "140364E6",
+  MsgCreateValidator = "EB361D01",
+  MsgRemoveValidator = "C1AFE85F",
+  MsgCreateValidatorProposal = "DB6A19FD",
+  MsgEditValidator = "C2E8BCCD",
+  MsgDelegate = "921D2E4E",
+  MsgBeginUnbonding = "A3823C9A",
+  MsgBeginRedelegate = "267996D2",
+  MsgCreateSideChainValidator = "D17201E5",
+  MsgEditSideChainValidator = "264CC57B",
+  MsgSideChainDelegate = "E3A07FD2",
+  MsgSideChainRedelegate = "E3CED364",
+  MsgSideChainUndelegate = "514F7E0E",
+  Claim = "4E781C11",
+  ClaimMsg = "175A0521",
+  BindMsg = "B9AE640C",
+  TransferOutMsg = "800819C0",
+  IssueMiniMsg = "A3F16C41",
+  IssueTinyMsg = "ED2832D4",
+  SetURIMsg = "7B1D34E7",
+  ListMiniMsg = "4C264019",
+  MiniToken = "E0051C20",
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/types/tx/txResult.ts b/node_modules/@binance-chain/javascript-sdk/src/types/tx/txResult.ts
new file mode 100644
index 0000000..e1ad00b
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/types/tx/txResult.ts
@@ -0,0 +1,43 @@
+import { StdTx } from "./stdTx"
+
+export interface ResultTx {
+  hash: Buffer | string
+  height: number
+  index: number
+  tx_result: ResponseDeliverTx
+  tx: Buffer | StdTx
+  proof?: TxProof
+}
+
+export interface ResponseDeliverTx {
+  code?: number
+  data?: string
+  log?: string
+  info?: string
+  gas_wanted?: number
+  gas_used?: number
+  events?: Event[]
+  tags?: KVPair[]
+  codespace?: string
+}
+
+export interface TxProof {
+  rootHash: Buffer
+  data: Buffer
+  proof: {
+    total: number
+    index: number
+    leaf_hash: Buffer
+    aunts: Buffer[]
+  }
+}
+
+export interface Event {
+  type?: string
+  attributes?: KVPair[]
+}
+
+export interface KVPair {
+  key: string
+  value: string
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/utils/cryptoHelper.ts b/node_modules/@binance-chain/javascript-sdk/src/utils/cryptoHelper.ts
new file mode 100644
index 0000000..9333ae6
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/utils/cryptoHelper.ts
@@ -0,0 +1,301 @@
+import hexEncoding from "crypto-js/enc-hex"
+import RIPEMD160 from "crypto-js/ripemd160"
+import SHA256 from "crypto-js/sha256"
+import SHA3 from "crypto-js/sha3"
+
+import * as crypto from "../crypto"
+
+/**
+ * @param {arrayBuffer} buf
+ * @returns {string} ASCII string
+ */
+export const ab2str = (buf: Uint8Array) => {
+  const numArr: number[] = []
+  for (let i = 0, len = buf.length; i < len; i++) {
+    numArr.push(buf[i])
+  }
+  String.fromCharCode.apply(null, numArr)
+}
+
+/**
+ * @param {string} str - ASCII string
+ * @returns {arrayBuffer}
+ */
+export const str2ab = (str: string) => {
+  if (typeof str !== "string") {
+    throw new Error("str2ab expects a string")
+  }
+  const result = new Uint8Array(str.length)
+  for (let i = 0, strLen = str.length; i < strLen; i++) {
+    result[i] = str.charCodeAt(i)
+  }
+  return result
+}
+
+/**
+ * @param {string} str - HEX string
+ * @returns {number[]}
+ */
+export const hexstring2ab = (str: string) => {
+  ensureHex(str)
+  if (!str.length) return new Uint8Array()
+  const iters = str.length / 2
+  const result = new Uint8Array(iters)
+  for (let i = 0; i < iters; i++) {
+    result[i] = parseInt(str.substring(0, 2), 16)
+    str = str.substring(2)
+  }
+  return result
+}
+
+/**
+ * @param {arrayBuffer} arr
+ * @returns {string} HEX string
+ */
+export const ab2hexstring = (arr: any) => {
+  if (typeof arr !== "object") {
+    throw new Error("ab2hexstring expects an array")
+  }
+  let result = ""
+  for (let i = 0; i < arr.length; i++) {
+    let str = arr[i].toString(16)
+    str = str.length === 0 ? "00" : str.length === 1 ? "0" + str : str
+    result += str
+  }
+  return result
+}
+
+/**
+ * @param {string} str - ASCII string
+ * @returns {string} HEX string
+ */
+export const str2hexstring = (str: string) => ab2hexstring(str2ab(str))
+
+/**
+ * @param {string} hexstring - HEX string
+ * @returns {string} ASCII string
+ */
+export const hexstring2str = (hexstring: string) =>
+  ab2str(hexstring2ab(hexstring))
+
+/**
+ * convert an integer to big endian hex and add leading zeros
+ * @param {Number} num
+ * @returns {string}
+ */
+export const int2hex = (num: number) => {
+  if (typeof num !== "number") {
+    throw new Error("int2hex expects a number")
+  }
+  const h = num.toString(16)
+  return h.length % 2 ? "0" + h : h
+}
+
+/**
+ * Converts a number to a big endian hexstring of a suitable size, optionally little endian
+ * @param {Number} num
+ * @param {Number} size - The required size in bytes, eg 1 for Uint8, 2 for Uint16. Defaults to 1.
+ * @param {Boolean} littleEndian - Encode the hex in little endian form
+ * @return {string}
+ */
+export const num2hexstring = (num: number, size = 1, littleEndian = false) => {
+  if (typeof num !== "number") throw new Error("num must be numeric")
+  if (num < 0) throw new RangeError("num is unsigned (>= 0)")
+  if (size % 1 !== 0) throw new Error("size must be a whole integer")
+  if (!Number.isSafeInteger(num))
+    throw new RangeError(`num (${num}) must be a safe integer`)
+  size = size * 2
+  let hexstring = num.toString(16)
+  hexstring =
+    hexstring.length % size === 0
+      ? hexstring
+      : ("0".repeat(size) + hexstring).substring(hexstring.length)
+  if (littleEndian) hexstring = reverseHex(hexstring)
+  return hexstring
+}
+
+/**
+ * Converts a number to a variable length Int. Used for array length header
+ * @param {Number} num - The number
+ * @returns {string} hexstring of the variable Int.
+ */
+export const num2VarInt = (num: number) => {
+  if (num < 0xfd) {
+    return num2hexstring(num)
+  } else if (num <= 0xffff) {
+    // uint16
+    return "fd" + num2hexstring(num, 2, true)
+  } else if (num <= 0xffffffff) {
+    // uint32
+    return "fe" + num2hexstring(num, 4, true)
+  } else {
+    // uint64
+    return "ff" + num2hexstring(num, 8, true)
+  }
+}
+
+/**
+ * XORs two hexstrings
+ * @param {string} str1 - HEX string
+ * @param {string} str2 - HEX string
+ * @returns {string} XOR output as a HEX string
+ */
+export const hexXor = (str1: string, str2: string) => {
+  ensureHex(str1)
+  ensureHex(str2)
+  if (str1.length !== str2.length)
+    throw new Error("strings are disparate lengths")
+  const result: any[] = []
+  for (let i = 0; i < str1.length; i += 2) {
+    result.push(
+      parseInt(str1.substr(i, 2), 16) ^ parseInt(str2.substr(i, 2), 16)
+    )
+  }
+  return ab2hexstring(result)
+}
+
+/**
+ * Reverses an array. Accepts arrayBuffer.
+ * @param {Array} arr
+ * @returns {Uint8Array}
+ */
+export const reverseArray = (arr: any[]) => {
+  if (typeof arr !== "object" || !arr.length)
+    throw new Error("reverseArray expects an array")
+  const result = new Uint8Array(arr.length)
+  for (let i = 0; i < arr.length; i++) {
+    result[i] = arr[arr.length - 1 - i]
+  }
+
+  return result
+}
+
+/**
+ * Reverses a HEX string, treating 2 chars as a byte.
+ * @example
+ * reverseHex('abcdef') = 'efcdab'
+ * @param {string} hex - HEX string
+ * @return {string} HEX string reversed in 2s.
+ */
+export const reverseHex = (hex: string) => {
+  ensureHex(hex)
+  let out = ""
+  for (let i = hex.length - 2; i >= 0; i -= 2) {
+    out += hex.substr(i, 2)
+  }
+  return out
+}
+
+const hexRegex = /^([0-9A-Fa-f]{2})*$/
+
+/**
+ * Checks if input is a hexstring. Empty string is considered a hexstring.
+ * @example
+ * isHex('0101') = true
+ * isHex('') = true
+ * isHex('0x01') = false
+ * @param {string} str
+ * @return {boolean}
+ */
+export const isHex = (str: string) => {
+  try {
+    return hexRegex.test(str)
+  } catch (err) {
+    return false
+  }
+}
+
+/**
+ * Throws an error if input is not hexstring.
+ * @param {string} str
+ */
+export const ensureHex = (str: string) => {
+  if (!isHex(str)) throw new Error(`Expected a hexstring but got ${str}`)
+}
+
+/**
+ * Computes a SHA256 followed by a RIPEMD160.
+ * @param {string} hex message to hash
+ * @returns {string} hash output
+ */
+export const sha256ripemd160 = (hex: string) => {
+  if (typeof hex !== "string")
+    throw new Error("sha256ripemd160 expects a string")
+  if (hex.length % 2 !== 0) throw new Error(`invalid hex string length: ${hex}`)
+  const hexEncoded = hexEncoding.parse(hex)
+  const ProgramSha256: any = SHA256(hexEncoded)
+  return RIPEMD160(ProgramSha256).toString()
+}
+
+/**
+ * Computes a single SHA256 digest.
+ * @param {string} hex message to hash
+ * @returns {string} hash output
+ */
+export const sha256 = (hex: string) => {
+  if (typeof hex !== "string") throw new Error("sha256 expects a hex string")
+  if (hex.length % 2 !== 0) throw new Error(`invalid hex string length: ${hex}`)
+  const hexEncoded = hexEncoding.parse(hex)
+  return SHA256(hexEncoded).toString()
+}
+
+/**
+ * Computes a single SHA3 (Keccak) digest.
+ * @param {string} hex message to hash
+ * @returns {string} hash output
+ */
+export const sha3 = (hex: string) => {
+  if (typeof hex !== "string") throw new Error("sha3 expects a hex string")
+  if (hex.length % 2 !== 0) throw new Error(`invalid hex string length: ${hex}`)
+  const hexEncoded = hexEncoding.parse(hex)
+  return SHA3(hexEncoded).toString()
+}
+
+/**
+ * Computes sha256 of random number and timestamp
+ * @param {String} randomNumber
+ * @param {Number} timestamp
+ * @returns {string} sha256 result
+ */
+export const calculateRandomNumberHash = (
+  randomNumber: string,
+  timestamp: number
+) => {
+  const timestampHexStr = timestamp.toString(16)
+  let timestampHexStrFormat = timestampHexStr
+  for (let i = 0; i < 16 - timestampHexStr.length; i++) {
+    timestampHexStrFormat = "0" + timestampHexStrFormat
+  }
+  const timestampBytes = Buffer.from(timestampHexStrFormat, "hex")
+  const newBuffer = Buffer.concat([
+    Buffer.from(randomNumber, "hex"),
+    timestampBytes,
+  ])
+  return sha256(newBuffer.toString("hex"))
+}
+
+/**
+ * Computes swapID
+ * @param {String} randomNumberHash
+ * @param {String} sender
+ * @param {String} senderOtherChain
+ * @returns {string} sha256 result
+ */
+export const calculateSwapID = (
+  randomNumberHash: string,
+  sender: string,
+  senderOtherChain: string
+) => {
+  const randomNumberHashBytes = Buffer.from(randomNumberHash, "hex")
+  const senderBytes = crypto.decodeAddress(sender)
+  const sendOtherChainBytes = Buffer.from(
+    senderOtherChain.toLowerCase(),
+    "utf8"
+  )
+  const newBuffer = Buffer.concat([
+    randomNumberHashBytes,
+    senderBytes,
+    sendOtherChainBytes,
+  ])
+  return sha256(newBuffer.toString("hex"))
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/utils/encoderHelper.ts b/node_modules/@binance-chain/javascript-sdk/src/utils/encoderHelper.ts
new file mode 100644
index 0000000..d8b5e6f
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/utils/encoderHelper.ts
@@ -0,0 +1,33 @@
+import is from "is_js"
+
+// typeToTyp3
+//amino type convert
+export default (type: any): 0 | 1 | 2 => {
+  if (is.boolean(type)) {
+    return 0
+  }
+
+  if (is.number(type)) {
+    if (is.integer(type)) {
+      return 0
+    } else {
+      return 1
+    }
+  }
+
+  if (is.string(type) || is.array(type) || is.object(type)) {
+    return 2
+  }
+
+  throw new Error(`Invalid type "${type}"`) // Is this what's expected?
+}
+
+export const size = function <T>(
+  items: T[],
+  iter: (it: T, index: number, acc: number) => number,
+  acc: number
+): number {
+  if (acc === undefined) acc = 0
+  for (let i = 0; i < items.length; ++i) acc += iter(items[i], i, acc)
+  return acc
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/utils/index.ts b/node_modules/@binance-chain/javascript-sdk/src/utils/index.ts
new file mode 100644
index 0000000..1cfc5b6
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/utils/index.ts
@@ -0,0 +1,5 @@
+export * from "./cryptoHelper"
+export * from "./encoderHelper"
+export * from "./validateHelper"
+export * from "./rpcHelper"
+export * from "./request"
diff --git a/node_modules/@binance-chain/javascript-sdk/src/utils/request.ts b/node_modules/@binance-chain/javascript-sdk/src/utils/request.ts
new file mode 100644
index 0000000..a85e4e2
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/utils/request.ts
@@ -0,0 +1,57 @@
+import axios, { AxiosInstance, Method, AxiosRequestConfig } from "axios"
+
+export class HttpRequest {
+  private httpClient: AxiosInstance
+
+  constructor(baseURL: string) {
+    this.httpClient = axios.create({ baseURL })
+  }
+
+  get(path: string, params?: any, opts?: AxiosRequestConfig) {
+    return this.request("get", path, params, opts)
+  }
+
+  post(path: string, body?: any, opts?: AxiosRequestConfig) {
+    return this.request("post", path, body, opts)
+  }
+
+  request(
+    method: Method,
+    path: string,
+    params?: any,
+    opts: AxiosRequestConfig = {}
+  ) {
+    const options = {
+      method,
+      url: path,
+      ...opts,
+    }
+
+    if (params) {
+      if (method === "get") {
+        options.params = params
+      } else {
+        options.data = params
+      }
+    }
+
+    return this.httpClient
+      .request(options)
+      .then((response) => {
+        return { result: response.data, status: response.status }
+      })
+      .catch((err) => {
+        let error = err
+        try {
+          const msgObj = err.response && err.response.data
+          error = new Error(msgObj.message)
+          error.code = msgObj.code
+        } catch (err) {
+          throw error
+        }
+        throw error
+      })
+  }
+}
+
+export default HttpRequest
diff --git a/node_modules/@binance-chain/javascript-sdk/src/utils/rpcHelper.ts b/node_modules/@binance-chain/javascript-sdk/src/utils/rpcHelper.ts
new file mode 100644
index 0000000..4006f64
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/utils/rpcHelper.ts
@@ -0,0 +1,64 @@
+import Big, { BigSource } from "big.js"
+
+import {
+  AminoPrefix,
+  NewOrderMsg,
+  CancelOrderMsg,
+  SendMsg,
+  BaseMsg,
+  BurnTokenMsg,
+  IssueTokenMsg,
+  FreezeTokenMsg,
+  UnFreezeTokenMsg,
+  TimeLockMsg,
+  TimeUnlockMsg,
+  MintTokenMsg,
+  TimeReLockMsg,
+} from "../types"
+
+export const BASENUMBER = Math.pow(10, 8)
+
+export const divide = (num: BigSource) => {
+  return +new Big(num).div(BASENUMBER).toString()
+}
+
+export const convertObjectArrayNum = <T extends { [k: string]: BigSource }>(
+  objArr: Array<T>,
+  keys: Array<keyof T>
+): void => {
+  objArr.forEach((item) => {
+    keys.forEach((key) => {
+      item[key] = divide(item[key]) as any
+    })
+  })
+}
+
+//TODO add gov and swap
+export const getMsgByAminoPrefix = (aminoPrefix: string) => {
+  switch (aminoPrefix.toUpperCase()) {
+    case AminoPrefix.NewOrderMsg:
+      return NewOrderMsg
+    case AminoPrefix.CancelOrderMsg:
+      return CancelOrderMsg
+    case AminoPrefix.MsgSend:
+      return SendMsg
+    case AminoPrefix.IssueMsg:
+      return IssueTokenMsg
+    case AminoPrefix.FreezeMsg:
+      return FreezeTokenMsg
+    case AminoPrefix.UnfreezeMsg:
+      return UnFreezeTokenMsg
+    case AminoPrefix.BurnMsg:
+      return BurnTokenMsg
+    case AminoPrefix.MintMsg:
+      return MintTokenMsg
+    case AminoPrefix.TimeLockMsg:
+      return TimeLockMsg
+    case AminoPrefix.TimeRelockMsg:
+      return TimeReLockMsg
+    case AminoPrefix.TimeUnlockMsg:
+      return TimeUnlockMsg
+    default:
+      return BaseMsg
+  }
+}
diff --git a/node_modules/@binance-chain/javascript-sdk/src/utils/validateHelper.ts b/node_modules/@binance-chain/javascript-sdk/src/utils/validateHelper.ts
new file mode 100644
index 0000000..58faf60
--- /dev/null
+++ b/node_modules/@binance-chain/javascript-sdk/src/utils/validateHelper.ts
@@ -0,0 +1,66 @@
+import Big, { BigSource } from "big.js"
+
+import { Coin } from "../types"
+
+const MAX_INT64 = Math.pow(2, 63)
+
+/**
+ * validate the input number.
+ * @param {Number} value
+ */
+export const checkNumber = (value: BigSource, name = "input number") => {
+  if (new Big(value).lte(0)) {
+    throw new Error(`${name} should be a positive number`)
+  }
+
+  if (new Big(value).gte(MAX_INT64)) {
+    throw new Error(`${name} should be less than 2^63`)
+  }
+}
+
+/**
+ * basic validation of coins
+ * @param {Array} coins
+ */
+export const checkCoins = (coins: Coin[]) => {
+  coins = coins || []
+  coins.forEach((coin) => {
+    checkNumber(coin.amount)
+    if (!coin.denom) {
+      throw new Error("invalid denmon")
+    }
+  })
+}
+
+export const validateSymbol = (symbol: string) => {
+  if (!symbol) {
+    throw new Error("suffixed token symbol cannot be empty")
+  }
+
+  const splitSymbols = symbol.split("-")
+
+  //check length with .B suffix
+  if (!/^[a-zA-z\d/.]{3,10}$/.test(splitSymbols[0])) {
+    throw new Error("symbol length is limited to 3~10")
+  }
+}
+
+export const validateTradingPair = (pair: string) => {
+  const symbols = pair.split("_")
+  if (symbols.length !== 2) {
+    throw new Error('the pair should in format "symbol1_symbol2"')
+  }
+
+  validateSymbol(symbols[0])
+  validateSymbol(symbols[1])
+}
+
+export const validateOffsetLimit = (offset: number, limit: number) => {
+  if (offset < 0) {
+    throw new Error("offset can't be less than 0")
+  }
+
+  if (limit < 0) {
+    throw new Error("limit can't be less than 0")
+  }
+}
